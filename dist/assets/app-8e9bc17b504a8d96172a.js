/*! For license information please see app-8e9bc17b504a8d96172a.js.LICENSE.txt */
(()=>{var e={349:(e,t,n)=>{var r,a=(r=(r="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){function t(){return N.buffer!=D&&z(N.buffer),M}function a(){return N.buffer!=D&&z(N.buffer),L}function s(){return N.buffer!=D&&z(N.buffer),P}function o(){return N.buffer!=D&&z(N.buffer),B}function i(){return N.buffer!=D&&z(N.buffer),W}var u,l,c,d=void 0!==(e=e||{})?e:{};d.ready=new Promise((function(e,t){u=e,l=t})),"undefined"!=typeof process&&process.listeners&&(c={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var p,h,f,m=Object.assign({},d),g=[],x=(e,t)=>{throw t},b="object"==typeof window,y="function"==typeof importScripts,w="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,v=d.ENVIRONMENT_IS_PTHREAD||!1,I="";function k(e){return d.locateFile?d.locateFile(e,I):I+e}if(w){var C,$;let e;I=y?n(980).dirname(I)+"/":"//",C=n(256),$=n(980),p=(e,t)=>(e=$.normalize(e),C.readFileSync(e,t?void 0:"utf8")),f=e=>{var t=p(e,!0);return t.buffer||(t=new Uint8Array(t)),t},h=(e,t,n)=>{e=$.normalize(e),C.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),g=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ie))throw e})),process.on("unhandledRejection",(function(e){throw e})),x=(e,t)=>{if(Y())throw process.exitCode=e,t;var n;(n=t)instanceof ie||R("exiting due to exception: "+n),process.exit(e)},d.inspect=function(){return"[Emscripten Module object]"};try{e=n(958)}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}n.g.Worker=e.Worker}else(b||y)&&(y?I=self.location.href:"undefined"!=typeof document&&document.currentScript&&(I=document.currentScript.src),void 0!==r&&r&&(I=r),I=0!==I.indexOf("blob:")?I.substr(0,I.replace(/[?#].*/,"").lastIndexOf("/")+1):"",w||(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},y&&(f=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),h=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));w&&"undefined"==typeof performance&&(n.g.performance=n(862).performance);var S=console.log.bind(console),_=console.warn.bind(console);w&&(S=e=>C.writeSync(1,e+"\n"),_=e=>C.writeSync(2,e+"\n"));var E,T=d.print||S,R=d.printErr||_;Object.assign(d,m),m=null,d.arguments&&(g=d.arguments),d.thisProgram&&d.thisProgram,d.quit&&(x=d.quit),Atomics.load,Atomics.store,Atomics.compareExchange,d.wasmBinary&&(E=d.wasmBinary);var N,A,F=d.noExitRuntime||!0;"object"!=typeof WebAssembly&&ne("no native wasm support detected");var O,D,M,L,P,B,W,U=!1,V="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function G(e,t,n){for(var r=t+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.buffer&&V)return V.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,a):e.subarray(t,a));for(var s="";t<a;){var o=e[t++];if(128&o){var i=63&e[t++];if(192!=(224&o)){var u=63&e[t++];if((o=224==(240&o)?(15&o)<<12|i<<6|u:(7&o)<<18|i<<12|u<<6|63&e[t++])<65536)s+=String.fromCharCode(o);else{var l=o-65536;s+=String.fromCharCode(55296|l>>10,56320|1023&l)}}else s+=String.fromCharCode((31&o)<<6|i)}else s+=String.fromCharCode(o)}return s}function z(e){D=e,d.HEAP8=M=new Int8Array(e),d.HEAP16=new Int16Array(e),d.HEAP32=P=new Int32Array(e),d.HEAPU8=L=new Uint8Array(e),d.HEAPU16=new Uint16Array(e),d.HEAPU32=B=new Uint32Array(e),d.HEAPF32=new Float32Array(e),d.HEAPF64=W=new Float64Array(e)}v&&(D=d.buffer);var H,j=d.INITIAL_MEMORY||16777216;if(v)N=d.wasmMemory,D=d.buffer;else if(d.wasmMemory)N=d.wasmMemory;else if(!((N=new WebAssembly.Memory({initial:j/65536,maximum:32768,shared:!0})).buffer instanceof SharedArrayBuffer))throw R("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),w&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");N&&(D=N.buffer),j=D.byteLength,z(D);var X=[],q=[],K=[];function Y(){return F}function Q(){v||he(q)}var Z,J=0,ee=null,te=null;function ne(e){v?postMessage({cmd:"onAbort",arg:e}):d.onAbort&&d.onAbort(e),R(e="Aborted("+e+")"),U=!0,O=1,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw l(t),t}function re(e){return e.startsWith("data:application/octet-stream;base64,")}function ae(e){return e.startsWith("file://")}function se(e){try{if(e==Z&&E)return new Uint8Array(E);if(f)return f(e);throw"both async and sync fetching of the wasm failed"}catch(e){ne(e)}}re(Z="tfjs-backend-wasm-threaded-simd.wasm")||(Z=k(Z));var oe={};function ie(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function ue(e){var t=pe.pthreads[e];t||ne(undefined),pe.returnWorkerToPool(t)}function le(e){var t=pe.getNewWorker();if(!t)return 6;pe.runningWorkers.push(t),pe.pthreads[e.pthread_ptr]=t,t.pthread_ptr=e.pthread_ptr;var n={cmd:"run",start_routine:e.startRoutine,arg:e.arg,pthread_ptr:e.pthread_ptr};return t.runPthread=()=>{n.time=performance.now(),t.postMessage(n,e.transferList)},t.loaded&&(t.runPthread(),delete t.runPthread),0}function ce(e){if(v)return Ie(1,1,e);O=e,Y()||(pe.terminateAllThreads(),d.onExit&&d.onExit(e),U=!0),x(e,new ie(e))}var de=function(e,t){if(O=e,!t&&v)throw me(e),"unwind";ce(e)},pe={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){v?pe.initWorker():pe.initMainThread()},initMainThread:function(){for(var e=8;e--;)pe.allocateUnusedWorker()},initWorker:function(){F=!1},setExitStatus:function(e){O=e},terminateAllThreads:function(){for(var e of Object.values(pe.pthreads))pe.returnWorkerToPool(e);for(var e of pe.unusedWorkers)e.terminate();pe.unusedWorkers=[]},returnWorkerToPool:function(e){var t=e.pthread_ptr;delete pe.pthreads[t],pe.unusedWorkers.push(e),pe.runningWorkers.splice(pe.runningWorkers.indexOf(e),1),e.pthread_ptr=0,Ue(t)},receiveObjectTransfer:function(e){},threadInitTLS:function(){pe.tlsInitFunctions.forEach((e=>e()))},loadWasmModuleToWorker:function(e,t){e.onmessage=n=>{var r,a=n.data,s=a.cmd;if(e.pthread_ptr&&(pe.currentProxiedOperationCallerThread=e.pthread_ptr),a.targetThread&&a.targetThread!=Le()){var o=pe.pthreads[a.targetThread];return o?o.postMessage(a,a.transferList):R('Internal error! Worker sent a message "'+s+'" to target pthread '+a.targetThread+", but that thread no longer exists!"),void(pe.currentProxiedOperationCallerThread=void 0)}"processProxyingQueue"===s?we(a.queue):"spawnThread"===s?le(a):"cleanupThread"===s?ue(a.thread):"killThread"===s?function(e){var t=pe.pthreads[e];delete pe.pthreads[e],t.terminate(),Ue(e),pe.runningWorkers.splice(pe.runningWorkers.indexOf(t),1),t.pthread_ptr=0}(a.thread):"cancelThread"===s?(r=a.thread,pe.pthreads[r].postMessage({cmd:"cancel"})):"loaded"===s?(e.loaded=!0,t&&t(e),e.runPthread&&(e.runPthread(),delete e.runPthread)):"print"===s?T("Thread "+a.threadId+": "+a.text):"printErr"===s?R("Thread "+a.threadId+": "+a.text):"alert"===s?alert("Thread "+a.threadId+": "+a.text):"setimmediate"===a.target?e.postMessage(a):"onAbort"===s?d.onAbort&&d.onAbort(a.arg):s&&R("worker sent an unknown command "+s),pe.currentProxiedOperationCallerThread=void 0},e.onerror=e=>{throw R("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},w&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){}))),e.postMessage({cmd:"load",urlOrBlob:d.mainScriptUrlOrBlob||r,wasmMemory:N,wasmModule:A})},allocateUnusedWorker:function(){var e=k("tfjs-backend-wasm-threaded-simd.worker.js");pe.unusedWorkers.push(new Worker(e))},getNewWorker:function(){return 0==pe.unusedWorkers.length&&(pe.allocateUnusedWorker(),pe.loadWasmModuleToWorker(pe.unusedWorkers[0])),pe.unusedWorkers.pop()}};function he(e){for(;e.length>0;)e.shift()(d)}function fe(e){var t=ze(),n=e();return He(t),n}function me(e){if(v)return Ie(2,0,e);try{de(e)}catch(e){!function(e){if(e instanceof ie||"unwind"==e)return O;x(1,e)}(e)}}d.PThread=pe,d.establishStackSpace=function(){var e=Le(),t=s()[e+44>>2],n=s()[e+48>>2];Ge(t,t-n),He(t)};var ge,xe=[];function be(e,t,n,r){return v?Ie(3,1,e,t,n,r):ye(e,t,n,r)}function ye(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return R("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];if(v&&0===a.length)return be(e,t,n,r);var s={startRoutine:n,pthread_ptr:e,arg:r,transferList:a};return v?(s.cmd="spawnThread",postMessage(s,a),0):le(s)}function we(e){Atomics.store(s(),e>>2,1),Le()&&We(e),Atomics.compareExchange(s(),e>>2,1,0)}function ve(e){ve.shown||(ve.shown={}),ve.shown[e]||(ve.shown[e]=1,w&&(e="warning: "+e),R(e))}function Ie(e,t){var n=arguments.length-2,r=arguments;return fe((()=>{for(var a=n,s=je(8*a),o=s>>3,u=0;u<n;u++){var l=r[2+u];i()[o+u]=l}return Be(e,a,s,t)}))}d.invokeEntryPoint=function(e,t){var n,r,a=((r=xe[n=e])||(n>=xe.length&&(xe.length=n+1),xe[n]=r=H.get(n)),r)(t);Y()?pe.setExitStatus(a):Ve(a)},d.executeNotifiedProxyingQueue=we,ge=w?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:v?()=>performance.now()-d.__performance_now_clock_drift:()=>performance.now();var ke=[];function Ce(e){try{return N.grow(e-D.byteLength+65535>>>16),z(N.buffer),1}catch(e){}}function $e(e){return v?Ie(4,1,e):52}function Se(e,t,n,r,a){return v?Ie(5,1,e,t,n,r,a):70}var _e=[null,[],[]];function Ee(e,t){var n=_e[e];0===t||10===t?((1===e?T:R)(G(n,0)),n.length=0):n.push(t)}function Te(e,t,n,r){if(v)return Ie(6,1,e,t,n,r);for(var s=0,i=0;i<n;i++){var u=o()[t>>2],l=o()[t+4>>2];t+=8;for(var c=0;c<l;c++)Ee(e,a()[u+c]);s+=l}return o()[r>>2]=s,0}function Re(e){return d["_"+e]}function Ne(e,n,r,s,o){var i={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);!function(e,t,n){!function(e,t,n,r){if(!(r>0))return 0;for(var a=n+r-1,s=0;s<e.length;++s){var o=e.charCodeAt(s);if(o>=55296&&o<=57343&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++s)),o<=127){if(n>=a)break;t[n++]=o}else if(o<=2047){if(n+1>=a)break;t[n++]=192|o>>6,t[n++]=128|63&o}else if(o<=65535){if(n+2>=a)break;t[n++]=224|o>>12,t[n++]=128|o>>6&63,t[n++]=128|63&o}else{if(n+3>=a)break;t[n++]=240|o>>18,t[n++]=128|o>>12&63,t[n++]=128|o>>6&63,t[n++]=128|63&o}}t[n]=0}(e,a(),t,n)}(e,t=je(n),n)}return t},array:e=>{var n=je(e.length);return function(e,n){t().set(e,n)}(e,n),n}},u=Re(e),l=[],c=0;if(s)for(var d=0;d<s.length;d++){var p=i[r[d]];p?(0===c&&(c=ze()),l[d]=p(s[d])):l[d]=s[d]}var h=u.apply(null,l);return function(e){return 0!==c&&He(c),function(e){return"string"===n?(t=e)?G(a(),t,r):"":"boolean"===n?Boolean(e):e;var t,r}(e)}(h)}pe.init();var Ae,Fe,Oe,De=[null,ce,me,be,$e,Se,Te],Me={__emscripten_init_main_thread_js:function(e){Pe(e,!y,1,!b),pe.threadInitTLS()},__emscripten_thread_cleanup:function(e){v?postMessage({cmd:"cleanupThread",thread:e}):ue(e)},__pthread_create_js:ye,_emscripten_default_pthread_stack_size:function(){return 2097152},_emscripten_get_now_is_monotonic:function(){return!0},_emscripten_notify_task_queue:function(e,t,n,r){if(e==t)setTimeout((()=>we(r)));else if(v)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{var a=pe.pthreads[e];if(!a)return;a.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},_emscripten_set_offscreencanvas_size:function(e,t,n){return-1},abort:function(){ne("")},emscripten_check_blocking_allowed:function(){w||y||ve("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_date_now:function(){return Date.now()},emscripten_get_heap_max:function(){return 2147483648},emscripten_get_now:ge,emscripten_memcpy_big:function(e,t,n){a().copyWithin(e,t,t+n)},emscripten_num_logical_cores:function(){return w?n(578).cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function(e,t,n){ke.length=t;for(var r=n>>3,a=0;a<t;a++)ke[a]=i()[r+a];return(e<0?oe[-e-1]:De[e]).apply(null,ke)},emscripten_resize_heap:function(e){var t=a().length;if((e>>>=0)<=t)return!1;var n,r=2147483648;if(e>r)return!1;for(var s=1;s<=4;s*=2){var o=t*(1+.2/s);if(o=Math.min(o,e+100663296),Ce(Math.min(r,(n=Math.max(e,o))+(65536-n%65536)%65536)))return!0}return!1},emscripten_unwind_to_js_event_loop:function(){throw"unwind"},exit:de,fd_close:$e,fd_seek:Se,fd_write:Te,memory:N||d.wasmMemory},Le=(function(){var e={env:Me,wasi_snapshot_preview1:Me};function t(e,t){var n,r,a=e.exports;if(d.asm=a,n=d.asm._emscripten_tls_init,pe.tlsInitFunctions.push(n),H=d.asm.__indirect_function_table,r=d.asm.__wasm_call_ctors,q.unshift(r),A=t,!v){var s=pe.unusedWorkers.length;pe.unusedWorkers.forEach((function(e){pe.loadWasmModuleToWorker(e,(function(){--s||function(e){if(J--,d.monitorRunDependencies&&d.monitorRunDependencies(J),0==J&&(null!==ee&&(clearInterval(ee),ee=null),te)){var t=te;te=null,t()}}()}))}))}}function n(e){t(e.instance,e.module)}function r(t){return function(){if(!E&&(b||y)){if("function"==typeof fetch&&!ae(Z))return fetch(Z,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+Z+"'";return e.arrayBuffer()})).catch((function(){return se(Z)}));if(h)return new Promise((function(e,t){h(Z,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return se(Z)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){R("failed to asynchronously prepare wasm: "+e),ne(e)}))}if(v||(J++,d.monitorRunDependencies&&d.monitorRunDependencies(J)),d.instantiateWasm)try{return d.instantiateWasm(e,t)}catch(e){R("Module.instantiateWasm callback failed with error: "+e),l(e)}(E||"function"!=typeof WebAssembly.instantiateStreaming||re(Z)||ae(Z)||w||"function"!=typeof fetch?r(n):fetch(Z,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return R("wasm streaming compile failed: "+e),R("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(l)}(),d.___wasm_call_ctors=function(){return(d.___wasm_call_ctors=d.asm.__wasm_call_ctors).apply(null,arguments)},d._init=function(){return(d._init=d.asm.init).apply(null,arguments)},d._init_with_threads_count=function(){return(d._init_with_threads_count=d.asm.init_with_threads_count).apply(null,arguments)},d._get_threads_count=function(){return(d._get_threads_count=d.asm.get_threads_count).apply(null,arguments)},d._register_tensor=function(){return(d._register_tensor=d.asm.register_tensor).apply(null,arguments)},d._dispose_data=function(){return(d._dispose_data=d.asm.dispose_data).apply(null,arguments)},d._dispose=function(){return(d._dispose=d.asm.dispose).apply(null,arguments)},d._Abs=function(){return(d._Abs=d.asm.Abs).apply(null,arguments)},d._Add=function(){return(d._Add=d.asm.Add).apply(null,arguments)},d._AddN=function(){return(d._AddN=d.asm.AddN).apply(null,arguments)},d._All=function(){return(d._All=d.asm.All).apply(null,arguments)},d._Any=function(){return(d._Any=d.asm.Any).apply(null,arguments)},d._ArgMax=function(){return(d._ArgMax=d.asm.ArgMax).apply(null,arguments)},d._AvgPool=function(){return(d._AvgPool=d.asm.AvgPool).apply(null,arguments)},d._BatchMatMul=function(){return(d._BatchMatMul=d.asm.BatchMatMul).apply(null,arguments)},d._Ceil=function(){return(d._Ceil=d.asm.Ceil).apply(null,arguments)},d._ClipByValue=function(){return(d._ClipByValue=d.asm.ClipByValue).apply(null,arguments)},d._Conv2D=function(){return(d._Conv2D=d.asm.Conv2D).apply(null,arguments)},d._Conv2DBackpropInput=function(){return(d._Conv2DBackpropInput=d.asm.Conv2DBackpropInput).apply(null,arguments)},d._Cos=function(){return(d._Cos=d.asm.Cos).apply(null,arguments)},d._Cosh=function(){return(d._Cosh=d.asm.Cosh).apply(null,arguments)},d._CropAndResize=function(){return(d._CropAndResize=d.asm.CropAndResize).apply(null,arguments)},d._Cumprod=function(){return(d._Cumprod=d.asm.Cumprod).apply(null,arguments)},d._Cumsum=function(){return(d._Cumsum=d.asm.Cumsum).apply(null,arguments)},d._DepthToSpace=function(){return(d._DepthToSpace=d.asm.DepthToSpace).apply(null,arguments)},d._DepthwiseConv2dNative=function(){return(d._DepthwiseConv2dNative=d.asm.DepthwiseConv2dNative).apply(null,arguments)},d._Elu=function(){return(d._Elu=d.asm.Elu).apply(null,arguments)},d._Equal=function(){return(d._Equal=d.asm.Equal).apply(null,arguments)},d._Exp=function(){return(d._Exp=d.asm.Exp).apply(null,arguments)},d._FlipLeftRight=function(){return(d._FlipLeftRight=d.asm.FlipLeftRight).apply(null,arguments)},d._Floor=function(){return(d._Floor=d.asm.Floor).apply(null,arguments)},d._FloorDiv=function(){return(d._FloorDiv=d.asm.FloorDiv).apply(null,arguments)},d._FusedBatchNorm=function(){return(d._FusedBatchNorm=d.asm.FusedBatchNorm).apply(null,arguments)},d._FusedConv2D=function(){return(d._FusedConv2D=d.asm.FusedConv2D).apply(null,arguments)},d._FusedDepthwiseConv2D=function(){return(d._FusedDepthwiseConv2D=d.asm.FusedDepthwiseConv2D).apply(null,arguments)},d._Gather=function(){return(d._Gather=d.asm.Gather).apply(null,arguments)},d._GatherNd=function(){return(d._GatherNd=d.asm.GatherNd).apply(null,arguments)},d._Greater=function(){return(d._Greater=d.asm.Greater).apply(null,arguments)},d._GreaterEqual=function(){return(d._GreaterEqual=d.asm.GreaterEqual).apply(null,arguments)},d._LeakyRelu=function(){return(d._LeakyRelu=d.asm.LeakyRelu).apply(null,arguments)},d._Less=function(){return(d._Less=d.asm.Less).apply(null,arguments)},d._LessEqual=function(){return(d._LessEqual=d.asm.LessEqual).apply(null,arguments)},d._Log=function(){return(d._Log=d.asm.Log).apply(null,arguments)},d._LogicalAnd=function(){return(d._LogicalAnd=d.asm.LogicalAnd).apply(null,arguments)},d._LogicalNot=function(){return(d._LogicalNot=d.asm.LogicalNot).apply(null,arguments)},d._LogicalOr=function(){return(d._LogicalOr=d.asm.LogicalOr).apply(null,arguments)},d._LogicalXor=function(){return(d._LogicalXor=d.asm.LogicalXor).apply(null,arguments)},d._Max=function(){return(d._Max=d.asm.Max).apply(null,arguments)},d._MaxPool=function(){return(d._MaxPool=d.asm.MaxPool).apply(null,arguments)},d._Maximum=function(){return(d._Maximum=d.asm.Maximum).apply(null,arguments)},d._Mean=function(){return(d._Mean=d.asm.Mean).apply(null,arguments)},d._Min=function(){return(d._Min=d.asm.Min).apply(null,arguments)},d._Minimum=function(){return(d._Minimum=d.asm.Minimum).apply(null,arguments)},d._MirrorPad=function(){return(d._MirrorPad=d.asm.MirrorPad).apply(null,arguments)},d._Multiply=function(){return(d._Multiply=d.asm.Multiply).apply(null,arguments)},d._Neg=function(){return(d._Neg=d.asm.Neg).apply(null,arguments)},d._NonMaxSuppressionV3=function(){return(d._NonMaxSuppressionV3=d.asm.NonMaxSuppressionV3).apply(null,arguments)},d._NonMaxSuppressionV4=function(){return(d._NonMaxSuppressionV4=d.asm.NonMaxSuppressionV4).apply(null,arguments)},d._NonMaxSuppressionV5=function(){return(d._NonMaxSuppressionV5=d.asm.NonMaxSuppressionV5).apply(null,arguments)},d._NotEqual=function(){return(d._NotEqual=d.asm.NotEqual).apply(null,arguments)},d._OneHot=function(){return(d._OneHot=d.asm.OneHot).apply(null,arguments)},d._PadV2=function(){return(d._PadV2=d.asm.PadV2).apply(null,arguments)},d._Pow=function(){return(d._Pow=d.asm.Pow).apply(null,arguments)},d._Prelu=function(){return(d._Prelu=d.asm.Prelu).apply(null,arguments)},d._Prod=function(){return(d._Prod=d.asm.Prod).apply(null,arguments)},d._RealDiv=function(){return(d._RealDiv=d.asm.RealDiv).apply(null,arguments)},d._Relu=function(){return(d._Relu=d.asm.Relu).apply(null,arguments)},d._Relu6=function(){return(d._Relu6=d.asm.Relu6).apply(null,arguments)},d._ResizeBilinear=function(){return(d._ResizeBilinear=d.asm.ResizeBilinear).apply(null,arguments)},d._ResizeNearestNeighbor=function(){return(d._ResizeNearestNeighbor=d.asm.ResizeNearestNeighbor).apply(null,arguments)},d._Reverse=function(){return(d._Reverse=d.asm.Reverse).apply(null,arguments)},d._RotateWithOffset=function(){return(d._RotateWithOffset=d.asm.RotateWithOffset).apply(null,arguments)},d._Round=function(){return(d._Round=d.asm.Round).apply(null,arguments)},d._Rsqrt=function(){return(d._Rsqrt=d.asm.Rsqrt).apply(null,arguments)},d._ScatterNd=function(){return(d._ScatterNd=d.asm.ScatterNd).apply(null,arguments)},d._SelectV2=function(){return(d._SelectV2=d.asm.SelectV2).apply(null,arguments)},d._Sigmoid=function(){return(d._Sigmoid=d.asm.Sigmoid).apply(null,arguments)},d._Sin=function(){return(d._Sin=d.asm.Sin).apply(null,arguments)},d._Softmax=function(){return(d._Softmax=d.asm.Softmax).apply(null,arguments)},d._SparseFillEmptyRows=function(){return(d._SparseFillEmptyRows=d.asm.SparseFillEmptyRows).apply(null,arguments)},d._SparseReshape=function(){return(d._SparseReshape=d.asm.SparseReshape).apply(null,arguments)},d._SparseSegmentReduction=function(){return(d._SparseSegmentReduction=d.asm.SparseSegmentReduction).apply(null,arguments)},d._Sqrt=function(){return(d._Sqrt=d.asm.Sqrt).apply(null,arguments)},d._Square=function(){return(d._Square=d.asm.Square).apply(null,arguments)},d._SquaredDifference=function(){return(d._SquaredDifference=d.asm.SquaredDifference).apply(null,arguments)},d._Step=function(){return(d._Step=d.asm.Step).apply(null,arguments)},d._StridedSlice=function(){return(d._StridedSlice=d.asm.StridedSlice).apply(null,arguments)},d._Sub=function(){return(d._Sub=d.asm.Sub).apply(null,arguments)},d._Sum=function(){return(d._Sum=d.asm.Sum).apply(null,arguments)},d._Tan=function(){return(d._Tan=d.asm.Tan).apply(null,arguments)},d._Tanh=function(){return(d._Tanh=d.asm.Tanh).apply(null,arguments)},d._Tile=function(){return(d._Tile=d.asm.Tile).apply(null,arguments)},d._TopK=function(){return(d._TopK=d.asm.TopK).apply(null,arguments)},d._Transform=function(){return(d._Transform=d.asm.Transform).apply(null,arguments)},d._Transpose=function(){return(d._Transpose=d.asm.Transpose).apply(null,arguments)},d.__FusedMatMul=function(){return(d.__FusedMatMul=d.asm._FusedMatMul).apply(null,arguments)},d._malloc=function(){return(d._malloc=d.asm.malloc).apply(null,arguments)},d._free=function(){return(d._free=d.asm.free).apply(null,arguments)},d.__emscripten_tls_init=function(){return(d.__emscripten_tls_init=d.asm._emscripten_tls_init).apply(null,arguments)},d._pthread_self=function(){return(Le=d._pthread_self=d.asm.pthread_self).apply(null,arguments)}),Pe=(d.___errno_location=function(){return(d.___errno_location=d.asm.__errno_location).apply(null,arguments)},d.__emscripten_thread_init=function(){return(Pe=d.__emscripten_thread_init=d.asm._emscripten_thread_init).apply(null,arguments)}),Be=(d.__emscripten_thread_crashed=function(){return(d.__emscripten_thread_crashed=d.asm._emscripten_thread_crashed).apply(null,arguments)},d._emscripten_main_thread_process_queued_calls=function(){return(d._emscripten_main_thread_process_queued_calls=d.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},d._emscripten_main_browser_thread_id=function(){return(d._emscripten_main_browser_thread_id=d.asm.emscripten_main_browser_thread_id).apply(null,arguments)},d._emscripten_run_in_main_runtime_thread_js=function(){return(Be=d._emscripten_run_in_main_runtime_thread_js=d.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)}),We=(d._emscripten_dispatch_to_thread_=function(){return(d._emscripten_dispatch_to_thread_=d.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},d.__emscripten_proxy_execute_task_queue=function(){return(We=d.__emscripten_proxy_execute_task_queue=d.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)}),Ue=d.__emscripten_thread_free_data=function(){return(Ue=d.__emscripten_thread_free_data=d.asm._emscripten_thread_free_data).apply(null,arguments)},Ve=d.__emscripten_thread_exit=function(){return(Ve=d.__emscripten_thread_exit=d.asm._emscripten_thread_exit).apply(null,arguments)},Ge=d._emscripten_stack_set_limits=function(){return(Ge=d._emscripten_stack_set_limits=d.asm.emscripten_stack_set_limits).apply(null,arguments)},ze=d.stackSave=function(){return(ze=d.stackSave=d.asm.stackSave).apply(null,arguments)},He=d.stackRestore=function(){return(He=d.stackRestore=d.asm.stackRestore).apply(null,arguments)},je=d.stackAlloc=function(){return(je=d.stackAlloc=d.asm.stackAlloc).apply(null,arguments)};function Xe(e){if(e=e||g,!(J>0)){if(v)return u(d),Q(),void postMessage({cmd:"loaded"});!function(){if(d.preRun)for("function"==typeof d.preRun&&(d.preRun=[d.preRun]);d.preRun.length;)e=d.preRun.shift(),X.unshift(e);var e;he(X)}(),J>0||(d.setStatus?(d.setStatus("Running..."),setTimeout((function(){setTimeout((function(){d.setStatus("")}),1),t()}),1)):t())}function t(){Ae||(Ae=!0,d.calledRun=!0,U||(Q(),u(d),d.onRuntimeInitialized&&d.onRuntimeInitialized(),function(){if(!v){if(d.postRun)for("function"==typeof d.postRun&&(d.postRun=[d.postRun]);d.postRun.length;)e=d.postRun.shift(),K.unshift(e);var e;he(K)}}()))}}if(d.dynCall_iijjiiii=function(){return(d.dynCall_iijjiiii=d.asm.dynCall_iijjiiii).apply(null,arguments)},d.dynCall_jiji=function(){return(d.dynCall_jiji=d.asm.dynCall_jiji).apply(null,arguments)},d.keepRuntimeAlive=Y,d.wasmMemory=N,d.cwrap=function(e,t,n,r){var a=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&a&&!r?Re(e):function(){return Ne(e,t,n,arguments)}},d.ExitStatus=ie,d.PThread=pe,te=function e(){Ae||Xe(),Ae||(te=e)},d.preInit)for("function"==typeof d.preInit&&(d.preInit=[d.preInit]);d.preInit.length>0;)d.preInit.pop()();if(Xe(),c&&(Fe={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!c.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!c.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof WasmBackendModule)Oe=WasmBackendModule;else{if(void 0===e)throw new Error("Could not find wasm module in post.js");Oe=e}if(Fe){var qe=Oe._dispose;Oe._dispose=function(){qe(),Fe.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Fe.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return e.ready});e.exports=a},142:e=>{e.exports.g='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance})}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};'},234:(e,t,n)=>{var r,a=(r=(r="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){var t,a,s,o=void 0!==(e=e||{})?e:{};o.ready=new Promise((function(e,n){t=e,a=n})),"undefined"!=typeof process&&process.listeners&&(s={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var i,u,l,c,d,p=Object.assign({},o),h=[],f="object"==typeof window,m="function"==typeof importScripts,g="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,x="";g?(x=m?n(980).dirname(x)+"/":"//",c=n(256),d=n(980),i=(e,t)=>(e=d.normalize(e),c.readFileSync(e,t?void 0:"utf8")),l=e=>{var t=i(e,!0);return t.buffer||(t=new Uint8Array(t)),t},u=(e,t,n)=>{e=d.normalize(e),c.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),h=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof V))throw e})),process.on("unhandledRejection",(function(e){throw e})),o.inspect=function(){return"[Emscripten Module object]"}):(f||m)&&(m?x=self.location.href:"undefined"!=typeof document&&document.currentScript&&(x=document.currentScript.src),r&&(x=r),x=0!==x.indexOf("blob:")?x.substr(0,x.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},m&&(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),u=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var b,y,w=o.print||console.log.bind(console),v=o.printErr||console.warn.bind(console);Object.assign(o,p),p=null,o.arguments&&(h=o.arguments),o.thisProgram&&o.thisProgram,o.quit&&o.quit,o.wasmBinary&&(b=o.wasmBinary),o.noExitRuntime,"object"!=typeof WebAssembly&&P("no native wasm support detected");var I,k,C,$,S=!1,_="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function E(e,t,n){for(var r=t+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.buffer&&_)return _.decode(e.subarray(t,a));for(var s="";t<a;){var o=e[t++];if(128&o){var i=63&e[t++];if(192!=(224&o)){var u=63&e[t++];if((o=224==(240&o)?(15&o)<<12|i<<6|u:(7&o)<<18|i<<12|u<<6|63&e[t++])<65536)s+=String.fromCharCode(o);else{var l=o-65536;s+=String.fromCharCode(55296|l>>10,56320|1023&l)}}else s+=String.fromCharCode((31&o)<<6|i)}else s+=String.fromCharCode(o)}return s}function T(e){I=e,o.HEAP8=k=new Int8Array(e),o.HEAP16=new Int16Array(e),o.HEAP32=new Int32Array(e),o.HEAPU8=C=new Uint8Array(e),o.HEAPU16=new Uint16Array(e),o.HEAPU32=$=new Uint32Array(e),o.HEAPF32=new Float32Array(e),o.HEAPF64=new Float64Array(e)}o.INITIAL_MEMORY;var R,N,A=[],F=[],O=[],D=0,M=null,L=null;function P(e){o.onAbort&&o.onAbort(e),v(e="Aborted("+e+")"),S=!0,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw a(t),t}function B(e){return e.startsWith("data:application/octet-stream;base64,")}function W(e){return e.startsWith("file://")}function U(e){try{if(e==R&&b)return new Uint8Array(b);if(l)return l(e);throw"both async and sync fetching of the wasm failed"}catch(e){P(e)}}function V(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function G(e){for(;e.length>0;)e.shift()(o)}function z(e){try{return y.grow(e-I.byteLength+65535>>>16),T(y.buffer),1}catch(e){}}B(R="tfjs-backend-wasm.wasm")||(N=R,R=o.locateFile?o.locateFile(N,x):x+N);var H=[null,[],[]];function j(e,t){var n=H[e];0===t||10===t?((1===e?w:v)(E(n,0)),n.length=0):n.push(t)}function X(e){return o["_"+e]}function q(e,t,n,r,a){var s={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);!function(e,t,n){!function(e,t,n,r){if(!(r>0))return 0;for(var a=n+r-1,s=0;s<e.length;++s){var o=e.charCodeAt(s);if(o>=55296&&o<=57343&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++s)),o<=127){if(n>=a)break;t[n++]=o}else if(o<=2047){if(n+1>=a)break;t[n++]=192|o>>6,t[n++]=128|63&o}else if(o<=65535){if(n+2>=a)break;t[n++]=224|o>>12,t[n++]=128|o>>6&63,t[n++]=128|63&o}else{if(n+3>=a)break;t[n++]=240|o>>18,t[n++]=128|o>>12&63,t[n++]=128|o>>6&63,t[n++]=128|63&o}}t[n]=0}(e,C,t,n)}(e,t=te(n),n)}return t},array:e=>{var t=te(e.length);return function(e,t){k.set(e,t)}(e,t),t}},o=X(e),i=[],u=0;if(r)for(var l=0;l<r.length;l++){var c=s[n[l]];c?(0===u&&(u=J()),i[l]=c(r[l])):i[l]=r[l]}var d=o.apply(null,i);return function(e){return 0!==u&&ee(u),function(e){return"string"===t?(n=e)?E(C,n,r):"":"boolean"===t?Boolean(e):e;var n,r}(e)}(d)}var K,Y,Q,Z={abort:function(){P("")},emscripten_get_heap_max:function(){return 2147483648},emscripten_memcpy_big:function(e,t,n){C.copyWithin(e,t,t+n)},emscripten_resize_heap:function(e){var t,n=C.length,r=2147483648;if((e>>>=0)>r)return!1;for(var a=1;a<=4;a*=2){var s=n*(1+.2/a);if(s=Math.min(s,e+100663296),z(Math.min(r,(t=Math.max(e,s))+(65536-t%65536)%65536)))return!0}return!1},fd_close:function(e){return 52},fd_seek:function(e,t,n,r,a){return 70},fd_write:function(e,t,n,r){for(var a=0,s=0;s<n;s++){var o=$[t>>2],i=$[t+4>>2];t+=8;for(var u=0;u<i;u++)j(e,C[o+u]);a+=i}return $[r>>2]=a,0}},J=(function(){var e={env:Z,wasi_snapshot_preview1:Z};function t(e,t){var n,r=e.exports;o.asm=r,T((y=o.asm.memory).buffer),o.asm.__indirect_function_table,n=o.asm.__wasm_call_ctors,F.unshift(n),function(e){if(D--,o.monitorRunDependencies&&o.monitorRunDependencies(D),0==D&&(null!==M&&(clearInterval(M),M=null),L)){var t=L;L=null,t()}}()}function n(e){t(e.instance)}function r(t){return function(){if(!b&&(f||m)){if("function"==typeof fetch&&!W(R))return fetch(R,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+R+"'";return e.arrayBuffer()})).catch((function(){return U(R)}));if(u)return new Promise((function(e,t){u(R,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return U(R)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){v("failed to asynchronously prepare wasm: "+e),P(e)}))}if(D++,o.monitorRunDependencies&&o.monitorRunDependencies(D),o.instantiateWasm)try{return o.instantiateWasm(e,t)}catch(e){v("Module.instantiateWasm callback failed with error: "+e),a(e)}(b||"function"!=typeof WebAssembly.instantiateStreaming||B(R)||W(R)||g||"function"!=typeof fetch?r(n):fetch(R,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return v("wasm streaming compile failed: "+e),v("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),o.___wasm_call_ctors=function(){return(o.___wasm_call_ctors=o.asm.__wasm_call_ctors).apply(null,arguments)},o._init=function(){return(o._init=o.asm.init).apply(null,arguments)},o._init_with_threads_count=function(){return(o._init_with_threads_count=o.asm.init_with_threads_count).apply(null,arguments)},o._get_threads_count=function(){return(o._get_threads_count=o.asm.get_threads_count).apply(null,arguments)},o._register_tensor=function(){return(o._register_tensor=o.asm.register_tensor).apply(null,arguments)},o._dispose_data=function(){return(o._dispose_data=o.asm.dispose_data).apply(null,arguments)},o._dispose=function(){return(o._dispose=o.asm.dispose).apply(null,arguments)},o._Abs=function(){return(o._Abs=o.asm.Abs).apply(null,arguments)},o._Add=function(){return(o._Add=o.asm.Add).apply(null,arguments)},o._AddN=function(){return(o._AddN=o.asm.AddN).apply(null,arguments)},o._All=function(){return(o._All=o.asm.All).apply(null,arguments)},o._Any=function(){return(o._Any=o.asm.Any).apply(null,arguments)},o._ArgMax=function(){return(o._ArgMax=o.asm.ArgMax).apply(null,arguments)},o._AvgPool=function(){return(o._AvgPool=o.asm.AvgPool).apply(null,arguments)},o._BatchMatMul=function(){return(o._BatchMatMul=o.asm.BatchMatMul).apply(null,arguments)},o._Ceil=function(){return(o._Ceil=o.asm.Ceil).apply(null,arguments)},o._ClipByValue=function(){return(o._ClipByValue=o.asm.ClipByValue).apply(null,arguments)},o._Conv2D=function(){return(o._Conv2D=o.asm.Conv2D).apply(null,arguments)},o._Conv2DBackpropInput=function(){return(o._Conv2DBackpropInput=o.asm.Conv2DBackpropInput).apply(null,arguments)},o._Cos=function(){return(o._Cos=o.asm.Cos).apply(null,arguments)},o._Cosh=function(){return(o._Cosh=o.asm.Cosh).apply(null,arguments)},o._CropAndResize=function(){return(o._CropAndResize=o.asm.CropAndResize).apply(null,arguments)},o._Cumprod=function(){return(o._Cumprod=o.asm.Cumprod).apply(null,arguments)},o._Cumsum=function(){return(o._Cumsum=o.asm.Cumsum).apply(null,arguments)},o._DepthToSpace=function(){return(o._DepthToSpace=o.asm.DepthToSpace).apply(null,arguments)},o._DepthwiseConv2dNative=function(){return(o._DepthwiseConv2dNative=o.asm.DepthwiseConv2dNative).apply(null,arguments)},o._Elu=function(){return(o._Elu=o.asm.Elu).apply(null,arguments)},o._Equal=function(){return(o._Equal=o.asm.Equal).apply(null,arguments)},o._Exp=function(){return(o._Exp=o.asm.Exp).apply(null,arguments)},o._FlipLeftRight=function(){return(o._FlipLeftRight=o.asm.FlipLeftRight).apply(null,arguments)},o._Floor=function(){return(o._Floor=o.asm.Floor).apply(null,arguments)},o._FloorDiv=function(){return(o._FloorDiv=o.asm.FloorDiv).apply(null,arguments)},o._FusedBatchNorm=function(){return(o._FusedBatchNorm=o.asm.FusedBatchNorm).apply(null,arguments)},o._FusedConv2D=function(){return(o._FusedConv2D=o.asm.FusedConv2D).apply(null,arguments)},o._FusedDepthwiseConv2D=function(){return(o._FusedDepthwiseConv2D=o.asm.FusedDepthwiseConv2D).apply(null,arguments)},o._Gather=function(){return(o._Gather=o.asm.Gather).apply(null,arguments)},o._GatherNd=function(){return(o._GatherNd=o.asm.GatherNd).apply(null,arguments)},o._Greater=function(){return(o._Greater=o.asm.Greater).apply(null,arguments)},o._GreaterEqual=function(){return(o._GreaterEqual=o.asm.GreaterEqual).apply(null,arguments)},o._LeakyRelu=function(){return(o._LeakyRelu=o.asm.LeakyRelu).apply(null,arguments)},o._Less=function(){return(o._Less=o.asm.Less).apply(null,arguments)},o._LessEqual=function(){return(o._LessEqual=o.asm.LessEqual).apply(null,arguments)},o._Log=function(){return(o._Log=o.asm.Log).apply(null,arguments)},o._LogicalAnd=function(){return(o._LogicalAnd=o.asm.LogicalAnd).apply(null,arguments)},o._LogicalNot=function(){return(o._LogicalNot=o.asm.LogicalNot).apply(null,arguments)},o._LogicalOr=function(){return(o._LogicalOr=o.asm.LogicalOr).apply(null,arguments)},o._LogicalXor=function(){return(o._LogicalXor=o.asm.LogicalXor).apply(null,arguments)},o._Max=function(){return(o._Max=o.asm.Max).apply(null,arguments)},o._MaxPool=function(){return(o._MaxPool=o.asm.MaxPool).apply(null,arguments)},o._Maximum=function(){return(o._Maximum=o.asm.Maximum).apply(null,arguments)},o._Mean=function(){return(o._Mean=o.asm.Mean).apply(null,arguments)},o._Min=function(){return(o._Min=o.asm.Min).apply(null,arguments)},o._Minimum=function(){return(o._Minimum=o.asm.Minimum).apply(null,arguments)},o._MirrorPad=function(){return(o._MirrorPad=o.asm.MirrorPad).apply(null,arguments)},o._Multiply=function(){return(o._Multiply=o.asm.Multiply).apply(null,arguments)},o._Neg=function(){return(o._Neg=o.asm.Neg).apply(null,arguments)},o._NonMaxSuppressionV3=function(){return(o._NonMaxSuppressionV3=o.asm.NonMaxSuppressionV3).apply(null,arguments)},o._NonMaxSuppressionV4=function(){return(o._NonMaxSuppressionV4=o.asm.NonMaxSuppressionV4).apply(null,arguments)},o._NonMaxSuppressionV5=function(){return(o._NonMaxSuppressionV5=o.asm.NonMaxSuppressionV5).apply(null,arguments)},o._NotEqual=function(){return(o._NotEqual=o.asm.NotEqual).apply(null,arguments)},o._OneHot=function(){return(o._OneHot=o.asm.OneHot).apply(null,arguments)},o._PadV2=function(){return(o._PadV2=o.asm.PadV2).apply(null,arguments)},o._Pow=function(){return(o._Pow=o.asm.Pow).apply(null,arguments)},o._Prelu=function(){return(o._Prelu=o.asm.Prelu).apply(null,arguments)},o._Prod=function(){return(o._Prod=o.asm.Prod).apply(null,arguments)},o._RealDiv=function(){return(o._RealDiv=o.asm.RealDiv).apply(null,arguments)},o._Relu=function(){return(o._Relu=o.asm.Relu).apply(null,arguments)},o._Relu6=function(){return(o._Relu6=o.asm.Relu6).apply(null,arguments)},o._ResizeBilinear=function(){return(o._ResizeBilinear=o.asm.ResizeBilinear).apply(null,arguments)},o._ResizeNearestNeighbor=function(){return(o._ResizeNearestNeighbor=o.asm.ResizeNearestNeighbor).apply(null,arguments)},o._Reverse=function(){return(o._Reverse=o.asm.Reverse).apply(null,arguments)},o._RotateWithOffset=function(){return(o._RotateWithOffset=o.asm.RotateWithOffset).apply(null,arguments)},o._Round=function(){return(o._Round=o.asm.Round).apply(null,arguments)},o._Rsqrt=function(){return(o._Rsqrt=o.asm.Rsqrt).apply(null,arguments)},o._ScatterNd=function(){return(o._ScatterNd=o.asm.ScatterNd).apply(null,arguments)},o._SelectV2=function(){return(o._SelectV2=o.asm.SelectV2).apply(null,arguments)},o._Sigmoid=function(){return(o._Sigmoid=o.asm.Sigmoid).apply(null,arguments)},o._Sin=function(){return(o._Sin=o.asm.Sin).apply(null,arguments)},o._Softmax=function(){return(o._Softmax=o.asm.Softmax).apply(null,arguments)},o._SparseFillEmptyRows=function(){return(o._SparseFillEmptyRows=o.asm.SparseFillEmptyRows).apply(null,arguments)},o._SparseReshape=function(){return(o._SparseReshape=o.asm.SparseReshape).apply(null,arguments)},o._SparseSegmentReduction=function(){return(o._SparseSegmentReduction=o.asm.SparseSegmentReduction).apply(null,arguments)},o._Sqrt=function(){return(o._Sqrt=o.asm.Sqrt).apply(null,arguments)},o._Square=function(){return(o._Square=o.asm.Square).apply(null,arguments)},o._SquaredDifference=function(){return(o._SquaredDifference=o.asm.SquaredDifference).apply(null,arguments)},o._Step=function(){return(o._Step=o.asm.Step).apply(null,arguments)},o._StridedSlice=function(){return(o._StridedSlice=o.asm.StridedSlice).apply(null,arguments)},o._Sub=function(){return(o._Sub=o.asm.Sub).apply(null,arguments)},o._Sum=function(){return(o._Sum=o.asm.Sum).apply(null,arguments)},o._Tan=function(){return(o._Tan=o.asm.Tan).apply(null,arguments)},o._Tanh=function(){return(o._Tanh=o.asm.Tanh).apply(null,arguments)},o._Tile=function(){return(o._Tile=o.asm.Tile).apply(null,arguments)},o._TopK=function(){return(o._TopK=o.asm.TopK).apply(null,arguments)},o._Transform=function(){return(o._Transform=o.asm.Transform).apply(null,arguments)},o._Transpose=function(){return(o._Transpose=o.asm.Transpose).apply(null,arguments)},o.__FusedMatMul=function(){return(o.__FusedMatMul=o.asm._FusedMatMul).apply(null,arguments)},o._malloc=function(){return(o._malloc=o.asm.malloc).apply(null,arguments)},o._free=function(){return(o._free=o.asm.free).apply(null,arguments)},o.___errno_location=function(){return(o.___errno_location=o.asm.__errno_location).apply(null,arguments)},o.stackSave=function(){return(J=o.stackSave=o.asm.stackSave).apply(null,arguments)}),ee=o.stackRestore=function(){return(ee=o.stackRestore=o.asm.stackRestore).apply(null,arguments)},te=o.stackAlloc=function(){return(te=o.stackAlloc=o.asm.stackAlloc).apply(null,arguments)};function ne(e){function n(){K||(K=!0,o.calledRun=!0,S||(G(F),t(o),o.onRuntimeInitialized&&o.onRuntimeInitialized(),function(){if(o.postRun)for("function"==typeof o.postRun&&(o.postRun=[o.postRun]);o.postRun.length;)e=o.postRun.shift(),O.unshift(e);var e;G(O)}()))}e=e||h,D>0||(function(){if(o.preRun)for("function"==typeof o.preRun&&(o.preRun=[o.preRun]);o.preRun.length;)e=o.preRun.shift(),A.unshift(e);var e;G(A)}(),D>0||(o.setStatus?(o.setStatus("Running..."),setTimeout((function(){setTimeout((function(){o.setStatus("")}),1),n()}),1)):n()))}if(o.dynCall_iijjiiii=function(){return(o.dynCall_iijjiiii=o.asm.dynCall_iijjiiii).apply(null,arguments)},o.dynCall_jiji=function(){return(o.dynCall_jiji=o.asm.dynCall_jiji).apply(null,arguments)},o.cwrap=function(e,t,n,r){var a=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&a&&!r?X(e):function(){return q(e,t,n,arguments)}},L=function e(){K||ne(),K||(L=e)},o.preInit)for("function"==typeof o.preInit&&(o.preInit=[o.preInit]);o.preInit.length>0;)o.preInit.pop()();if(ne(),s&&(Y={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!s.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!s.unhandledRejection.indexOf(e)>-1}))}),void 0!==e)Q=e;else{if("undefined"==typeof WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");Q=WasmBackendModuleThreadedSimd}if(Y){var re=Q._dispose;Q._dispose=function(){re(),Y.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Y.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return e.ready});e.exports=a},720:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var a={},s={};function o(e,t){var n,r,o;return t?(o=0<=(e>>>=0)&&e<256)&&(r=s[e])?r:(n=u(e,(0|e)<0?-1:0,!0),o&&(s[e]=n),n):(o=-128<=(e|=0)&&e<128)&&(r=a[e])?r:(n=u(e,e<0?-1:0,!1),o&&(a[e]=n),n)}function i(e,t){if(isNaN(e))return t?x:g;if(t){if(e<0)return x;if(e>=h)return I}else{if(e<=-f)return k;if(e+1>=f)return v}return e<0?i(-e,t).neg():u(e%p|0,e/p|0,t)}function u(e,t,r){return new n(e,t,r)}n.fromInt=o,n.fromNumber=i,n.fromBits=u;var l=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var a=i(l(n,8)),s=g,o=0;o<e.length;o+=8){var u=Math.min(8,e.length-o),d=parseInt(e.substring(o,o+u),n);if(u<8){var p=i(l(n,u));s=s.mul(p).add(i(d))}else s=(s=s.mul(a)).add(i(d))}return s.unsigned=t,s}function d(e,t){return"number"==typeof e?i(e,t):"string"==typeof e?c(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=d;var p=4294967296,h=p*p,f=h/2,m=o(1<<24),g=o(0);n.ZERO=g;var x=o(0,!0);n.UZERO=x;var b=o(1);n.ONE=b;var y=o(1,!0);n.UONE=y;var w=o(-1);n.NEG_ONE=w;var v=u(-1,2147483647,!1);n.MAX_VALUE=v;var I=u(-1,-1,!0);n.MAX_UNSIGNED_VALUE=I;var k=u(0,-2147483648,!1);n.MIN_VALUE=k;var C=n.prototype;C.toInt=function(){return this.unsigned?this.low>>>0:this.low},C.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},C.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(k)){var t=i(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=i(l(e,6),this.unsigned),s=this,o="";;){var u=s.div(a),c=(s.sub(u.mul(a)).toInt()>>>0).toString(e);if((s=u).isZero())return c+o;for(;c.length<6;)c="0"+c;o=""+c+o}},C.getHighBits=function(){return this.high},C.getHighBitsUnsigned=function(){return this.high>>>0},C.getLowBits=function(){return this.low},C.getLowBitsUnsigned=function(){return this.low>>>0},C.getNumBitsAbs=function(){if(this.isNegative())return this.eq(k)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},C.isZero=function(){return 0===this.high&&0===this.low},C.eqz=C.isZero,C.isNegative=function(){return!this.unsigned&&this.high<0},C.isPositive=function(){return this.unsigned||this.high>=0},C.isOdd=function(){return 1==(1&this.low)},C.isEven=function(){return 0==(1&this.low)},C.equals=function(e){return r(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},C.eq=C.equals,C.notEquals=function(e){return!this.eq(e)},C.neq=C.notEquals,C.ne=C.notEquals,C.lessThan=function(e){return this.comp(e)<0},C.lt=C.lessThan,C.lessThanOrEqual=function(e){return this.comp(e)<=0},C.lte=C.lessThanOrEqual,C.le=C.lessThanOrEqual,C.greaterThan=function(e){return this.comp(e)>0},C.gt=C.greaterThan,C.greaterThanOrEqual=function(e){return this.comp(e)>=0},C.gte=C.greaterThanOrEqual,C.ge=C.greaterThanOrEqual,C.compare=function(e){if(r(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},C.comp=C.compare,C.negate=function(){return!this.unsigned&&this.eq(k)?k:this.not().add(b)},C.neg=C.negate,C.add=function(e){r(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,a=this.low>>>16,s=65535&this.low,o=e.high>>>16,i=65535&e.high,l=e.low>>>16,c=0,p=0,h=0,f=0;return h+=(f+=s+(65535&e.low))>>>16,p+=(h+=a+l)>>>16,c+=(p+=n+i)>>>16,c+=t+o,u((h&=65535)<<16|(f&=65535),(c&=65535)<<16|(p&=65535),this.unsigned)},C.subtract=function(e){return r(e)||(e=d(e)),this.add(e.neg())},C.sub=C.subtract,C.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=d(e)),t)return u(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(k))return e.isOdd()?k:g;if(e.eq(k))return this.isOdd()?k:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return i(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,a=65535&this.high,s=this.low>>>16,o=65535&this.low,l=e.high>>>16,c=65535&e.high,p=e.low>>>16,h=65535&e.low,f=0,x=0,b=0,y=0;return b+=(y+=o*h)>>>16,x+=(b+=s*h)>>>16,b&=65535,x+=(b+=o*p)>>>16,f+=(x+=a*h)>>>16,x&=65535,f+=(x+=s*p)>>>16,x&=65535,f+=(x+=o*c)>>>16,f+=n*h+a*p+s*c+o*l,u((b&=65535)<<16|(y&=65535),(f&=65535)<<16|(x&=65535),this.unsigned)},C.mul=C.multiply,C.divide=function(e){if(r(e)||(e=d(e)),e.isZero())throw Error("division by zero");var n,a,s;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?x:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return x;if(e.gt(this.shru(1)))return y;s=x}else{if(this.eq(k))return e.eq(b)||e.eq(w)?k:e.eq(k)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:w:(a=this.sub(e.mul(n)),s=n.add(a.div(e)));if(e.eq(k))return this.unsigned?x:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=g}for(a=this;a.gte(e);){n=Math.max(1,Math.floor(a.toNumber()/e.toNumber()));for(var o=Math.ceil(Math.log(n)/Math.LN2),c=o<=48?1:l(2,o-48),p=i(n),h=p.mul(e);h.isNegative()||h.gt(a);)h=(p=i(n-=c,this.unsigned)).mul(e);p.isZero()&&(p=b),s=s.add(p),a=a.sub(h)}return s},C.div=C.divide,C.modulo=function(e){return r(e)||(e=d(e)),t?u((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},C.mod=C.modulo,C.rem=C.modulo,C.not=function(){return u(~this.low,~this.high,this.unsigned)},C.and=function(e){return r(e)||(e=d(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},C.or=function(e){return r(e)||(e=d(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},C.xor=function(e){return r(e)||(e=d(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},C.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},C.shl=C.shiftLeft,C.shiftRight=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},C.shr=C.shiftRight,C.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},C.shru=C.shiftRightUnsigned,C.shr_u=C.shiftRightUnsigned,C.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},C.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},C.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},C.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},C.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},256:()=>{},578:()=>{},980:()=>{},862:()=>{},958:()=>{},410:()=>{},628:()=>{}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var s=t[r]={exports:{}};return e[r](s,s.exports,n),s.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{"use strict";var e={};n.r(e),n.d(e,{assertParamsValid:()=>ua,computeFlatOffset:()=>va,computeOutShape:()=>ca,getNormalizedAxes:()=>fa,isSliceContinous:()=>wa,maskToAxes:()=>la,parseSliceParams:()=>Ia,sliceInfo:()=>ka,startForAxis:()=>ba,startIndicesWithElidedDims:()=>ma,stopForAxis:()=>ya,stopIndicesWithElidedDims:()=>ga,stridesForAxis:()=>xa,stridesWithElidedDims:()=>da});var t={};n.r(t),n.d(t,{collectGatherOpShapeInfo:()=>_i,computeOutShape:()=>Si,segOpComputeOptimalWindowSize:()=>$i});var r={};n.r(r),n.d(r,{ERF_A1:()=>Ho,ERF_A2:()=>jo,ERF_A3:()=>Xo,ERF_A4:()=>qo,ERF_A5:()=>Ko,ERF_P:()=>zo,PARALLELIZE_THRESHOLD:()=>Oo,RowPartitionType:()=>To,SELU_SCALE:()=>Go,SELU_SCALEALPHA:()=>Vo,applyActivation:()=>_o,assertAndGetBroadcastShape:()=>ra,assertAxesAreInnerMostDims:()=>Is,assertParamsConsistent:()=>no,assignToTypedArray:()=>ti,axesAreInnerMostDims:()=>bs,calculateShapes:()=>ia,checkEinsumDimSizes:()=>ui,checkPadOnDimRoundingMode:()=>bo,combineLocations:()=>ys,combineRaggedTensorToTensorShapes:()=>Ro,complexWithEvenIndex:()=>Zo,complexWithOddIndex:()=>Jo,computeConv2DInfo:()=>io,computeConv3DInfo:()=>uo,computeDefaultPad:()=>lo,computeDilation2DInfo:()=>ao,computeOptimalWindowSize:()=>Do,computeOutAndReduceShapes:()=>ws,computeOutShape:()=>ro,computePool2DInfo:()=>so,computePool3DInfo:()=>oo,convertConv2DDataFormat:()=>xo,decodeEinsumEquation:()=>oi,eitherStridesOrDilationsAreOne:()=>go,expandShapeToKeepDim:()=>vs,exponent:()=>ri,exponents:()=>ni,fromStringArrayToUint8:()=>Ti,fromUint8ToStringArray:()=>Ei,getAxesPermutation:()=>ks,getBroadcastDims:()=>ta,getComplexWithIndex:()=>ei,getEinsumComputePath:()=>li,getEinsumPermutation:()=>ii,getFusedBiasGradient:()=>So,getFusedDyActivation:()=>$o,getImageCenter:()=>Mo,getInnerMostAxes:()=>$s,getPermuted:()=>Po,getRaggedRank:()=>Ao,getReductionAxes:()=>na,getReshaped:()=>Lo,getReshapedPermuted:()=>Bo,getRowPartitionTypesHelper:()=>No,getSliceBeginCoords:()=>Wo,getSliceSize:()=>Uo,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>hi,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>fi,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>mi,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>bi,getSparseReshapeInputOutputMismatchErrorMessage:()=>wi,getSparseReshapeInputOutputMultipleErrorMessage:()=>yi,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>gi,getSparseReshapeNegativeOutputDimErrorMessage:()=>xi,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Ci,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>vi,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Ii,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>ki,getUndoAxesPermutation:()=>Cs,isIdentityPermutation:()=>ci,log:()=>tn,mergeRealAndImagArrays:()=>Yo,prepareAndValidate:()=>aa,prepareSplitSize:()=>pi,segment_util:()=>t,shouldFuse:()=>Eo,slice_util:()=>e,splitRealAndImagArrays:()=>Qo,tupleValuesAreOne:()=>mo,upcastType:()=>Kn,validateDefaultValueShape:()=>Fo,validateInput:()=>oa,validateUpdateShape:()=>sa,warn:()=>en});var a={};n.r(a),n.d(a,{addImpl:()=>tl,bincountImpl:()=>rl,bincountReduceImpl:()=>al,castImpl:()=>Qu,ceilImpl:()=>ul,concatImpl:()=>ll,equalImpl:()=>cl,expImpl:()=>dl,expm1Impl:()=>pl,floorImpl:()=>hl,gatherNdImpl:()=>fl,gatherV2Impl:()=>ml,greaterEqualImpl:()=>xl,greaterImpl:()=>gl,lessEqualImpl:()=>yl,lessImpl:()=>bl,linSpaceImpl:()=>wl,logImpl:()=>vl,maxImpl:()=>Il,maximumImpl:()=>kl,minimumImpl:()=>Cl,multiplyImpl:()=>$l,negImpl:()=>_l,notEqualImpl:()=>El,prodImpl:()=>Rl,raggedGatherImpl:()=>Al,raggedTensorToTensorImpl:()=>Ll,rangeImpl:()=>Pl,rsqrtImpl:()=>Bl,scatterImpl:()=>Wl,sigmoidImpl:()=>Ul,simpleAbsImpl:()=>ju,sliceImpl:()=>Vl,sparseFillEmptyRowsImpl:()=>Gl,sparseReshapeImpl:()=>zl,sparseSegmentReductionImpl:()=>Hl,sqrtImpl:()=>jl,squaredDifferenceImpl:()=>Xl,stridedSliceImpl:()=>ql,stringNGramsImpl:()=>Yl,stringSplitImpl:()=>Zl,stringToHashBucketFastImpl:()=>Jl,subImpl:()=>ec,tileImpl:()=>nc,topKImpl:()=>sc,transposeImpl:()=>Tl,uniqueImpl:()=>oc});class s{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class o{refCount(e){return i("refCount")}incRef(e){return i("incRef")}timerAvailable(){return!0}time(e){return i("time")}read(e){return i("read")}readSync(e){return i("readSync")}readToGPU(e,t){return i("readToGPU")}numDataIds(){return i("numDataIds")}disposeData(e,t){return i("disposeData")}write(e,t,n){return i("write")}move(e,t,n,r,a){return i("move")}memory(){return i("memory")}floatPrecision(){return i("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return i("dispose")}}function i(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function u(e,t,n){return Math.max(e,Math.min(t,n))}function l(e){return e%2==0?e:e+1}function c(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function d(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function p(e,t,n=""){d(g(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function h(e){d(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function f(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||_(e)&&!n)for(let r=0;r<e.length;++r)f(e[r],t,n);else t.push(e);return t}function m(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function g(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function x(e){return e%1==0}function b(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function y(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function w(e,t=(e=>0),n,r=setTimeout){return new Promise(((a,s)=>{let o=0;const i=()=>{if(e())return void a();o++;const u=t(o);null!=n&&o>=n?s():r(i,u)};i()}))}function v(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const a=e.slice();return a[r]=t/n,a}function I(e,t){const n=t.length;return d((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),d(e.every((e=>x(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function k(e,t){const n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||a?null:I(t,e).sort();let o=0;for(let t=0;t<e.length;++t){if(null!=s){if(s[o]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==s[o]||s[o]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),s[o]<=t&&o++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function C(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function $(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function S(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function _(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function E(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function T(e){return"string"==typeof e||e instanceof String}function R(e){return Array.isArray(e)?R(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":"number"==typeof e?"float32":T(e)?"string":"boolean"==typeof e?"bool":"float32"}function N(e){return!!(e&&e.constructor&&e.call&&e.apply)}function A(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function F(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function O(e,t,n,r=!1){const a=new Array;if(1===t.length){const s=t[0]*(r?2:1);for(let t=0;t<s;t++)a[t]=n[e+t]}else{const s=t[0],o=t.slice(1),i=o.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<s;t++)a[t]=O(e+t*i,o,n,r)}return a}function D(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return O(0,e,t,n)}function M(e,t){const n=L(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function L(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function P(e){e.forEach((t=>{d(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function B(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function W(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function U(e){return e&&e.then&&"function"==typeof e.then}const V="tfjsflags";class G{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=z,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(H().getBool("IS_TEST")||H().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];H().getBool("IS_TEST")||H().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(U(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);V in e&&e[V].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}(t,n)}))}}function z(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("=")))),t}function H(){return X}let j,X=null;function q(){if(null==j){let e;if("undefined"!=typeof window)e=window;else if(void 0!==n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}j=e}return j}function K(e,t){const n=function(){const e=q();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const Y="Abs",Q="Add",Z="AddN",J="All",ee="Any",te="ArgMax",ne="AvgPool",re="BatchMatMul",ae="BatchToSpaceND",se="Bincount",oe="Cast",ie="Ceil",ue="ClipByValue",le="Complex",ce="ComplexAbs",de="Concat",pe="Conv2D",he="Conv2DBackpropInput",fe="Cosh",me="Cumprod",ge="Cumsum",xe="CropAndResize",be="DepthToSpace",ye="DepthwiseConv2dNative",we="RealDiv",ve="Elu",Ie="Equal",ke="Exp",Ce="ExpandDims",$e="Expm1",Se="Fill",_e="FlipLeftRight",Ee="Floor",Te="FloorDiv",Re="FusedBatchNorm",Ne="GatherV2",Ae="GatherNd",Fe="Greater",Oe="GreaterEqual",De="Identity",Me="IFFT",Le="Imag",Pe="LeakyRelu",Be="Less",We="LessEqual",Ue="Log",Ve="Log1p",Ge="LogicalAnd",ze="LogicalNot",He="LogicalOr",je="Max",Xe="Maximum",qe="MaxPool",Ke="Mean",Ye="Min",Qe="Minimum",Ze="MirrorPad",Je="Multiply",et="Neg",tt="NotEqual",nt="NonMaxSuppressionV3",rt="NonMaxSuppressionV4",at="NonMaxSuppressionV5",st="OnesLike",ot="OneHot",it="Pack",ut="PadV2",lt="Pow",ct="Prelu",dt="Prod",pt="Range",ht="Real",ft="Relu",mt="Reshape",gt="ResizeNearestNeighbor",xt="ResizeBilinear",bt="Relu6",yt="Reverse",wt="Round",vt="Rsqrt",It="ScatterNd",kt="Select",Ct="Slice",$t="Sigmoid",St="Sqrt",_t="Sum",Et="SpaceToBatchND",Tt="SplitV",Rt="Softmax",Nt="SparseFillEmptyRows",At="SparseReshape",Ft="SparseSegmentMean",Ot="SparseSegmentSum",Dt="SquaredDifference",Mt="Square",Lt="StridedSlice",Pt="StringNGrams",Bt="StringSplit",Wt="StringToHashBucketFast",Ut="Sub",Vt="Tanh",Gt="Tile",zt="TopK",Ht="Transform",jt="Transpose",Xt="Unpack",qt="ZerosLike",Kt="Step",Yt="RotateWithOffset",Qt="_FusedMatMul",Zt="FusedConv2D",Jt="FusedDepthwiseConv2D";function en(...e){H().getBool("IS_TEST")||H().getBool("PROD")||console.warn(...e)}function tn(...e){H().getBool("IS_TEST")||H().getBool("PROD")||console.log(...e)}const nn=K("kernelRegistry",(()=>new Map)),rn=K("gradRegistry",(()=>new Map));function an(e,t){const n=ln(e,t);return nn.get(n)}function sn(e){return rn.get(e)}function on(e){const t=nn.entries(),n=[];for(;;){const{done:r,value:a}=t.next();if(r)break;const[s,o]=a,[i]=s.split("_");i===e&&n.push(o)}return n}function un(e){const{kernelName:t,backendName:n}=e,r=ln(t,n);nn.has(r)&&en(`The kernel '${t}' for backend '${n}' is already registered`),nn.set(r,e)}function ln(e,t){return`${t}_${e}`}var cn=n(720);const dn=n.n(cn)()||cn;function pn(e){return dn.fromString(e,!0,16)}const hn=pn("c3a5c85c97cb3127"),fn=pn("b492b66fbe98f273"),mn=pn("9ae16a3b2f90404f");function gn(e){return e.xor(e.shru(47))}function xn(e,t,n){const r=e.slice(t,t+n);return dn.fromBytes(Array.from(r),!0,!0)}function bn(e,t){return xn(e,t,8)}function yn(e,t){return xn(e,t,4)}function wn(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function vn(e,t,n=pn("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function In(e,t,n,r){return function(e,t,n,r,a,s){a=a.add(e),s=wn(s.add(a).add(r),21);const o=a;return a=(a=a.add(t)).add(n),s=s.add(wn(a,44)),[a.add(r),s.add(o)]}(bn(e,t),bn(e,t+8),bn(e,t+16),bn(e,t+24),n,r)}function kn(e,t=e.length){const n=dn.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){const n=mn.add(2*t),r=bn(e,0).add(mn),a=bn(e,t-8);return vn(wn(a,37).mul(n).add(r),wn(r,25).add(a).mul(n),n)}if(t>=4){const n=mn.add(2*t);return vn(yn(e,0).shl(3).add(t),yn(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return gn(mn.mul(n).xor(hn.mul(r))).mul(mn)}return mn}(e,t):function(e,t=e.length){const n=mn.add(2*t),r=bn(e,0).mul(fn),a=bn(e,8),s=bn(e,t-8).mul(n),o=bn(e,t-16).mul(mn);return vn(wn(r.add(a),43).add(wn(s,30)).add(o),r.add(wn(a.add(mn),18)).add(s),n)}(e,t);if(t<=64)return function(e,t=e.length){const n=mn.add(2*t),r=bn(e,0).mul(mn),a=bn(e,8),s=bn(e,t-8).mul(n),o=bn(e,t-16).mul(mn),i=wn(r.add(a),43).add(wn(s,30)).add(o),u=vn(i,r.add(wn(a.add(mn),18)).add(s),n),l=bn(e,16).mul(n),c=bn(e,24),d=i.add(bn(e,t-32)).mul(n),p=u.add(bn(e,t-24)).mul(n);return vn(wn(l.add(c),43).add(wn(d,30)).add(p),l.add(wn(c.add(r),18)).add(d),n)}(e,t);let r=n,a=n.mul(fn).add(113),s=gn(a.mul(mn).add(113)).mul(mn),o=[dn.UZERO,dn.UZERO],i=[dn.UZERO,dn.UZERO];r=r.mul(mn).add(bn(e,0));let u=0;const l=64*(t-1>>6),c=l+(t-1&63)-63;do{r=wn(r.add(a).add(o[0]).add(bn(e,u+8)),37).mul(fn),a=wn(a.add(o[1]).add(bn(e,u+48)),42).mul(fn),r=r.xor(i[1]),a=a.add(o[0]).add(bn(e,u+40)),s=wn(s.add(i[0]),33).mul(fn),o=In(e,u,o[1].mul(fn),r.add(i[0])),i=In(e,u+32,s.add(i[1]),a.add(bn(e,u+16))),[s,r]=[r,s],u+=64}while(u!==l);const d=fn.add(s.and(255).shl(1));return u=c,i[0]=i[0].add(t-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),r=wn(r.add(a).add(o[0]).add(bn(e,u+8)),37).mul(d),a=wn(a.add(o[1]).add(bn(e,u+48)),42).mul(d),r=r.xor(i[1].mul(9)),a=a.add(o[0].mul(9).add(bn(e,u+40))),s=wn(s.add(i[0]),33).mul(d),o=In(e,u,o[1].mul(d),r.add(i[0])),i=In(e,u+32,s.add(i[1]),a.add(bn(e,u+16))),[s,r]=[r,s],vn(vn(o[0],i[0],d).add(gn(a).mul(hn)).add(s),vn(o[1],i[1],d).add(r),d)}function Cn(e,t){return"string"===t?_n(e):$n([e],t)}function $n(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=f(e)),H().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function Sn(){return H().platform.now()}function _n(e,t="utf-8"){return t=t||"utf-8",H().platform.encode(e,t)}function En(e,t="utf-8"){return t=t||"utf-8",H().platform.decode(e,t)}class Tn{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Nn)}profileKernel(e,t,n){let r;const a=()=>{r=n()};let s;const o=Sn();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(const e of r)e.dataSync();s=Promise.resolve({kernelMs:Sn()-o})}if(H().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<r.length;t++){const n=r[t];n.data().then((t=>{Rn(t,n.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:s.then((e=>e.kernelMs)),extraInfo:s.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),r,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}}function Rn(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class Nn{logKernelProfile(e,t,n,r,a,s){const o="number"==typeof r?y(`${r}ms`,9):r.error,i=y(e,25),u=t.rank,l=t.size,c=y(t.shape.toString(),14);let d="";for(const e in a){const n=a[e];if(null!=n){const r=n.shape||t.shape,a=r.length;d+=`${e}: ${a}D ${a>0?r:""} `}}console.log(`%c${i}\t%c${o}\t%c${u}D ${c}\t%c${l}\t%c${d}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function An(e,t,n,r){const a=F(t),s=function(e,t,n,r){const a=m(t),s=r[r.length-1],o=new Array(s).fill(0),i=t.length,u="complex64"===n?Mn(e):e;if(i>1)for(let e=0;e<a/s;e++){const t=e*s;for(let e=0;e<s;e++)o[e]=Math.max(o[e],Fn(u[t+e],0,n).length)}return o}(e,t,n,a),o=t.length,i=Dn(e,t,n,a,s),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${o}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(i.map((e=>"    "+e)).join("\n")),u.join("\n")}function Fn(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:T(e)?`'${e}'`:"bool"===n?On(e):parseFloat(e.toFixed(7)).toString(),y(r,t)}function On(e){return 0===e?"false":"true"}function Dn(e,t,n,r,a,s=!0){const o="complex64"===n?2:1,i=t[0],u=t.length;if(0===u)return"complex64"===n?[Fn(Mn(e)[0],0,n)]:"bool"===n?[On(e[0])]:[e[0].toString()];if(1===u){if(i>20){const t=3*o;let r=Array.from(e.slice(0,t)),s=Array.from(e.slice((i-3)*o,i*o));return"complex64"===n&&(r=Mn(r),s=Mn(s)),["["+r.map(((e,t)=>Fn(e,a[t],n))).join(", ")+", ..., "+s.map(((e,t)=>Fn(e,a[i-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?Mn(e):Array.from(e)).map(((e,t)=>Fn(e,a[t],n))).join(", ")+"]"]}const l=t.slice(1),c=r.slice(1),d=r[0]*o,p=[];if(i>20){for(let t=0;t<3;t++){const r=t*d,s=r+d;p.push(...Dn(e.slice(r,s),l,n,c,a,!1))}p.push("...");for(let t=i-3;t<i;t++){const r=t*d,s=r+d;p.push(...Dn(e.slice(r,s),l,n,c,a,t===i-1))}}else for(let t=0;t<i;t++){const r=t*d,s=r+d;p.push(...Dn(e.slice(r,s),l,n,c,a,t===i-1))}const h=2===u?",":"";p[0]="["+p[0]+h;for(let e=1;e<p.length-1;e++)p[e]=" "+p[e]+h;let f=",\n";for(let e=2;e<u;e++)f+="\n";return p[p.length-1]=" "+p[p.length-1]+"]"+(s?"":f),p}function Mn(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class Ln{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=m(e),null!=n){const e=n.length;d(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||$(t,this.size),this.strides=F(e)}set(e,...t){0===t.length&&(t=[0]),d(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Pn().makeTensor(this.values,this.shape,this.dtype)}}let Pn=null,Bn=null,Wn=null;class Un{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=m(e),this.strides=F(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Bn.buffer(this.shape,this.dtype,e)}bufferSync(){return Bn.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return D(this.shape,e,"complex64"===this.dtype)}arraySync(){return D(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=Pn().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>En(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Pn().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Pn().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>En(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Pn().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Pn().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Bn.print(this,e)}clone(){return this.throwIfDisposed(),Bn.clone(this)}toString(e=!1){return An(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Bn.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Pn().makeVariable(this,e,t,n)}}Object.defineProperty(Un,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),K("Tensor",(()=>Un));class Vn extends Un{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!g(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Pn().disposeTensor(this),this.dataId=e.dataId,Pn().incRef(this,null)}dispose(){Pn().disposeVariable(this),this.isDisposedInternal=!0}}var Gn,zn,Hn,jn,Xn;Object.defineProperty(Vn,Symbol.hasInstance,{value:e=>e instanceof Un&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(Gn||(Gn={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(zn||(zn={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(Hn||(Hn={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(jn||(jn={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Xn||(Xn={}));const qn={float32:jn,int32:zn,bool:Hn,complex64:Xn};function Kn(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return qn[e][t]}function Yn(e){return Kn(e,"int32")}function Qn(e,t){if(e.dtype===t.dtype)return[e,t];const n=Kn(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Zn(e){const t=[];return Jn(e,t,new Set),t}function Jn(e,t,n){if(null==e)return;if(e instanceof Un)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!=typeof r)return;var r;const a=e;for(const e in a){const r=a[e];n.has(r)||(n.add(r),Jn(r,t,n))}}function er(e){return null!=e.kernelName}class tr{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class nr{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new tr}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(en(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Tn(this.backendInstance),!0}setupRegisteredKernels(){on(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){on(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof o||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0)))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,en(`Initialization of backend ${e} failed`),en(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(t){return en(`Initialization of backend ${e} failed`),en(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return nr.nextTensorId++}nextVariableId(){return nr.nextVariableId++}clone(e){const t=ar.runKernel(De,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e};return ar.runKernel(oe,t,{dtype:"float32"})}})),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==an(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-t-a-s;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),a=this.state.numBytes,s=this.state.numTensors;let o,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const u=er(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(er(e)){const{kernelName:t,inputs:a,attrs:s}=e;null==this.backendName&&this.backend;const u=an(t,this.backendName);d(null!=u,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),o=()=>{const e=this.backend.numDataIds();i=u.kernelFunc({inputs:a,attrs:s,backend:this.backend});const o=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,o);const l=o.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,a,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,a=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};o=()=>{const e=this.backend.numDataIds();i=this.tidy((()=>t(this.backend,a)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,n),n}}const{inputs:l,attrs:c}=e,p=er(e)?null:e.backwardsFunc;let h;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(h=this.profiler.profileKernel(u,l,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs):t=o()})),r&&this.addTapeNode(u,l,t,p,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((e=>null!=l[e]?l[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const r=sn(e);if(null!=r){const e=r.inputsToSave||[],a=r.outputsToSave||[];let s;r.saveAllInputs?(d(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(t).map((e=>t[e]))):s=e.map((e=>t[e]));const o=n.filter(((e,t)=>a[t]));return s.concat(o)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&T(e[0])&&(a=e.map((e=>_n(e))));const s=r.write(a,t,n),o=new Un(t,n,s,this.nextTensorId());if(this.trackTensor(o,r),"string"===n){const e=this.state.tensorInfo.get(s),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return o}makeTensorFromDataId(e,t,n,r){const a={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:a}=e,s=new Un(r,a,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const a=new Vn(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*E(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Vn||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*E(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,s){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},i=sn(e);null!=i&&(r=i.gradFunc),null!=r&&(o.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=L(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,s))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Zn(e),n=new Set(t.map((e=>e.id)));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n,r=!1){if(d(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));d(a instanceof Un,(()=>"The result y returned by f() must be a tensor."));const s=function(e,t,n){const r={},a={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){const s=e[n],o=s.inputs;for(const e in o){const n=o[e];let i=!1;for(let e=0;e<t.length;e++)if(r[n.id]){s.outputs.forEach((e=>r[e.id]=!0)),i=!0,a[s.id]=!0;break}if(i)break}}const s={};s[n.id]=!0;const o={};for(let t=e.length-1;t>=0;t--){const n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(s[n.outputs[e].id]){for(const e in r)s[r[e].id]=!0,o[n.id]=!0;break}}const i=[];for(let t=0;t<e.length;t++){const n=e[t];if(a[n.id]&&o[n.id]){const e={};for(const t in n.inputs){const a=n.inputs[t];r[a.id]&&(e[t]=a)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,i.push(t)}}return i}(this.state.activeTape,t,a);if(!r&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[a.id]=null==n?function(e){const t=M(m(e),"float32");return ar.makeTensor(t,e,"float32")}(a.shape):n,function(e,t,n,r){for(let a=t.length-1;a>=0;a--){const s=t[a],o=[];if(s.outputs.forEach((t=>{const n=e[t.id];null!=n?o.push(n):o.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const i=s.gradient(o);for(const t in s.inputs){if(!(t in i))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(i)}.`);const a=n((()=>i[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);const o=s.inputs[t];if(!g(a.shape,o.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${o.shape}'`);if(null==e[o.id])e[o.id]=a;else{const t=e[o.id];e[o.id]=r(t,a),t.dispose()}}}}(e,s,(e=>this.tidy(e)),sr);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){return d(N(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;d(t.every((e=>e instanceof Un)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};return t.forEach(((e,t)=>{r[t]=e})),this.runKernelFunc({forwardFunc:(r,a)=>(n=e(...t,a),d(n.value instanceof Un,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),d(N(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,r)=>{const a=n.gradFunc(e,r),s=Array.isArray(a)?a:[a];d(s.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),d(s.every((e=>e instanceof Un)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return s.forEach(((e,t)=>{o[t]=()=>e})),o},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Sn(),n=await this.backend.time(e);return n.wallMs=Sn()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new tr;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function rr(){const e=q();if(null==e._tfengine){const t=new G(e);e._tfengine=new nr(t)}var t;return t=e._tfengine.ENV,X=t,Pn=()=>e._tfengine,e._tfengine}nr.nextTensorId=0,nr.nextVariableId=0;const ar=rr();function sr(e,t){const n={a:e,b:t};return ar.runKernel(Q,n)}function or(e){if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function ir(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const ur=H();ur.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),ur.registerFlag("IS_BROWSER",(()=>ir())),ur.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),ur.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),ur.registerFlag("PROD",(()=>!1)),ur.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>ur.getBool("DEBUG"))),ur.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),ur.registerFlag("IS_TEST",(()=>!1)),ur.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),ur.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),ur.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1)),ur.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),ur.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const lr="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function cr(e){return lr?Buffer.byteLength(e):new Blob([e]).size}function dr(e){if(1===e.length)return e[0];let t=0;e.forEach((e=>{t+=e.byteLength}));const n=new Uint8Array(t);let r=0;return e.forEach((e=>{n.set(new Uint8Array(e),r),r+=e.byteLength})),n.buffer}function pr(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function hr(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:cr(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:cr(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}class fr{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==fr.instance&&(fr.instance=new fr),fr.instance}static registerSaveRouter(e){fr.getInstance().saveRouters.push(e)}static registerLoadRouter(e){fr.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return fr.getHandlers(e,"save")}static getLoadHandlers(e,t){return fr.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?fr.getInstance().loadRouters:fr.getInstance().saveRouters).forEach((t=>{const a=t(e,n);null!==a&&r.push(a)})),r}}const mr="tensorflowjs",gr="models_store",xr="model_info_store";function br(){if(!H().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function yr(e){const t=e.result;t.createObjectStore(gr,{keyPath:"modelPath"}),t.createObjectStore(xr,{keyPath:"modelPath"})}class wr{constructor(e){if(this.indexedDB=br(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(mr,1);r.onupgradeneeded=()=>yr(r),r.onsuccess=()=>{const a=r.result;if(null==t){const t=a.transaction(gr,"readonly"),r=t.objectStore(gr).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{const r=hr(t),s=a.transaction(xr,"readwrite");let o=s.objectStore(xr);const i=o.put({modelPath:this.modelPath,modelArtifactsInfo:r});let u;i.onsuccess=()=>{u=a.transaction(gr,"readwrite");const i=u.objectStore(gr).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r});i.onsuccess=()=>e({modelArtifactsInfo:r}),i.onerror=e=>{o=s.objectStore(xr);const t=o.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(i.error)),t.onerror=e=>(a.close(),n(i.error))}},i.onerror=e=>(a.close(),n(i.error)),s.oncomplete=()=>{null==u?a.close():u.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}}wr.URL_SCHEME="indexeddb://";const vr=e=>{return H().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(wr.URL_SCHEME)?(t=e.slice(wr.URL_SCHEME.length),new wr(t)):null;var t};fr.registerSaveRouter(vr),fr.registerLoadRouter(vr);class Ir{constructor(){this.indexedDB=br()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(mr,1);n.onupgradeneeded=()=>yr(n),n.onsuccess=()=>{const r=n.result,a=r.transaction(xr,"readonly"),s=a.objectStore(xr).getAll();s.onsuccess=()=>{const t={};for(const e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(wr.URL_SCHEME)?t.slice(wr.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(mr,1);r.onupgradeneeded=()=>yr(r),r.onsuccess=()=>{const a=r.result,s=a.transaction(xr,"readwrite"),o=s.objectStore(xr),i=o.get(e);let u;i.onsuccess=()=>{if(null==i.result)return a.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=o.delete(e),s=()=>{u=a.transaction(gr,"readwrite");const r=u.objectStore(gr).delete(e);r.onsuccess=()=>t(i.result.modelArtifactsInfo),r.onerror=e=>n(i.error)};r.onsuccess=s,r.onerror=e=>(s(),a.close(),n(i.error))}},i.onerror=e=>(a.close(),n(i.error)),s.oncomplete=()=>{null==u?a.close():u.oncomplete=()=>a.close()}},r.onerror=e=>n(r.error)}))}}const kr="/",Cr="tensorflowjs_models",$r="info",Sr="model_topology",_r="weight_specs",Er="weight_data",Tr="model_metadata";function Rr(e){return{info:[Cr,e,$r].join(kr),topology:[Cr,e,Sr].join(kr),weightSpecs:[Cr,e,_r].join(kr),weightData:[Cr,e,Er].join(kr),modelMetadata:[Cr,e,Tr].join(kr)}}function Nr(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Ar(e){const t=e.split(kr);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(kr)}class Fr{constructor(e){if(!H().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Rr(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=hr(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(lr)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let e=0,r=t.length;e<r;e++)n+=String.fromCharCode(t[e]);return btoa(n)}(e.weightData));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch(e){throw Nr(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){const e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(lr){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}(s),t}}Fr.URL_SCHEME="localstorage://";const Or=e=>{return H().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Fr.URL_SCHEME)?(t=e.slice(Fr.URL_SCHEME.length),new Fr(t)):null;var t};fr.registerSaveRouter(Or),fr.registerLoadRouter(Or);class Dr{constructor(){d(H().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),d("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=Cr+kr,n=kr+$r;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);a.startsWith(t)&&a.endsWith(n)&&(e[Ar(a)]=JSON.parse(this.LS.getItem(a)))}return e}async removeModel(e){var t;const n=Rr(e=(t=e).startsWith(Fr.URL_SCHEME)?t.slice(Fr.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return Nr(n),r}}class Mr{constructor(){this.managers={}}static getInstance(){return null==Mr.instance&&(Mr.instance=new Mr),Mr.instance}static registerManager(e,t){d(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),d(e.length>0,(()=>"scheme must not be an empty string."));const n=Mr.getInstance();d(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=Mr.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Mr.getInstance().managers)}}class Lr{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){window&&H().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))}),!0))):setTimeout(e,t)}}if(H().get("IS_BROWSER")){H().setPlatform("browser",new Lr);try{Mr.registerManager(Fr.URL_SCHEME,new Dr)}catch(e){}try{Mr.registerManager(wr.URL_SCHEME,new Ir)}catch(e){}}let Pr;function Br(e,t="float32",n){return t=t||"float32",P(e),new Ln(e,t,n)}function Wr(e,t){let n=e;if(_(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||_(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&H().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Ur(e,r,[]),r}function Ur(e,t,n){if(n=n||[],!Array.isArray(e)&&!_(e))return void d(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));d(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),d(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let t=0;t<e.length;++t)Ur(e[t],r,n.concat(t))}function Vr(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function Gr(e,t,n,r="numeric"){if(e instanceof Un)return Vr(r,e.dtype,t,n),e;let a=R(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),Vr(r,a,t,n),null==e||!_(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const s=Wr(e,a);_(e)||Array.isArray(e)||(e=[e]);const o="string"!==a?$n(e,a):f(e,[],!0);return ar.makeTensor(o,s,a)}function zr(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,a)=>Gr(e,`${t}[${a}]`,n,r)))}function Hr(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const a=(...e)=>{ar.startScope(n);try{const t=r(...e);return U(t)&&console.error("Cannot return a Promise inside of tidy."),ar.endScope(t),t}catch(e){throw ar.endScope(null),e}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}H().get("IS_NODE")&&!H().get("IS_BROWSER")&&H().setPlatform("node",new class{constructor(){this.util=n(628),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=H().global.fetch?H().global.fetch(e,t):(null==Pr&&(Pr=n(410)),Pr(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}});const jr=Hr({cast_:function(e,t){const n=Gr(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},a={dtype:t};return ar.runKernel(oe,r,a)}}),Xr=Hr({clone_:function(e){const t={x:Gr(e,"x","clone","string_or_numeric")};return ar.runKernel(De,t)}});function qr(e){return new Promise((e=>setTimeout(e))).then(e)}rr(),Bn={buffer:Br,cast:jr,clone:Xr,print:function(e,t=!1){console.log(e.toString(t))}};class Kr{constructor(e){if(!H().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Kr.URL_SCHEME)&&(e=e.slice(Kr.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=pr(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await qr((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await qr((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:hr(e)}}}}function Yr(e,t,n,r){!function(e){d(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){d(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),d(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),d(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let a=0;return Promise.all(e.map((s=>(s.then((s=>{const o=n+ ++a/e.length*(r-n);return t(o),s})),s))))}async function Qr(e,t){null==t&&(t={});const n=null==t.fetchFunc?H().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=(null==t.onProgress?await Promise.all(r):await Yr(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(a):await Yr(a,t.onProgress,.5,1)}Kr.URL_SCHEME="downloads://",fr.registerSaveRouter((e=>H().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Kr.URL_SCHEME)?function(e="model"){return new Kr(e)}(e.slice(Kr.URL_SCHEME.length)):null));class Zr{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(d("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=H().platform.fetch,d(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&d(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=pr(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:hr(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return async function(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),function(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),r}(e,n,r)}(t,(e=>this.loadWeights(e)))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(t),a=this.weightPathPrefix||n,s=function(e){const t=[];for(const n of e)t.push(...n.weights);return t}(e),o=[],i=[];for(const t of e)for(const e of t.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):o.push(a+e+r);return this.weightUrlConverter&&o.push(...await Promise.all(i)),[s,dr(await Qr(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function Jr(e){return null!=e.match(Zr.URL_SCHEME_REGEX)}Zr.URL_SCHEME_REGEX=/^https?:\/\//;const ea=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>Jr(e))):Jr(e),n)return function(e,t){return new Zr(e,t)}(e,t)}return null};function ta(e,t){const n=e.length,r=[];for(let a=0;a<n;a++){const s=n-1-a,o=e[s]||1;(t[t.length-1-a]||1)>1&&1===o&&r.unshift(s)}return r}function na(e,t){const n=[];for(let r=0;r<t.length;r++){const a=e[e.length-r-1],s=t.length-r-1,o=t[s];(null==a||1===a&&o>1)&&n.unshift(s)}return n}function ra(e,t){const n=[],r=Math.max(e.length,t.length);for(let a=0;a<r;a++){let r=e[e.length-a-1];null==r&&(r=1);let s=t[t.length-a-1];if(null==s&&(s=1),1===r)n.unshift(s);else if(1===s)n.unshift(r);else{if(r!==s)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);n.unshift(r)}}return n}function aa(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===m(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const a=t.shape,s=a[a.length-1];let o=1;for(let e=0;e<a.length-1;++e)o*=a[e];const i=e.shape,u=a.slice();u.pop();let l=1;for(let e=s;e<n;++e)l*=i[e],u.push(i[e]);const c=[...F(e.shape).map((e=>e/l)),1].slice(0,s);return[u,o,l,c]}function sa(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+" update.rank != "+(a+e.length-r));for(let e=0;e<a;++e)if(n.shape[e]!==t.shape[e])throw new Error(s+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-a;++t)if(n.shape[t+a]!==e[t+r])throw new Error(s+` updates.shape[${t+a}] (${n.shape[t+a]}) != shape[${t+a}] (${e[t+a]})`)}function oa(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}sa(n,t,e)}function ia(e,t,n){const r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length;let o=1;for(let e=a;e<s;++e)o*=n[e];const i=a<1?1:a;return{sliceRank:a,numUpdates:m(t.shape)/i,sliceSize:o,strides:[...F(n.slice(0,a)),1],outputSize:m(n)}}function ua(e,t,n){const r=e.shape.length;d(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),d(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let a=0;a<r;++a)d(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function la(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function ca(e,t,n){const r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function da(e,t,n,r){const a=[...e];for(let e=a.length;e<r.length;e++)a.push(1);for(let e=0;e<n;e++)0===e?a[t]=1:(a.splice(t,0,1),a.pop());return a}function pa(e,t,n){return n<=e?n:n-(t-1)}function ha(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function fa(e,t,n,r,a,s,o,i,u){const l=e.length;let c=new Array(l),d=new Array(l),p=new Array(l);if(t.length&&n>0){const u=t[0],l=n+1;c=ma(o,u,l,r,e),d=ga(i,u,l,a,e),p=da(s,u,l,e)}else for(let t=0;t<l;t++)c[t]=ba(o,r,s,e,t,u),d[t]=ya(i,a,s,e,t,u),p[t]=xa(s,t,u);return{begin:c,end:d,strides:p}}function ma(e,t,n,r,a){const s=[...a],o=ha(n,t);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=0;else{const o=pa(t,n,a);let i=r[o];e&1<<o&&(i=0),s[a]=i}return s}function ga(e,t,n,r,a){const s=[...a],o=ha(n,t);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{const o=pa(t,n,a);let i=r[o];e&1<<o&&(i=Number.MAX_SAFE_INTEGER),s[a]=i}for(let e=0;e<s.length;e++){const t=a[e];s[e]<0&&(s[e]+=t),s[e]=u(0,s[e],a[e])}return s}function xa(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function ba(e,t,n,r,a,s){let o=t[a];const i=n[a]||1;(e&1<<a||s&1<<a||null==o)&&(o=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[a];return o<0&&(o+=l),o=u(0,o,l-1),o}function ya(e,t,n,r,a,s){let o=t[a];const i=n[a]||1;(e&1<<a||s&1<<a||null==o)&&(o=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[a];return o<0&&(o+=l),o=i>0?u(0,o,l):u(-1,o,l-1),o}function wa(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function va(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function Ia(e,t,n){let r;const a=e.shape.length;let s;return r="number"==typeof t?[t,...new Array(a-1).fill(0)]:t.length<a?t.concat(new Array(a-t.length).fill(0)):t.slice(),r.forEach((e=>{d(-1!==e,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(a).fill(-1):"number"==typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,s=s.map(((t,n)=>t>=0?t:(d(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,s]}function ka(e,t,n,r,a,s,o,i,u){let l;if(null==r?(l=new Array(t.length),l.fill(1)):l=r,null!=o&&0!=(o&o-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:a,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};for(let e=0;e<d.dims;e++)c&&0!=(1<<e&i)&&d.numAddAxisAfterEllipsis++,1<<e&o&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const p={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(d,p);let h=!0,f=!0,m=!0;const g=[],x=[];for(let t=0;t<e.length;++t){if(0===p.strides[t])throw Error(`strides[${t}] must be non-zero`);const n=!!(p.shrinkAxisMask&1<<t),r=e[t];if(-1===r){g.push(n?1:-1);continue}const a=[p.beginMask&1<<t,p.endMask&1<<t],s=[p.strides[t]>0?0:-1,p.strides[t]>0?r:r-1];if(n&&p.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===p.strides[t];const o=!!(p.beginMask&1<<t&&p.endMask&1<<t);if(p.beginValid&&p.endValid){if(n){const e=p.begin[t]<0?r+p.begin[t]:p.begin[t];if(p.begin[t]=e,p.end[t]=p.begin[t]+1,e<0||e>=r)throw Error(`slice index ${p.begin[t]} of dimension ${t} out of bounds.`)}else p.begin[t]=Ca(p.begin[t],0,p.strides[t],r,a,s),p.end[t]=Ca(p.end[t],1,p.strides[t],r,a,s);const e=1===p.strides[t]&&0===p.begin[t]&&p.end[t]===r;h=h&&e,f=f&&(0===t&&1===p.strides[t]||e)}else h=h&&1===p.strides[t]&&o,f=f&&(0===t&&1===p.strides[t]||o);let i,u=!1;if(p.beginValid&&p.endValid?(i=p.end[t]-p.begin[t],u=!0):n?(i=1,u=!0):o&&r>=0&&(i=p.strides[t]<0?-r:r,u=!0),u){let e;e=0===i||i<0!=p.strides[t]<0?0:Math.trunc(i/p.strides[t])+(i%p.strides[t]!=0?1:0),g.push(e)}else g.push(-1)}for(let e=0;e<p.finalShapeGatherIndices.length;++e){const t=p.finalShapeGatherIndices[e];t>=0?x.push(g[t]):-2===t&&x.push(1)}return{finalShapeSparse:x.filter(((e,t)=>-2!==p.finalShapeGatherIndices[t])),finalShape:x,isIdentity:h,sliceDim0:f,isSimpleSlice:m,begin:p.begin,end:p.end,strides:p.strides}}function Ca(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{const t=e<0?r+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}fr.registerSaveRouter(ea),fr.registerLoadRouter(ea);const $a=Hr({reshape_:function(e,t){const n={x:Gr(e,"x","reshape","string_or_numeric")},r={shape:t};return ar.runKernel(mt,n,r)}}),Sa=Hr({broadcastTo_:function(e,t){let n=Gr(e,"broadcastTo","x");const r=n.shape;if(t.some((e=>!(e>0)||e%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=$a(n,e)}const a=n.shape,s=Array.from(t);for(let e=t.length-1;e>=0;e--)if(a[e]===t[e])s[e]=1;else if(1!==n.shape[e])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return Xr(n);const o={x:n},i={reps:s};return ar.runKernel(Gt,o,i)}});function _a(e,t,n,r){if(null==r&&(r=R(e)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!_(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){P(t);const e=m(t),r=m(n);d(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let e=0;e<n.length;++e){const r=n[e],a=e!==n.length-1||r!==m(t.slice(e));d(n[e]===t[e]||!a,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return _(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?$n(e,r):f(e,[],!0),ar.makeTensor(e,t,r)}function Ea(e,t){if((_(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&_(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return _a(e,[],[],t)}const Ta=Hr({complex_:function(e,t){const n=Gr(e,"real","complex"),r=Gr(t,"imag","complex");p(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const a={real:n,imag:r};return ar.runKernel(le,a)}});function Ra(e,t="float32"){if("complex64"===t){const t=Ra(e,"float32"),n=Ra(e,"float32");return Ta(t,n)}const n=L(m(e),t);return ar.makeTensor(n,e,t)}const Na=Hr({concat_:function(e,t=0){d(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=zr(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return Xr(n[0]);const r=n,a={axis:t};return ar.runKernel(de,r,a)}}),Aa=Hr({imag_:function(e){const t={input:Gr(e,"input","imag")};return ar.runKernel(Le,t)}}),Fa=Hr({real_:function(e){const t={input:Gr(e,"input","real")};return ar.runKernel(ht,t)}}),Oa=Hr({slice_:function(e,t,n){const r=Gr(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const a={x:r},s={begin:t,size:n};return ar.runKernel(Ct,a,s)}}),Da=Hr({split_:function(e,t,n=0){const r={x:Gr(e,"x","split")},a={numOrSizeSplits:t,axis:n};return ar.runKernel(Tt,r,a)}}),Ma=Hr({zerosLike_:function(e){const t={x:Gr(e,"x","zerosLike")};return ar.runKernel(qt,t)}}),La=Hr({fft_:function(e){d("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return ar.runKernel("FFT",t)}}),Pa=Hr({rfft_:function(e,t){d("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const r=e.size/n;let a;if(null!=t&&t<n){const r=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,a=Oa(e,r,s),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,a=Na([e,Ra(r)],e.shape.length-1),n=t}else a=e;const s=Ma(a),o=$a(Ta(a,s),[r,n]),i=La(o),u=Math.floor(n/2)+1,l=Fa(i),c=Aa(i),p=Da(l,[u,n-u],l.shape.length-1),h=Da(c,[u,n-u],c.shape.length-1),f=a.shape.slice();return f[a.shape.length-1]=u,$a(Ta(p[0],h[0]),f)}}),Ba=Hr({ifft_:function(e){d("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return ar.runKernel(Me,t)}}),Wa=Hr({mul_:function(e,t){let n=Gr(e,"a","mul"),r=Gr(t,"b","mul");[n,r]=Qn(n,r);const a={a:n,b:r};return ar.runKernel(Je,a)}}),Ua=Hr({reverse_:function(e,t){const n={x:Gr(e,"x","reverse")},r={dims:t};return ar.runKernel(yt,n,r)}});function Va(e,t){h(e);const n=Wr(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return _a(e,null,n,t)}function Ga(e,t,n){const r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){const o=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(o)}return Va(a,"float32")}Hr({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const a=$a(e,[n,t]);r=Ba(a)}else{const a=[n,2*(t-1)],s=$a(Fa(e),[n,t]),o=$a(Aa(e),[n,t]),i=Ua(Oa(s,[0,1],[n,t-2]),1),u=Wa(Ua(Oa(o,[0,1],[n,t-2]),1),Ea(-1)),l=Na([s,i],1),c=Na([o,u],1),d=$a(Ta(l,c),[a[0],a[1]]);r=Ba(d)}if(r=Fa(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=$a(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}}),Hr({hammingWindow_:function(e){return Ga(e,.54,.46)}});const za=Hr({hannWindow_:function(e){return Ga(e,.5,.5)}});function Ha(e,t,n){const r={shape:e,value:t,dtype:n};return ar.runKernel(Se,{},r)}function ja(e,t,n){if(h(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Wr(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return _a(e,t,r,n)}const Xa=Hr({frame_:function(e,t,n,r=!1,a=0){let s=0;const o=[];for(;s+t<=e.size;)o.push(Oa(e,s,t)),s+=n;if(r)for(;s<e.size;){const r=s+t-e.size,i=Na([Oa(e,s,t-r),Ha([r],a)]);o.push(i),s+=n}return 0===o.length?ja([],[0,t]):$a(Na(o),[o.length,t])}});Hr({stft_:function(e,t,n,r,a=za){var s;null==r&&(s=t,r=Math.floor(Math.pow(2,Math.ceil(Math.log(s)/Math.log(2)))));const o=Xa(e,t,n),i=Wa(o,a(t));return Pa(i,r)}}),Hr({cropAndResize_:function(e,t,n,r,a="bilinear",s=0){const o=Gr(e,"image","cropAndResize"),i=Gr(t,"boxes","cropAndResize","float32"),u=Gr(n,"boxInd","cropAndResize","int32"),l=i.shape[0];d(4===o.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`)),d(2===i.rank&&4===i.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`)),d(1===u.rank&&u.shape[0]===l,(()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`)),d(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),d(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),d("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));const c={image:o,boxes:i,boxInd:u},p={method:a,extrapolationValue:s,cropSize:r};return ar.runKernel(xe,c,p)}}),Hr({flipLeftRight_:function(e){const t=Gr(e,"image","flipLeftRight","float32");d(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return ar.runKernel(_e,n,{})}});const qa=Hr({tile_:function(e,t){const n=Gr(e,"x","tile","string_or_numeric");d(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},a={reps:t};return ar.runKernel(Gt,r,a)}});function Ka(e,t,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=e.shape[0];return n=Math.min(n,o),d(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),d(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),d(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),d(1===t.rank,(()=>"scores must be a 1D tensor")),d(t.shape[0]===o,(()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`)),d(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}function Ya(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,a=e.length,s=0,o=!1;for(;r<a;){s=r+(a-r>>>1);const i=n(t,e[s]);i>0?r=s+1:(a=s,o=!i)}return o?r:-r-1}(e,t,n||Qa)}(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function Qa(e,t){return e>t?1:e<t?-1:0}function Za(e,t,n,r,a,s,o=!1,i=!1,u=!1){const l=[];for(let e=0;e<t.length;e++)t[e]>a&&l.push({score:t[e],boxIndex:e,suppressBeginIndex:0});l.sort(ts);const c=s>0?-.5/s:0,d=[],p=[];for(;d.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=t;if(n<a)break;let i=!1;for(let n=d.length-1;n>=o;--n){const o=Ja(e,s,d[n]);if(o>=r){i=!0;break}if(t.score=t.score*es(r,c,o),t.score<=a)break}t.suppressBeginIndex=d.length,i||(t.score===n?(d.push(s),p.push(t.score)):t.score>a&&Ya(l,t,ts))}const h=d.length,f=n-h;i&&f>0&&(d.push(...new Array(f).fill(0)),p.push(...new Array(f).fill(0)));const m={selectedIndices:d};return o&&(m.selectedScores=p),u&&(m.validOutputs=h),m}function Ja(e,t,n){const r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(a[0],a[2]),c=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),p=Math.max(a[1],a[3]),h=(i-s)*(u-o),f=(d-l)*(p-c);if(h<=0||f<=0)return 0;const m=Math.max(s,l),g=Math.max(o,c),x=Math.min(i,d),b=Math.min(u,p),y=Math.max(x-m,0)*Math.max(b-g,0);return y/(h+f-y)}function es(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function ts(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}Hr({grayscaleToRGB_:function(e){const t=Gr(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];d(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),d(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,qa(t,a)}}),Hr({rotateWithOffset_:function(e,t,n=0,r=.5){const a=Gr(e,"image","rotateWithOffset","float32");d(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));const s={image:a},o={radians:t,fillValue:n,center:r};return ar.runKernel(Yt,s,o)}}),Hr({nonMaxSuppression_:function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){const s=Gr(e,"boxes","nonMaxSuppression","float32"),o=Gr(t,"scores","nonMaxSuppression","float32"),i=Ka(s,o,n,r,a),u={maxOutputSize:n=i.maxOutputSize,iouThreshold:r=i.iouThreshold,scoreThreshold:a=i.scoreThreshold};return ar.runKernel(nt,{boxes:s,scores:o},u)}}),Hr({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){const o=Gr(e,"boxes","nonMaxSuppression"),i=Gr(t,"scores","nonMaxSuppression"),u=Ka(o,i,n,r,a,s),l={boxes:o,scores:i},c={maxOutputSize:n=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:a=u.scoreThreshold,softNmsSigma:s=u.softNmsSigma},d=ar.runKernel(at,l,c);return{selectedIndices:d[0],selectedScores:d[1]}}}),Hr({nonMaxSuppressionPadded_:function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){const o=Gr(e,"boxes","nonMaxSuppression"),i=Gr(t,"scores","nonMaxSuppression"),u=Ka(o,i,n,r,a,null),l={boxes:o,scores:i},c={maxOutputSize:u.maxOutputSize,iouThreshold:u.iouThreshold,scoreThreshold:u.scoreThreshold,padToMaxOutputSize:s},d=ar.runKernel(rt,l,c);return{selectedIndices:d[0],validOutputs:d[1]}}}),Hr({resizeBilinear_:function(e,t,n=!1,r=!1){const a=Gr(e,"images","resizeBilinear");d(3===a.rank||4===a.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`)),d(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),d(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=$a(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,i={images:s},u={alignCorners:n,halfPixelCenters:r,size:t},l=ar.runKernel(xt,i,u);return o?$a(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),Hr({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){const a=Gr(e,"images","resizeNearestNeighbor");d(3===a.rank||4===a.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`)),d(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),d("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),d(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=$a(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,i={images:s},u={alignCorners:n,halfPixelCenters:r,size:t},l=ar.runKernel(gt,i,u);return o?$a(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const ns=Hr({bincount_:function(e,t,n){const r=Gr(e,"x","bincount"),a=Gr(t,"weights","bincount");d("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),d(n>=0,(()=>`size must be non-negative, but got ${n}.`)),d(a.size===r.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`));const s={x:r,weights:a},o={size:n};return ar.runKernel(se,s,o)}}),rs=Hr({lessEqual_:function(e,t){let n=Gr(e,"a","lessEqual","string_or_numeric"),r=Gr(t,"b","lessEqual","string_or_numeric");[n,r]=Qn(n,r),ra(n.shape,r.shape);const a={a:n,b:r};return ar.runKernel(We,a)}}),as=Hr({greater_:function(e,t){let n=Gr(e,"a","greater","string_or_numeric"),r=Gr(t,"b","greater","string_or_numeric");[n,r]=Qn(n,r),ra(n.shape,r.shape);const a={a:n,b:r};return ar.runKernel(Fe,a)}}),ss=Hr({sum_:function(e,t=null,n=!1){let r=Gr(e,"x","sum");"bool"===r.dtype&&(r=jr(r,"int32"));const a={x:r},s={axis:t,keepDims:n};return ar.runKernel(_t,a,s)}}),os=Hr({add_:function(e,t){let n=Gr(e,"a","add"),r=Gr(t,"b","add");[n,r]=Qn(n,r);const a={a:n,b:r};return ar.runKernel(Q,a)}}),is=Hr({floorDiv_:function(e,t){let n=Gr(e,"a","floorDiv"),r=Gr(t,"b","floorDiv");[n,r]=Qn(n,r);const a={a:n,b:r};return ar.runKernel(Te,a)}}),us=Hr({div_:function(e,t){let n=Gr(e,"a","div"),r=Gr(t,"b","div");if([n,r]=Qn(n,r),"int32"===n.dtype&&"int32"===r.dtype)return is(n,r);const a={a:n,b:r};return ar.runKernel(we,a,{})}}),ls=Hr({sub_:function(e,t){let n=Gr(e,"a","sub"),r=Gr(t,"b","sub");[n,r]=Qn(n,r);const a={a:n,b:r};return ar.runKernel(Ut,a)}}),cs=Hr({round_:function(e){const t={x:Gr(e,"x","round")};return ar.runKernel(wt,t)}}),ds=Hr({where_:function(e,t,n){const r=Gr(t,"a","where"),a=Gr(n,"b","where"),s=Gr(e,"condition","where","bool"),o=ra(ra(s.shape,r.shape),a.shape),i={condition:Sa(s,o),t:Sa(r,o),e:Sa(a,o)};return ar.runKernel(kt,i)}});function ps(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const a={start:e,stop:t,step:n,dtype:r};return ar.runKernel(pt,{},a)}Hr({threshold_:function(e,t="binary",n=!1,r=.5){const a=Gr(e,"image","threshold"),s=a.shape[0]*a.shape[1];let o,i,u,l,c=Wa(Va([r]),255);if(d(3===a.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`)),d(3===a.shape[2]||1===a.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`)),d("int32"===a.dtype||"float32"===a.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`)),d("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===a.shape[2]){[o,i,u]=Da(a,[1,1,1],-1);const e=Wa(o,.2989),t=Wa(i,.587),n=Wa(u,.114);l=os(os(e,t),n)}else l=e;var p,h;"otsu"===t&&(c=function(e,t){let n,r,a,s,o,i,u=Va([-1]),l=Va([0]),c=Va([0]);for(let d=0;d<e.size-1;d++){n=Oa(e,0,d+1),r=Oa(e,d+1),o=us(ss(n),t),i=us(ss(r),t);const p=ss(Wa(n,ps(0,n.size)));a=us(p,ss(n));const h=Ha(r.shape,n.size),f=os(ps(0,r.size),h),m=Wa(r,f);s=us(ss(m),ss(r));const g=ls(a,s),x=ls(a,s),b=Wa(o,i);c=Wa(Wa(b,g),x);const y=as(c,l);l=ds(y,c,l),u=ds(y,Va([d]),u)}return u}(ns(jr(cs(l),"int32"),_a(p=[],undefined,Wr(p,h),h),256),s));const f=n?rs(l,c):as(l,c);return jr(Wa(f,255),"int32")}}),Hr({transform_:function(e,t,n="nearest",r="constant",a=0,s){const o=Gr(e,"image","transform","float32"),i=Gr(t,"transforms","transform","float32");d(4===o.rank,(()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`)),d(2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),d(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));const u={image:o,transforms:i},l={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return ar.runKernel(Ht,u,l)}});const hs=Hr({greaterEqual_:function(e,t){let n=Gr(e,"a","greaterEqual","string_or_numeric"),r=Gr(t,"b","greaterEqual","string_or_numeric");[n,r]=Qn(n,r),ra(n.shape,r.shape);const a={a:n,b:r};return ar.runKernel(Oe,a)}}),fs=Hr({logicalAnd_:function(e,t){const n=Gr(e,"a","logicalAnd","bool"),r=Gr(t,"b","logicalAnd","bool");ra(n.shape,r.shape);const a={a:n,b:r};return ar.runKernel(Ge,a)}}),ms=Hr({stack_:function(e,t=0){const n=zr(e,"tensors","stack","string_or_numeric");d(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&d(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,a={axis:t};return ar.runKernel(it,r,a)}}),gs=Hr({unstack_:function(e,t=0){const n=Gr(e,"x","unstack","string_or_numeric");d(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},a={axis:t};return ar.runKernel(Xt,r,a)}});Hr({bandPart_:function(e,t,n){d(t%1==0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),d(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`));const r=Gr(e,"a","bandPart");d(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const a=r.shape,[s,o]=r.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);t<0&&(t=s),n<0&&(n=o);const i=$a(ps(0,s,1,"int32"),[-1,1]),u=ps(0,o,1,"int32"),l=ls(i,u),c=fs(rs(l,Ea(+t,"int32")),hs(l,Ea(-n,"int32"))),p=Ra([s,o],r.dtype);return $a(ms(gs($a(r,[-1,s,o])).map((e=>ds(c,e,p)))),a)}});const xs=Hr({abs_:function(e){const t=Gr(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return ar.runKernel(ce,e)}{const e={x:t};return ar.runKernel(Y,e)}}});function bs(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function ys(e,t,n){const r=e.length+t.length,a=[];let s=0,o=0;for(let i=0;i<r;i++)-1===n.indexOf(i)?a.push(e[s++]):a.push(t[o++]);return a}function ws(e,t){const n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]}function vs(e,t){return ys(e,t.map((e=>1)),t)}function Is(e,t,n){d(bs(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function ks(e,t){if(bs(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function Cs(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function $s(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const Ss=Hr({max_:function(e,t=null,n=!1){const r={x:Gr(e,"x","max")},a={reductionIndices:t,keepDims:n};return ar.runKernel(je,r,a)}}),_s=Hr({min_:function(e,t=null,n=!1){const r={x:Gr(e,"x","min")},a={axis:t,keepDims:n};return ar.runKernel(Ye,r,a)}}),Es=Hr({pow_:function(e,t){let n=Gr(e,"base","pow"),r=Gr(t,"exp","pow");[n,r]=Qn(n,r);const a={a:n,b:r};return ar.runKernel(lt,a)}}),Ts=Hr({sqrt_:function(e){const t={x:Gr(e,"x","sqrt","float32")};return ar.runKernel(St,t)}}),Rs=Hr({square_:function(e){const t=Gr(e,"x","square");return ar.runKernel("Square",{x:t},{})}});function Ns(e,t,n=null){if(0===e.rank)return xs(e);if(1!==e.rank&&null===n)return Ns($a(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return ss(xs(e),n);if(t===1/0)return Ss(xs(e),n);if(t===-1/0)return _s(xs(e),n);if("euclidean"===t||2===t)return Ts(ss(Es(xs(e),Ea(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Ss(ss(xs(e),n[0]),n[1]-1);if(t===1/0)return Ss(ss(xs(e),n[1]),n[0]);if(t===-1/0)return _s(ss(xs(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Ts(ss(Rs(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const As=Hr({norm_:function(e,t="euclidean",n=null,r=!1){const a=Ns(e=Gr(e,"x","norm"),t,n);let s=a.shape;if(r){const t=I(n,e.shape);s=vs(a.shape,t)}return $a(a,s)}}),Fs=Hr({squeeze_:function(e,t){const n=Gr(e,"x","squeeze","string_or_numeric");return $a(n,k(n.shape,t).newShape)}});function Os(){return ar}function Ds(e,t){return ar.tidy(e,t)}function Ms(e,t,n=1){return ar.registerBackend(e,t,n)}Hr({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,d(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)d(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=Da(e,e.shape[0],0).map((e=>Fs(e,[0])));d(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let t=0;t<e.length;++t)n.push(ar.tidy((()=>{let e=r[t];if(t>0)for(let r=0;r<t;++r){const t=Wa(ss(Wa(n[r],e)),n[r]);e=ls(e,t)}return us(e,As(e,"euclidean"))})));return t?ms(n,0):n}}),Wn=function(e){H().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};const Ls=Hr({expandDims_:function(e,t=0){const n=Gr(e,"x","expandDims","string_or_numeric");d(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},a={dim:t};return ar.runKernel(Ce,r,a)}}),Ps=Hr({eye_:function(e,t,n,r="float32"){null==t&&(t=e);const a=Br([e,t],r),s=e<=t?e:t;for(let e=0;e<s;++e)a.set(1,e,e);const o=$a(a.toTensor(),[e,t]);if(null==n)return o;if(1===n.length)return qa(Ls(o,0),[n[0],1,1]);if(2===n.length)return qa(Ls(Ls(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return qa(Ls(Ls(Ls(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}}),Bs=Hr({matMul_:function(e,t,n=!1,r=!1){let a=Gr(e,"a","matMul"),s=Gr(t,"b","matMul");[a,s]=Qn(a,s);const o={a,b:s},i={transposeA:n,transposeB:r};return ar.runKernel(re,o,i)}}),Ws=Hr({neg_:function(e){const t={x:Gr(e,"x","neg")};return ar.runKernel(et,t)}}),Us=Hr({transpose_:function(e,t,n){const r=Gr(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),d(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{d(e>=0&&e<r.rank,(()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${t}`))})),r.rank<=1)return r.clone();const a={x:r},s={perm:t};return"complex64"===r.dtype?Ds((()=>{let e=Fa(r),t=Aa(r);return e=ar.runKernel(jt,{x:e},s),t=ar.runKernel(jt,{x:t},s),n&&(t=Ws(t)),Ta(e,t)})):ar.runKernel(jt,a,s)}});function Vs(e,t=!1){return ar.tidy((()=>{d(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let a=Ps(n),s=Xr(e);const o=ja([[1]],[1,1]);let i=Xr(o);const u=n>=r?r:n;for(let e=0;e<u;++e){const t=s,u=i,l=a;[i,s,a]=ar.tidy((()=>{const t=Oa(s,[e,e],[n-e,1]),u=As(t),l=Oa(s,[e,e],[1,1]),c=ds(as(l,0),ja([[-1]]),ja([[1]])),d=ls(l,Wa(c,u)),p=us(t,d);i=1===p.shape[0]?Xr(o):Na([o,Oa(p,[1,0],[p.shape[0]-1,p.shape[1]])],0);const h=Ws(us(Bs(c,d),u)),f=Oa(s,[e,0],[n-e,r]),m=Wa(h,i),g=Us(i);if(0===e)s=ls(f,Bs(m,Bs(g,f)));else{const t=ls(f,Bs(m,Bs(g,f)));s=Na([Oa(s,[0,0],[e,r]),t],0)}const x=Us(m),b=Oa(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=ls(b,Bs(Bs(b,i),x));else{const t=ls(b,Bs(Bs(b,i),x));a=Na([Oa(a,[0,0],[n,e]),t],1)}return[i,s,a]})),Zn([t,u,l]).forEach((e=>e.dispose()))}return!t&&n>r&&(a=Oa(a,[0,0],[n,r]),s=Oa(s,[0,0],[r,r])),[a,s]}))}var Gs;Hr({qr_:function(e,t=!1){if(d(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return Vs(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=gs($a(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];return r.forEach((e=>{const[n,r]=Vs(e,t);a.push(n),s.push(r)})),[$a(ms(a,0),e.shape),$a(ms(s,0),e.shape)]}}}),function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Gs||(Gs={}));const zs=Hr({mean_:function(e,t=null,n=!1){const r={x:Gr(e,"x","mean")},a={axis:t,keepDims:n};return ar.runKernel(Ke,r,a)}}),Hs=Hr({notEqual_:function(e,t){let n=Gr(e,"a","notEqual","string_or_numeric"),r=Gr(t,"b","notEqual","string_or_numeric");[n,r]=Qn(n,r),ra(n.shape,r.shape);const a={a:n,b:r};return ar.runKernel(tt,a)}});function js(e,t="float32"){if("complex64"===t){const t=js(e,"float32"),n=Ra(e,"float32");return Ta(t,n)}const n=M(m(e),t);return ar.makeTensor(n,e,t)}const Xs=Hr({computeWeightedLoss_:function(e,t,n=Gs.SUM_BY_NONZERO_WEIGHTS){const r=Gr(e,"losses","computeWeightedLoss");let a=null;null!=t&&(a=Gr(t,"weights","computeWeightedLoss"));const s=null==a?r:Wa(r,a);if(n===Gs.NONE)return s;if(n===Gs.SUM)return ss(s);if(n===Gs.MEAN){if(null==a)return zs(s);{const e=r.size/a.size,t=us(ss(s),ss(a));return e>1?us(t,Ea(e)):t}}if(n===Gs.SUM_BY_NONZERO_WEIGHTS){if(null==a)return us(ss(s),Ea(r.size));{const e=Wa(a,js(r.shape)),t=jr(ss(Hs(e,Ea(0))),"float32");return us(ss(s),t)}}throw Error(`Unknown reduction: ${n}`)}});Hr({absoluteDifference_:function(e,t,n,r=Gs.SUM_BY_NONZERO_WEIGHTS){const a=Gr(e,"labels","absoluteDifference"),s=Gr(t,"predictions","absoluteDifference");let o=null;null!=n&&(o=Gr(n,"weights","absoluteDifference")),p(a.shape,s.shape,"Error in absoluteDifference: ");const i=xs(ls(a,s));return Xs(i,o,r)}}),Hr({cosineDistance_:function(e,t,n,r,a=Gs.SUM_BY_NONZERO_WEIGHTS){const s=Gr(e,"labels","cosineDistance"),o=Gr(t,"predictions","cosineDistance");let i=null;null!=r&&(i=Gr(r,"weights","cosineDistance")),p(s.shape,o.shape,"Error in cosineDistance: ");const u=Ea(1),l=ls(u,ss(Wa(s,o),n,!0));return Xs(l,i,a)}});const qs=Hr({relu_:function(e){const t={x:Gr(e,"x","relu")};return ar.runKernel(ft,t)}});Hr({hingeLoss_:function(e,t,n,r=Gs.SUM_BY_NONZERO_WEIGHTS){let a=Gr(e,"labels","hingeLoss");const s=Gr(t,"predictions","hingeLoss");let o=null;null!=n&&(o=Gr(n,"weights","hingeLoss")),p(a.shape,s.shape,"Error in hingeLoss: ");const i=Ea(1);a=ls(Wa(Ea(2),a),i);const u=qs(ls(i,Wa(a,s)));return Xs(u,o,r)}});const Ks=Hr({minimum_:function(e,t){let n=Gr(e,"a","minimum"),r=Gr(t,"b","minimum");[n,r]=Qn(n,r),"bool"===n.dtype&&(n=jr(n,"int32"),r=jr(r,"int32")),ra(n.shape,r.shape);const a={a:n,b:r};return ar.runKernel(Qe,a)}});Hr({huberLoss_:function(e,t,n,r=1,a=Gs.SUM_BY_NONZERO_WEIGHTS){const s=Gr(e,"labels","huberLoss"),o=Gr(t,"predictions","huberLoss");let i=null;null!=n&&(i=Gr(n,"weights","huberLoss")),p(s.shape,o.shape,"Error in huberLoss: ");const u=Ea(r),l=xs(ls(o,s)),c=Ks(l,u),d=ls(l,c),h=os(Wa(Ea(.5),Rs(c)),Wa(u,d));return Xs(h,i,a)}});const Ys=Hr({log_:function(e){const t={x:Gr(e,"x","log","float32")};return ar.runKernel(Ue,t)}});Hr({logLoss_:function(e,t,n,r=1e-7,a=Gs.SUM_BY_NONZERO_WEIGHTS){const s=Gr(e,"labels","logLoss"),o=Gr(t,"predictions","logLoss");let i=null;null!=n&&(i=Gr(n,"weights","logLoss")),p(s.shape,o.shape,"Error in logLoss: ");const u=Ea(1),l=Ea(r),c=Ws(Wa(s,Ys(os(o,l)))),d=Wa(ls(u,s),Ys(os(ls(u,o),l))),h=ls(c,d);return Xs(h,i,a)}});const Qs=Hr({squaredDifference_:function(e,t){let n=Gr(e,"a","squaredDifference"),r=Gr(t,"b","squaredDifference");[n,r]=Qn(n,r),ra(n.shape,r.shape);const a={a:n,b:r};return ar.runKernel(Dt,a,{})}});Hr({meanSquaredError_:function(e,t,n,r=Gs.SUM_BY_NONZERO_WEIGHTS){const a=Gr(e,"labels","meanSquaredError"),s=Gr(t,"predictions","meanSquaredError");let o=null;null!=n&&(o=Gr(n,"weights","meanSquaredError")),p(a.shape,s.shape,"Error in meanSquaredError: ");const i=Qs(a,s);return Xs(i,o,r)}});const Zs=Hr({exp_:function(e){const t={x:Gr(e,"x","exp")};return ar.runKernel(ke,t)}}),Js=Hr({log1p_:function(e){const t={x:Gr(e,"x","log1p")};return ar.runKernel(Ve,t)}});Hr({sigmoidCrossEntropy_:function(e,t,n,r=0,a=Gs.SUM_BY_NONZERO_WEIGHTS){let s=Gr(e,"multiClassLabels","sigmoidCrossEntropy");const o=Gr(t,"logits","sigmoidCrossEntropy");let i=null;if(null!=n&&(i=Gr(n,"weights","sigmoidCrossEntropy")),p(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=Ea(r),t=Ea(1),n=Ea(.5);s=os(Wa(s,ls(t,e)),Wa(n,e))}const u=function(e,t){const n=Gr(e,"labels","sigmoidCrossEntropyWithLogits"),r=Gr(t,"logits","sigmoidCrossEntropyWithLogits");p(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const a=qs(r),s=Wa(r,n),o=Js(Zs(Ws(xs(r))));return os(ls(a,s),o)}(s,o);return Xs(u,i,a)}});const eo=Hr({logSumExp_:function(e,t=null,n=!1){const r=Gr(e,"x","logSumExp"),a=I(t,r.shape),s=Ss(r,a,!0),o=ls(r,s),i=Zs(o),u=ss(i,a),l=Ys(u),c=os($a(s,l.shape),l);if(n){const e=vs(c.shape,a);return $a(c,e)}return c}});Hr({softmaxCrossEntropy_:function(e,t,n,r=0,a=Gs.SUM_BY_NONZERO_WEIGHTS){let s=Gr(e,"onehotLabels","softmaxCrossEntropy");const o=Gr(t,"logits","softmaxCrossEntropy");let i=null;if(null!=n&&(i=Gr(n,"weights","softmaxCrossEntropy")),p(s.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const e=Ea(r),t=Ea(1),n=Ea(s.shape[1]);s=os(Wa(s,ls(t,e)),us(e,n))}const u=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const r=(a=(e,t,r)=>{const a=eo(t,[n],!0),s=ls(jr(t,"float32"),a);r([e,s]);const o=Ws(Wa(s,e));return{value:ss(o,[n]),gradFunc:(e,t)=>{const[r,a]=t,s=vs(e.shape,[n]);return[Wa($a(e,s),ls(jr(r,"float32"),Zs(a))),Wa($a(e,s),ls(Zs(a),jr(r,"float32")))]}}},ar.customGrad(a));var a;return r(e,t)}(s,o);return Xs(u,i,a)}}),Hr({sparseFillEmptyRows_:function(e,t,n,r){const a=Gr(e,"indices","sparseFillEmptyRows","int32"),s=Gr(t,"values","sparseFillEmptyRows"),o=Gr(n,"denseShape","sparseFillEmptyRows","int32"),i=Gr(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==o.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(0!==i.rank)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const u={indices:a,values:s,denseShape:o,defaultValue:i},l=ar.runKernel(Nt,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}}),Hr({sparseReshape_:function(e,t,n){const r=Gr(e,"inputIndices","sparseReshape","int32"),a=Gr(t,"inputShape","sparseReshape","int32"),s=Gr(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const o={inputIndices:r,inputShape:a,newShape:s},i=ar.runKernel(At,o);return{outputIndices:i[0],outputShape:i[1]}}}),Hr({sparseSegmentMean_:function(e,t,n){const r=Gr(e,"data","sparseSegmentMean"),a=Gr(t,"indices","sparseSegmentMean","int32"),s=Gr(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);const o={data:r,indices:a,segmentIds:s};return ar.runKernel(Ft,o)}}),Hr({sparseSegmentSum_:function(e,t,n){const r=Gr(e,"data","sparseSegmentSum"),a=Gr(t,"indices","sparseSegmentSum","int32"),s=Gr(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);const o={data:r,indices:a,segmentIds:s};return ar.runKernel(Ot,o)}}),Hr({stringNGrams_:function(e,t,n,r,a,s,o,i){const u=Gr(e,"data","stringNGrams","string");if("string"!==u.dtype)throw new Error("Data must be of datatype string");if(1!==u.shape.length)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=Gr(t,"dataSplits","stringNGrams");if("int32"!==l.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:o,preserveShortSequences:i},d={data:u,dataSplits:l},p=ar.runKernel(Pt,d,c);return{nGrams:p[0],nGramsSplits:p[1]}}}),Hr({stringSplit_:function(e,t,n=!0){const r=Gr(e,"input","stringSplit","string"),a=Gr(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);const s={skipEmpty:n},o={input:r,delimiter:a},i=ar.runKernel(Bt,o,s);return{indices:i[0],values:i[1],shape:i[2]}}}),Hr({stringToHashBucketFast_:function(e,t){const n=Gr(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const a={input:n};return ar.runKernel(Wt,a,r)}});const to="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function no(e,t){const n=e[0].length;e.forEach(((e,t)=>{d(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),d(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,a)=>{for(let s=0;s<n;s++)d(s===t||e[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`))}))}function ro(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}function ao(e,t,n,r,a="NHWC",s){return io(e,[...t,e[3]],n,s,r,null,null,xo(a))}function so(e,t,n,r,a,s,o="channelsLast"){const[i,u]=co(t);let l;if("channelsLast"===o)l=[i,u,e[3],e[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);l=[i,u,e[1],e[1]]}return io(e,l,n,r,a,s,!1,o)}function oo(e,t,n,r,a,s,o="NDHWC"){const[i,u,l]=po(t);let c,d;if("NDHWC"===o)d="channelsLast",c=[i,u,l,e[4],e[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);d="channelsFirst",c=[i,u,l,e[1],e[1]]}return uo(e,c,n,r,a,!1,d,s)}function io(e,t,n,r,a,s,o=!1,i="channelsLast"){let[u,l,c,d]=[-1,-1,-1,-1];if("channelsLast"===i)[u,l,c,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[u,d,l,c]=e}const[p,h,,f]=t,[m,g]=co(n),[x,b]=co(r),y=ho(p,x),w=ho(h,b),{padInfo:v,outHeight:I,outWidth:k}=function(e,t,n,r,a,s,o,i,u){let l,c,d;if("number"==typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const a=function(e,t,n,r,a){null==r&&(r=lo(e,t,n));const s=e[1];return[fo((e[0]-t+2*r)/n+1,a),fo((s-t+2*r)/n+1,a)]}([t,n],s,r,e,i);c=a[0],d=a[1]}else if("same"===e){c=Math.ceil(t/r),d=Math.ceil(n/a);const e=Math.max(0,(c-1)*r+s-t),i=Math.max(0,(d-1)*a+o-n),u=Math.floor(e/2),p=e-u,h=Math.floor(i/2);l={top:u,bottom:p,left:h,right:i-h,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/r),d=Math.ceil((n-o+1)/a);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const p="channelsLast"===u?e[1][0]:e[2][0],h="channelsLast"===u?e[1][1]:e[2][1],f="channelsLast"===u?e[2][0]:e[3][0],m="channelsLast"===u?e[2][1]:e[3][1];l={top:p,bottom:h,left:f,right:m,type:0===p&&0===h&&0===f&&0===m?"VALID":"EXPLICIT"},c=fo((t-s+p+h)/r+1,i),d=fo((n-o+f+m)/a+1,i)}}return{padInfo:l,outHeight:c,outWidth:d}}(a,l,c,m,g,y,w,s,i),C=o?f*d:f;let $;return"channelsFirst"===i?$=[u,C,I,k]:"channelsLast"===i&&($=[u,I,k,C]),{batchSize:u,dataFormat:i,inHeight:l,inWidth:c,inChannels:d,outHeight:I,outWidth:k,outChannels:C,padInfo:v,strideHeight:m,strideWidth:g,filterHeight:p,filterWidth:h,effectiveFilterHeight:y,effectiveFilterWidth:w,dilationHeight:x,dilationWidth:b,inShape:e,outShape:$,filterShape:t}}function uo(e,t,n,r,a,s=!1,o="channelsLast",i){let[u,l,c,d,p]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[u,l,c,d,p]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[u,p,l,c,d]=e}const[h,f,m,,g]=t,[x,b,y]=po(n),[w,v,I]=po(r),k=ho(h,w),C=ho(f,v),$=ho(m,I),{padInfo:S,outDepth:_,outHeight:E,outWidth:T}=function(e,t,n,r,a,s,o,i,u,l,c){let d,p,h,f;if("number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,a,s){null==a&&(a=lo(e,t,r));const o=e[1],i=e[2];return[fo((e[0]-t+2*a)/r+1,s),fo((o-t+2*a)/r+1,s),fo((i-t+2*a)/r+1,s),1]}([t,n,r,1],i,0,a,e,c);p=s[0],h=s[1],f=s[2]}else if("same"===e){p=Math.ceil(t/a),h=Math.ceil(n/s),f=Math.ceil(r/o);const e=(p-1)*a+i-t,c=(h-1)*s+u-n,m=(f-1)*o+l-r,g=Math.floor(e/2),x=e-g,b=Math.floor(c/2),y=c-b,w=Math.floor(m/2);d={top:b,bottom:y,left:w,right:m-w,front:g,back:x,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},p=Math.ceil((t-i+1)/a),h=Math.ceil((n-u+1)/s),f=Math.ceil((r-l+1)/o)}return{padInfo:d,outDepth:p,outHeight:h,outWidth:f}}(a,l,c,d,x,b,y,k,C,$,i),R=s?g*p:g;let N;return"channelsFirst"===o?N=[u,R,_,E,T]:"channelsLast"===o&&(N=[u,_,E,T,R]),{batchSize:u,dataFormat:o,inDepth:l,inHeight:c,inWidth:d,inChannels:p,outDepth:_,outHeight:E,outWidth:T,outChannels:R,padInfo:S,strideDepth:x,strideHeight:b,strideWidth:y,filterDepth:h,filterHeight:f,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:C,effectiveFilterWidth:$,dilationDepth:w,dilationHeight:v,dilationWidth:I,inShape:e,outShape:N,filterShape:t}}function lo(e,t,n,r=1){const a=ho(t,r);return Math.floor((e[0]*(n-1)-n+a)/2)}function co(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function po(e){return"number"==typeof e?[e,e,e]:e}function ho(e,t){return t<=1?e:e+(e-1)*(t-1)}function fo(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function mo(e){const[t,n,r]=co(e);return 1===t&&1===n&&1===r}function go(e,t){return mo(e)||mo(t)}function xo(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function bo(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)d(x(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{d(x(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}const yo=Hr({elu_:function(e){const t={x:Gr(e,"x","elu","float32")};return ar.runKernel(ve,t)}}),wo=Hr({leakyRelu_:function(e,t=.2){const n={x:Gr(e,"x","leakyRelu")},r={alpha:t};return ar.runKernel(Pe,n,r)}}),vo=Hr({prelu_:function(e,t){const n={x:Gr(e,"x","prelu"),alpha:Gr(t,"alpha","prelu")};return ar.runKernel(ct,n)}}),Io=Hr({relu6_:function(e){const t={x:Gr(e,"x","relu6")};return ar.runKernel(bt,t)}}),ko=Hr({sigmoid_:function(e){const t={x:Gr(e,"x","sigmoid","float32")};return ar.runKernel($t,t)}}),Co=Hr({step_:function(e,t=0){const n={x:Gr(e,"x","step")},r={alpha:t};return ar.runKernel(Kt,n,r)}});function $o(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Wa(e,Co(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function So(e,t){let n=t;const r=na(e.shape,t.shape);return r.length>0&&(n=ss(n,r)),$a(n,e.shape)}function _o(e,t,n,r){if("linear"===t)return e;if("relu"===t)return qs(e);if("elu"===t)return yo(e);if("relu6"===t)return Io(e);if("prelu"===t)return vo(e,n);if("leakyrelu"===t)return wo(e,r);if("sigmoid"===t)return ko(e);throw new Error(`Unknown fused activation ${t}.`)}const Eo=(e,t)=>!(e>0)||"linear"===t;var To;function Ro(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){const s=n[a],o=r[r.length-n.length+a],i=r[o];if(s>=0)if(i>=0){if(i!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${i}`)}else r[o]=s}return r}function No(e){const t={FIRST_DIM_SIZE:To.FIRST_DIM_SIZE,VALUE_ROWIDS:To.VALUE_ROWIDS,ROW_LENGTHS:To.ROW_LENGTHS,ROW_SPLITS:To.ROW_SPLITS,ROW_LIMITS:To.ROW_LIMITS,ROW_STARTS:To.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function Ao(e){return 0===e.length?0:e[0]===To.FIRST_DIM_SIZE?e.length-1:e.length}function Fo(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){const n=e[a],r=t[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${n} but ragged tensor input.flatValues.shape[${a-e.length}] = ${r}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(To||(To={}));const Oo=30;function Do(e){return e<=Oo?e:A(e,Math.floor(Math.sqrt(e)))}function Mo(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function Lo(e,t,n,r=!0){let a=[];if(r)a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function Po(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],a=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?a.push(r):n.push(r);r.push(...n),r.push(0),r.push(...a)}return r}function Bo(e,t,n,r=!0){const a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?a.push(t[n-1]*e[n]):a.push(e[n]/t[n-1]):a.push(e[n]);return a}function Wo(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function Uo(e,t,n){const r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}const Vo=1.7580993408473768,Go=1.0507009873554805,zo=.3275911,Ho=.254829592,jo=-.284496736,Xo=1.421413741,qo=-1.453152027,Ko=1.061405429;function Yo(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Qo(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function Zo(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function Jo(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function ei(e,t){return{real:e[2*t],imag:e[2*t+1]}}function ti(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function ni(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){const s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function ri(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const ai="->",si=/->/g;function oi(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(si,"").length)/ai.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${ai}").`);const[r,a]=e.split(ai);d(-1===r.indexOf("..."),(()=>'The ellipsis notation ("...") is not supported yet.'));const s=r.split(","),o=s.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let e=0;e<a.length;++e){const t=a[e];if(!s.some((e=>-1!==e.indexOf(t))))throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===i.indexOf(t)&&i.push(t)}for(let e=0;e<r.length;++e){const t=r[e];-1===i.indexOf(t)&&","!==t&&i.push(t)}const u=new Array(s.length);for(let e=0;e<o;++e){if(new Set(s[e].split("")).size!==s[e].length)throw new Error(`Found duplicate axes in input component ${s[e]}. Support for duplicate axes in input is not implemented yet.`);u[e]=[];for(let t=0;t<s[e].length;++t)u[e].push(i.indexOf(s[e][t]))}const l=i.length,c=[];for(let e=a.length;e<l;++e)c.push(e);return{allDims:i,summedDims:c,idDims:u}}function ii(e,t){let n=new Array(e);n.fill(-1);for(let e=0;e<t.length;++e)n[t[e]]=e;const r=[];for(let t=0;t<e;++t)-1===n[t]&&r.push(t);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function ui(e,t,n){const r=new Array(e);for(let e=0;e<n.length;++e){const a=n[e].shape;for(let n=0;n<t[e].length;++n)void 0===r[t[e][n]]?r[t[e][n]]=a[n]:d(r[t[e][n]]===a[n],(()=>`Expected dimension ${r[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(a)}, but got dimension ${a[n]}`))}}function li(e,t){const n=e,r=[];let a=0;0===e.length&&n.push(-1),a=e.length+1;for(let e=0;e<a;++e)r.push([]);const s=[];for(let e=0;e<n.length;++e){const a=di(t,n[e]);for(const t of a)-1===s.indexOf(t)&&(r[e].push(t),s.push(t))}return{path:n,steps:r}}function ci(e){return e.every(((e,t)=>e===t))}function di(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function pi(e,t,n=0){let r=[];if("number"==typeof t)d(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{d(t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0)<=1,(()=>"There should be only one negative value in split array."));const a=t.indexOf(-1);if(-1!==a){const r=t.reduce(((e,t)=>t>0?e+t:e));t[a]=e.shape[n]-r}d(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function hi(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function fi(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function mi(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function gi(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function xi(e,t){return`size ${e} must be non-negative, not ${t}`}function bi(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function yi(e,t){return`Input to reshape is a SparseTensor with ${m(e)}\n  dense values, but the requested shape requires a multiple of ${m(t)}. inputShape=${e} outputShape= ${t}`}function wi(e,t){return`Input to reshape is a tensor with ${m(e)} dense values, but the requested shape has ${m(t)}. inputShape=${e} outputShape=${t}`}function vi(){return"segment ids must be >= 0"}function Ii(){return"segment ids are not increasing"}function ki(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Ci(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function $i(e,t){let n,r=!1;for(e<=Oo?(n=e,r=!0):n=A(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=A(e,n+1);return n}function Si(e,t,n){const r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function _i(e,t,n,r){const a=t.shape.length,s=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const o=e.shape[n],i=[];let u=1,l=1,c=1;for(let t=0;t<r;++t)i.push(e.shape[t]),u*=e.shape[t];for(let t=r;t<n;t++)i.push(e.shape[t]),l*=e.shape[t];for(let e=r;e<a;e++)i.push(t.shape[e]);for(let t=n+1;t<s;t++)i.push(e.shape[t]),c*=e.shape[t];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:o,outputShape:i}}function Ei(e){try{return e.map((e=>En(e)))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Ti(e){return e.map((e=>_n(e)))}const Ri={},Ni={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Ai(e,t){if(!(e in Ri)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete Ri[e]}),!1),H().getBool("SOFTWARE_WEBGL_ENABLED")&&(Ni.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",Ni)||n.getContext("experimental-webgl",Ni):n.getContext("webgl2",Ni)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;Ri[e]=n}const n=Ri[e];return null==n||n.isContextLost()?(delete Ri[e],Ai(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Ri[e])}var Fi,Oi,Di;function Mi(e,t){return[t,e]}function Li(e){const t=m(e);return b(Math.ceil(t/4))}function Pi(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function Bi(e,t){const n=e;let r,a,s,o,i,u,l,c,d,p;return 2===H().getNumber("WEBGL_VERSION")?(r=n.R32F,a=n.R16F,s=n.RGBA16F,o=n.RGBA32F,i=n.RED,l=4,c=1,d=n.HALF_FLOAT,p=n.FLOAT,u=n.RGBA8):(r=e.RGBA,a=e.RGBA,s=e.RGBA,o=n.RGBA,i=e.RGBA,l=4,c=4,d=null!=t?t.HALF_FLOAT_OES:null,p=e.FLOAT,u=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:p}}function Wi(e,t){const n=t();return H().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}function Ui(e){return!!(H().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function Vi(e,t){return Qi(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(Fi||(Fi={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(Oi||(Oi={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(Di||(Di={}));const Gi=/ERROR: [0-9]+:([0-9]+):/g;function zi(e,t){const n=Gi.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],a=e.split("\n"),s=a.length.toString().length+2,o=a.map(((e,t)=>y((t+1).toString(),s)+e));let i=0;for(let e=0;e<o.length;e++)i=Math.max(o[e].length,i);const u=o.slice(0,r-1),l=o.slice(r-1,r),c=o.slice(r);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${y(l[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function Hi(e,t){if(Wi(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function ji(e,t,n,r,a,s,o){const i=e.getAttribLocation(t,n);return-1!==i&&(Wi(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),Wi(e,(()=>e.vertexAttribPointer(i,a,e.FLOAT,!1,s,o))),Wi(e,(()=>e.enableVertexAttribArray(i))),!0)}function Xi(e,t,n,r){Wi(e,(()=>function(e,t,n){(function(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(e,n),Wi(e,(()=>e.activeTexture(e.TEXTURE0+n))),Wi(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,r))),Wi(e,(()=>e.uniform1i(n,r)))}function qi(e,t,n){Wi(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),Wi(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function Ki(e,t){Wi(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),Wi(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function Yi(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function Qi(e,t,n){const r=Wi(e,(()=>t()));if(null==r)throw new Error(n);return r}function Zi(e,t=2){return m(e.slice(0,e.length-t))}function Ji(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function eu(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[Zi(e),...Ji(e)]),t}function tu(e){return e%2==0}function nu(e,t){if(g(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r)return!0;if(tu(n)&&tu(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&tu(e[0])&&tu(t[0])}let ru,au;function su(e,t){return null!=e.getExtension(t)}function ou(e){try{if(null!=Ai(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function iu(e){const t=Bi(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function uu(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&d("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const lu=H();function cu(){let e,t,n,r,a,s,o,i,u,l;return 2===H().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",o="out vec4 outputColor;",i=H().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",u="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",o="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:u,defineRound:l}}function du(e,t,n="index"){const r=F(t);return r.map(((t,a)=>`int ${e[a]} = ${n} / ${t}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`};`)).join("")}function pu(e,t,n="index"){const r=F(t);return r.map(((t,a)=>`int ${e[a]} = ${n} / outShapeStrides[${a}]; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`};`)).join("")}function hu(e){const t=F(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}lu.registerFlag("HAS_WEBGL",(()=>lu.getNumber("WEBGL_VERSION")>0)),lu.registerFlag("WEBGL_VERSION",(()=>ou(2)?2:ou(1)?1:0)),lu.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),lu.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===lu.get("WEBGL_VERSION"))),lu.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),lu.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),lu.registerFlag("WEBGL_PACK",(()=>lu.getBool("HAS_WEBGL"))),lu.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>lu.getBool("WEBGL_PACK"))),lu.registerFlag("WEBGL_PACK_CLIP",(()=>lu.getBool("WEBGL_PACK"))),lu.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>lu.getBool("WEBGL_PACK"))),lu.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>lu.getBool("WEBGL_PACK"))),lu.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>lu.getBool("WEBGL_PACK"))),lu.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>lu.getBool("WEBGL_PACK"))),lu.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>lu.getBool("WEBGL_PACK"))),lu.registerFlag("WEBGL_PACK_REDUCE",(()=>lu.getBool("WEBGL_PACK"))),lu.registerFlag("WEBGL_LAZILY_UNPACK",(()=>lu.getBool("WEBGL_PACK"))),lu.registerFlag("WEBGL_CONV_IM2COL",(()=>lu.getBool("WEBGL_PACK"))),lu.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==ru){const t=Ai(e);ru=t.getParameter(t.MAX_TEXTURE_SIZE)}return ru}(lu.getNumber("WEBGL_VERSION")))),lu.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==au){const t=Ai(e);au=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,au)}(lu.getNumber("WEBGL_VERSION")))),lu.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=lu.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=Ai(e);return t=su(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:su(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),lu.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>lu.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!or())),lu.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=Ai(e);if(1===e){if(!su(t,"OES_texture_float"))return!1}else if(!su(t,"EXT_color_buffer_float"))return!1;return iu(t)}(lu.getNumber("WEBGL_VERSION")))),lu.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!lu.getBool("WEBGL_FORCE_F16_TEXTURES")&&lu.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),lu.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>function(e){if(0===e)return!1;const t=Ai(e);if(1!==e){if(su(t,"EXT_color_buffer_float"))return iu(t);const e="EXT_color_buffer_half_float";if(su(t,e)){const n=t.getExtension(e);return function(e,t){const n=Bi(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(a),s}(t,n)}return!1}return!!su(t,"OES_texture_float")&&!!su(t,"WEBGL_color_buffer_float")&&iu(t)}(lu.getNumber("WEBGL_VERSION")))),lu.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=lu.getNumber("WEBGL_VERSION"))&&null!=Ai(e).fenceSync;var e})),lu.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>lu.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),lu.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),lu.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>or()?1:-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),lu.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),lu.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),lu.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),lu.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),lu.registerFlag("WEBGL_EXP_CONV",(()=>!1)),lu.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>lu.getBool("IS_TEST"))),lu.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),lu.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),lu.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1));const fu="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:mu}=r;function gu(e,t,n){const r=[];if(e.forEach((e=>{const t=m(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=Su(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const a=r.join("\n"),s=e.map((e=>function(e,t,n=!1,r){let a="";a+=n?bu(e,r):xu(e,r);const s=e.shapeInfo.logicalShape,o=t.logicalShape;return s.length<=o.length&&(a+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,i=mu(e.shapeInfo.logicalShape,t.logicalShape),u=$u(o),l=o-s;let c;const d=["x","y","z","w","u","v"];c=0===s?"":o<2&&i.length>=1?"coords = 0;":i.map((e=>`coords.${d[e+l]} = 0;`)).join("\n");let p="";p=o<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+l]}`)).join(", ");let h="return outputValue;";const f=1===m(e.shapeInfo.logicalShape),g=1===m(t.logicalShape);if(1!==s||f||g){if(f&&!g)h=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const e=s-2,t=s-1;i.indexOf(e)>-1&&i.indexOf(t)>-1?h="return vec4(outputValue.x);":i.indexOf(e)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(t)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}}else h="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${a}() {\n      ${u} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${p});\n      ${h}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,o=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===u&&null==e.shapeInfo.flatOffset&&g(o,s))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const l=$u(u),c=mu(e.shapeInfo.logicalShape,t.logicalShape),d=u-i;let p;const h=["x","y","z","w","u","v"];p=0===i?"":u<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${h[e+d]} = 0;`)).join("\n");let f="";return f=u<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+d]}`)).join(", "),`\n    float ${a}() {\n      ${l} coords = getOutputCoords();\n      ${p}\n      return get${r}(${f});\n    }\n  `}(e,t)),a}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),o=t.texShape,i=cu(),u=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(i);let l,c,d=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${yu}\n    ${wu}\n    ${vu}\n  `}(i);return t.isPacked?(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(g(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const a=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2);let o=s,i="",u="b, r, c";for(let t=2;t<e.length-1;t++)o*=e[e.length-t-1],i=`\n      int b${t} = index / ${o};\n      index -= b${t} * ${o};\n    `+i,u=`b${t}, `+u;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${i}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${u});\n    }\n  `}(e,t,n)}}(t.logicalShape,o,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(i)):(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){return g(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${pu(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;const r=du(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${pu(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=du(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=du(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=du(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,o,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(i)),n.packedInputs&&(d+=Iu),[d,u,c,a,l,s,n.userCode].join("\n")}function xu(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[a,s]=e.shapeInfo.texShape;if(1===a&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=ku(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[i,u]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${i}, ${u}, ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Cu(e)}\n      }\n    `;const a=e.shapeInfo.texShape,s=a[0],o=a[1];if(1===o&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=ku(n);return 1===o?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===s?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${o}, index + ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&g(n,s)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=s[0];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:o,keptDims:i}=k(n),u=o;if(u.length<n.length){const n=["row","col"];return`\n      ${xu(_u(e,u),t)}\n      float ${a}(int row, int col) {\n        return ${a}(${Eu(n,i)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${Cu(e)}\n      }\n    `;const l=s[0],c=s[1],d=ku(r);return 1===c?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===l?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${l}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],o=n[2],{newShape:i,keptDims:u}=k(n),l=i;if(l.length<n.length){const n=["row","col","depth"];return`\n        ${xu(_u(e,l),t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${Eu(n,u)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${o}, 1)));\n        ${Cu(e)}\n      }\n    `;const c=e.shapeInfo.texShape,d=c[0],p=c[1],h=e.shapeInfo.flatOffset;if(p===s&&null==h)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${p}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(p===o&&null==h)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=ku(r);return t?`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${o} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${p}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],o=n[2]*s,i=n[1]*o,{newShape:u,keptDims:l}=k(n);if(u.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${xu(_u(e,u),t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${Eu(n,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${i}, ${o}, ${s}, 1)));\n        ${Cu(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],h=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(h===i&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(h===s&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const x=ku(r);return t?`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${x});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${p}, ${h}, index + ${x});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,o=t[2]*s,i=t[1]*o,{newShape:u,keptDims:l}=k(t);if(u.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${xu(_u(e,u))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Eu(t,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${i}, ${o}, ${s}, ${a})) +\n          depth3;\n        ${Cu(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],h=d[1];if(h===i&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${s}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(h===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} + depth * ${s} +\n          depth2 * ${a} + depth3 + ${ku(n)};\n      vec2 uv = uvFromFlat(${p}, ${h}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=k(t);if(a.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${xu(_u(e,a))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Eu(t,s)});\n      }\n    `}const o=t[5],i=t[4]*o,u=t[3]*i,l=t[2]*u,c=t[1]*l;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${l}, ${u}, ${i})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${Cu(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],f=p[1];if(f===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${u}, ${i}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===o&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${l} + depth * ${u} +\n          depth2 * ${i} + depth3 * ${o} + depth4 + ${ku(n)};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function bu(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${cu().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=cu();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;const o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,o=s[0],i=s[1],u=cu();if(null!=s&&g(n,s))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `;const l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(n[1]/2)}, ${l[0]}, ${l[1]}, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const r=[1,2],s=["b","row","col"];return`\n        ${bu(_u(e,n.slice(1)),t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${Eu(s,r)});\n        }\n      `}const i=cu();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${i.texture2D}(${r}, uv);\n    }\n  `;const u=o[0],l=o[1],c=Math.ceil(n[2]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${u}, ${l}, ${c*Math.ceil(n[1]/2)}, ${c}, b, row, col);\n      return ${i.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=cu();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;const s=e.shapeInfo.logicalShape,o=s.length,i=e.shapeInfo.texShape,u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],l=u[0],c=u[1],d=Math.ceil(s[o-1]/2);let p=d*Math.ceil(s[o-2]/2),h="int b, int row, int col",f=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let e=2;e<o-1;e++)h=`int b${e}, `+h,p*=s[o-e-1],f=`b${e} * ${p} + `+f;return`\n    vec4 ${r}(${h}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const yu="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",wu="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",vu="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Iu="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function ku(e){return`offset${e}`}function Cu(e){const t=e.name,n=m(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function $u(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Su(e,t,n){const{newShape:r,keptDims:a}=k(t),s=t.length,o=e&&3===s&&1===t[0],i=o?t.slice(1):r,u=!e&&s>1&&!g(t,n)&&r.length<s||o;return{useSqueezeShape:u,uniformShape:u?i:t,keptDims:a}}function _u(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Eu(e,t){return t.map((t=>e[t])).join(", ")}function Tu(e,t,n){const r={},a={},s={},o=[];let i,u,l,c=null,d=null;d=e.getUniformLocation(n,"NAN",!1),1===H().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(n,"INFINITY",!1));const p=!1;for(let o=0;o<t.variableNames.length;o++){const i=t.variableNames[o];r[i]=e.getUniformLocation(n,i,p),r[`offset${i}`]=e.getUniformLocation(n,`offset${i}`,p),t.enableShapeUniforms&&(a[`${i}Shape`]=e.getUniformLocation(n,`${i}Shape`,p),s[`${i}TexShape`]=e.getUniformLocation(n,`${i}TexShape`,p))}return t.enableShapeUniforms&&(i=e.getUniformLocation(n,"outShape",p),l=e.getUniformLocation(n,"outShapeStrides",p),u=e.getUniformLocation(n,"outTexShape",p)),t.customUniforms&&t.customUniforms.forEach(((t,r)=>{o[r]=e.getUniformLocation(n,t.name,p)})),{uniformLocations:r,customUniformLocations:o,infLoc:c,nanLoc:d,inShapesLocations:a,inTexShapesLocations:s,outShapeLocation:i,outShapeStridesLocation:l,outTexShapeLocation:u}}function Ru(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,a=t[n],s=a.shape;if(!g(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&a.isUniform)return;const o=e.texShape,i=a.isUniform?null:a.texData.texShape;if(!g(o,i))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${i} must match`)}))}function Nu(e){return H().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class Au{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Fi.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=cu();this.outputShape=e,this.enableShapeUniforms=Nu(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?pu(["r","c","d"],e):du(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class Fu{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Fi.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=cu();this.outputShape=e,this.enableShapeUniforms=Nu(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?pu(["r","c","d"],e):du(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class Ou{constructor(e){this.variableNames=["A"],this.outTexUsage=Oi.DOWNLOAD;const t=cu();this.outputShape=e,this.userCode=`\n      ${fu}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class Du{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Oi.DOWNLOAD;const t=cu();this.outputShape=e,this.userCode=`\n      ${fu}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class Mu{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=cu();this.outputShape=e,this.enableShapeUniforms=Nu(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":hu(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${n.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${n.output} = vec4(${r}, 0., 0., 0.);\n      }\n    `}}class Lu{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=cu();this.outputShape=e,this.enableShapeUniforms=Nu(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let a=0;a<=1;a++){const s=2*t+a;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${s}] = values[0];\n            } else if (offset == 1) {\n              result[${s}] = values[1];\n            } else if (offset == 2) {\n              result[${s}] = values[2];\n            } else {\n              result[${s}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":hu(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}}function Pu(e,t,n,r,a,s){!function(e,t){const n=H().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const o=function(e){return Qi(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),i=e.TEXTURE_2D;return Wi(e,(()=>e.bindTexture(i,o))),Wi(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),Wi(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),Wi(e,(()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST))),Wi(e,(()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===H().getNumber("WEBGL_VERSION")?Wi(e,(()=>e.texImage2D(i,0,r,t,n,0,a,s,null))):Wi(e,(()=>e.texStorage2D(i,1,r,t,n))),Wi(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:o,texShape:[n,t]}}function Bu(e){return e.internalFormatFloat}function Wu(e){return e.internalFormatHalfFloat}function Uu(e){return e.downloadTextureFormat}function Vu(e){return e.internalFormatPackedFloat}function Gu(e){return e.internalFormatPackedHalfFloat}class zu{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=H().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,function(e,t){Ri[e]=t}(t,e)):this.gl=Ai(t);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===H().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=Vi(this.gl,e),su(this.gl,t))this.textureHalfFloatExtension=Vi(this.gl,t);else if(H().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),su(this.gl,r))this.colorBufferHalfFloatExtension=Vi(this.gl,r);else if(H().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",su(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!su(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function(e){return function(e,t){const n=Qi(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return Wi(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),Wi(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(e){return function(e,t){const n=Qi(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return Wi(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),Wi(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(e){return Qi(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=Bi(this.gl,this.textureHalfFloatExtension)}get debug(){return H().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Wi(e,(()=>e.finish())),Wi(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),Wi(e,(()=>e.deleteFramebuffer(this.framebuffer))),Wi(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),Wi(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),Wi(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=Mi(t,n);return Pu(e,a,s,Bu(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=Mi(t,n);return Pu(e,a,s,Wu(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=Mi(t,n);return Pu(e,a,s,Uu(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){Wi(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===H().getNumber("WEBGL_VERSION")?Wi(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):Wi(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===H().getNumber("WEBGL_VERSION")?Wi(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):Wi(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),Wi(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,a,s){let o,i,u;Wi(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(o=new Uint8Array(n*r*4),i=e.UNSIGNED_BYTE,u=e.RGBA):(o=new Float32Array(n*r*4),i=e.FLOAT,u=s.internalFormatPackedFloat),o.set(a),2===H().getNumber("WEBGL_VERSION")?Wi(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,i,o))):Wi(e,(()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,i,o))),Wi(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=Pi(t,n);return Pu(e,a,s,Gu(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=Pi(t,n);return Pu(e,a,s,Vu(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Ki(this.gl,this.framebuffer),this.outputTexture=null),Wi(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[a,s]=Mi(t,n),o=new Uint8Array(t*n*4);return Wi(e,(()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,o))),new Float32Array(o.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return function(e,t,n,r,a,s,o,i){const u=e,l=new Float32Array(function(e,t){const[n,r]=Pi(e,t);return n*r*4}(s,o));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}(this.gl,e,0,0,0,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n,r){const a=e.createBuffer();Wi(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a)));const s=16*t*n;return Wi(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),Wi(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),Wi(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),a}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(H().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return Wi(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=function(e){const t=cu();return function(e,t){const n=Qi(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(Wi(e,(()=>e.shaderSource(n,t))),Wi(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(t));const n=function(e){return Qi(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);return Wi(t,(()=>t.attachShader(n,this.vertexShader))),Wi(t,(()=>t.attachShader(n,e))),function(e,t){if(Wi(e,(()=>e.linkProgram(t))),!H().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n),this.debug&&Hi(t,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=function(e,t,n){return Wi(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),ji(e,t,"clipSpacePos",n,3,20,0)&&ji(e,t,"uv",n,2,20,12)}(t,this.program,this.vertexBuffer)),n}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&Wi(this.gl,(()=>this.gl.deleteProgram(e)))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&Hi(this.gl,this.program),Wi(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return Qi(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Wi(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),Xi(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,a]=Pi(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&Hi(this.gl,this.program),Yi(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),Wi(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Wi(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Vi(this.gl,2===H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await w((()=>this.disposed||this.isQueryAvailable(e,H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in H().platform&&(n=H().platform.setTimeoutCustom.bind(H().platform)),w((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),qi(this.gl,e,this.framebuffer),this.debug&&Yi(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(qi(this.gl,this.outputTexture,this.framebuffer),this.debug&&Yi(this.gl)):Ki(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;qi(r,e,this.framebuffer),this.debug&&Yi(r),this.outputTexture=e,Wi(r,(()=>r.viewport(0,0,t,n))),Wi(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),Wi(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function Hu(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&d("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}function ju(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}function Xu(e){return(t,n,r,a,s)=>{const o=ra(t,n),i=o.length,u=F(o),l=C(s,m(o)),c=t.length,d=n.length,p=F(t),h=F(n),f=ta(t,o),g=ta(n,o);if(f.length+g.length===0)for(let t=0;t<l.length;++t)l[t]=e(r[t%r.length],a[t%a.length]);else for(let t=0;t<l.length;++t){const n=W(t,i,u),s=n.slice(-c);f.forEach((e=>s[e]=0));const o=B(s,c,p),m=n.slice(-d);g.forEach((e=>m[e]=0));const x=B(m,d,h);l[t]=e(r[o],a[x])}return[l,o]}}function qu(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,i=n.makeTensorInfo(r.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",o)},i}function Ku(e,t,n="float32"){if("complex64"===n)return qu({inputs:{real:Ku(e,t,"float32"),imag:Ku(e,t,"float32")},backend:e});const r=L(m(t),n);return e.makeTensorInfo(t,n,r)}function Yu(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function Qu(e,t,n,r){if("int32"===r)return[t,"int32",Int32Array.from(e)];if("bool"===r){const r=$n([0],n),[a,s]=Xu(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[s,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function Zu(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return Yu({inputs:{x:a},backend:n});const e=Ku(n,a.shape,a.dtype),t=Zu({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=qu({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){const e=function(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}({inputs:{input:a},backend:n}),t=Zu({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!S(a.dtype,s)){const e=Yu({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}const o=n.data.get(a.dataId).values,[i,u,l]=Qu(o,a.shape,a.dtype,s);return n.makeTensorInfo(i,u,l)}function Ju(e,t,n,r){return null==n?({inputs:n,backend:a})=>{const{a:s,b:o}=n,i=a;Hu([s,o],e);const u=i.data.get(s.dataId).values,l=i.data.get(o.dataId).values,c="string"===s.dtype?Ei(u):u,d="string"===s.dtype?Ei(l):l,p=r||s.dtype,[h,f]=t(s.shape,o.shape,c,d,p);return i.makeTensorInfo(f,p,h)}:({inputs:e,backend:a})=>{const{a:s,b:o}=e,i=a;if("complex64"===s.dtype||"complex64"===o.dtype){const e=Zu({inputs:{x:s},backend:i,attrs:{dtype:"complex64"}}),t=i.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,u=i.data.get(r.dataId).values,l=i.data.get(a.dataId).values,c=Zu({inputs:{x:o},backend:i,attrs:{dtype:"complex64"}}),d=i.data.get(c.dataId),p=d.complexTensorInfos.real,h=d.complexTensorInfos.imag,f=i.data.get(p.dataId).values,m=i.data.get(h.dataId).values,[g,x,b]=n(s.shape,o.shape,u,l,f,m),y=i.makeTensorInfo(b,"float32",g),w=i.makeTensorInfo(b,"float32",x),v=qu({inputs:{real:y,imag:w},backend:i});return i.disposeIntermediateTensorInfo(e),i.disposeIntermediateTensorInfo(c),i.disposeIntermediateTensorInfo(y),i.disposeIntermediateTensorInfo(w),v}{const e=i.data.get(s.dataId).values,n=i.data.get(o.dataId).values,a=r||s.dtype,[u,l]=t(s.shape,o.shape,e,n,a);return i.makeTensorInfo(l,a,u)}}}function el(e){return(t,n,r,a,s,o)=>{const i=ra(t,n),u=m(i),l=i.length,c=F(i),d=C("float32",u),p=C("float32",u),h=ta(t,i),f=ta(n,i),g=Yo(r,a),x=Yo(s,o),b=t.length,y=F(t),w=n.length,v=F(n);if(h.length+f.length===0)for(let t=0;t<d.length;t++){const n=t%g.length,r=t%x.length,a=e(g[2*n],g[2*n+1],x[2*r],x[2*r+1]);d[t]=a.real,p[t]=a.imag}else for(let t=0;t<d.length;t++){const n=W(t,l,c),r=n.slice(-b);h.forEach((e=>r[e]=0));const a=B(r,b,y),s=n.slice(-w);f.forEach((e=>s[e]=0));const o=B(s,w,v),i=e(g[2*a],g[2*a+1],x[2*o],x[2*o+1]);d[t]=i.real,p[t]=i.imag}return[d,p,i]}}const tl=Xu(((e,t)=>e+t)),nl=el(((e,t,n,r)=>({real:e+n,imag:t+r})));function rl(e,t,n,r,a){const s=m(r),o=L(a,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0)throw new Error("Input x must be non-negative!");r>=a||(o[r]+=s>0?t[n]:1)}return o}function al(e,t,n,r=!1){const a=e.shape[0],s=e.shape[1],o=Br([a,n],t.dtype);for(let i=0;i<a;i++)for(let a=0;a<s;a++){const s=e.get(i,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?o.set(1,i,s):t.size>0?o.set(o.get(i,s)+t.get(i,a),i,s):o.set(o.get(i,s)+1,i,s))}return o}function sl(e){return(t,n,r)=>{const a=C(n,t.length);for(let n=0;n<t.length;++n)a[n]=e(t[n],r);return a}}function ol(e,t,n){return({inputs:r,attrs:a,backend:s})=>{const{x:o}=r;if(Hu(o,e),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const i=s,u=i.data.get(o.dataId).values,l=m(o.shape),c=n||o.dtype,d=$(c,l);for(let e=0;e<l;++e)d[e]=t(u[e],a);return i.makeTensorInfo(o.shape,c,d)}}function il(e,t,n){return({inputs:r,attrs:a,backend:s})=>{const{x:o}=r;if(Hu(o,e),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const i=s,u=i.data.get(o.dataId).values,l=n||o.dtype,c=t(u,l,a);return i.makeTensorInfo(o.shape,l,c)}}Ju(Q,tl,nl);const ul=sl((e=>Math.ceil(e)));function ll(e,t,n,r){const a=$(n,m(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=m(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const s="string"===n?Ei(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[i+t]=s[o++]}r+=e.shape[1]}))}return a}il(ie,ul);const cl=Xu(((e,t)=>e===t?1:0)),dl=(Ju(Ie,cl,null,"bool"),sl((e=>Math.exp(e)))),pl=(il(ke,dl,"float32"),sl((e=>Math.expm1(e)))),hl=(il($e,pl),sl((e=>Math.floor(e))));function fl(e,t,n,r,a,s,o,i,u){const l=Br([r,s],n);for(let n=0;n<r;n++){const r=[];let c=0;for(let t=0;t<a;t++){const s=e[n*a+t];c+=s*o[t],r.push(s)}if(c<0||c>=u/s)throw new Error(`Invalid indices: ${r} does not index into ${i}`);for(let e=0;e<s;e++)l.values[n*s+e]=t.get(...t.indexToLoc(c*s+e))}return l}function ml(e,t,n){const r=Br(n,e.dtype);for(let n=0;n<r.size;++n){const a=r.indexToLoc(n).slice(),s=a[0],o=a[2],i=t.locToIndex([s,o]);a[2]=t.values[i];const u=e.locToIndex(a);0<=u&&u<e.values.length&&(r.values[n]=e.values[u])}return r}il(Ee,hl);const gl=Xu(((e,t)=>e>t?1:0)),xl=(Ju(Fe,gl,null,"bool"),Xu(((e,t)=>e>=t?1:0))),bl=(Ju(Oe,xl,null,"bool"),Xu(((e,t)=>e<t?1:0))),yl=(Ju(Be,bl,null,"bool"),Xu(((e,t)=>e<=t?1:0)));function wl(e,t,n){const r=(t-e)/(n-1),a=L(n,"float32");a[0]=e;for(let e=1;e<a.length;e++)a[e]=a[e-1]+r;return a}Ju(We,yl,null,"bool");const vl=sl((e=>Math.log(e)));function Il(e,t,n,r){const a=C(r,m(n));for(let n=0;n<a.length;++n){const r=n*t;let s=e[r];for(let n=0;n<t;++n){const t=e[r+n];(Number.isNaN(t)||t>s)&&(s=t)}a[n]=s}return a}il(Ue,vl);const kl=Xu(((e,t)=>Math.max(e,t))),Cl=(Ju(Xe,kl),Xu(((e,t)=>Math.min(e,t)))),$l=(Ju(Qe,Cl),Xu(((e,t)=>e*t))),Sl=el(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})));function _l(e,t,n){const r=Cn(-1,n);return $l([],t,r,e,n)}Ju(Je,$l,Sl);const El=Xu(((e,t)=>e!==t?1:0));function Tl(e,t,n,r,a){const s=t.length,o=m(t),i=F(t),u=F(a),l=C(n,m(a));for(let t=0;t<o;++t){const n=W(t,s,i),a=new Array(n.length);for(let e=0;e<a.length;e++)a[e]=n[r[e]];l[B(a,s,u)]=e[t]}return l}function Rl(e,t,n,r){const[a,s]=ws(e,r),o=Kn(t,"int32"),i=L(m(a),o),u=m(s);for(let e=0;e<i.length;++e){const t=e*u;let r=1;for(let e=0;e<u;++e)r*=n[t+e];i[e]=r}return{outVals:i,outShape:a,outDtype:o}}function Nl(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function Al(e,t,n,r,a,s,o,i){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){const a=W(r,t.length,F(t)).join(",");throw new Error(`indices[${a}] = ${e} is not in [0, ${n})`)}}))}(s,o,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const u=r[0],{outSplits:l,valueSlices:c,numValues:d}=function(e,t,n,r){const a=[];let s=0;const o=t.length-1+n.length,i=new Array(o).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],a=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let u=1;for(let e=0;e<t.length-1;++e){u*=t[e];const n=t[e+1];for(let t=1;t<u+1;++t)i[e].push(t*n)}for(let r=0;r<e.length;++r){let o=e[r],u=e[r]+1;for(let e=0;e<n.length;++e){const r=n[e],a=e+t.length-1;if(a>=0){const e=i[a],t=e[e.length-1]-r[o];for(let e=o;e<u;++e)i[a].push(r[e+1]+t)}o=r[o],u=r[u]}u!==o&&(a.push([o,u]),s+=u-o)}return{outSplits:i,valueSlices:a,numValues:s}}(s,o,e,u),p=function(e){const t=[];for(let n=0;n<e.length;++n){const r=$("int32",e[n].length);t.push(r),e[n].forEach(((e,t)=>r[t]=e))}return t}(l),h=function(e,t,n,r,a){const s=t.slice();s[0]=a;const o=$(n,m(s)),i=e.length;return function(e,t,n,r,a,s){const o=Nl(t,2)[1],i=Nl(s,2)[1];let u=0;for(const t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<r;++t)a[u*i+t]=e[n*o+t];++u}}(e,t,r,0===i?0:i/t[0],o,s),[o,s]}(n,r,a,c,d);return[p,h[0],h[1]]}Ju(tt,El,null,"bool");var Fl=To;class Ol{constructor(e,t,n,r,a,s,o,i,u,l){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=o,this.rowPartitionValues=i,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=No(l),this.raggedRank=Ao(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Fl.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Fl.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Fl.VALUE_ROWIDS:return Ol.getMaxWidthValueRowID(t);case Fl.ROW_SPLITS:return Ol.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Fl[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],a=0;for(let s=1;s<t;++s){const t=e[s];t!==r&&(r=t,a=Math.max(s-n,a),n=s)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Ml(e,n)}calculateOutputSize(e){const t=this.valuesShape;Fo(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=Ro(this.raggedRank,n,t);r[0]<0&&(r[0]=e);for(let e=1;e<=this.raggedRank;++e)r[e]<0&&(r[e]=this.getMaxWidth(e));return r}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),a=[];let s=0;for(let e=0;e<r;++e,s+=t)a.push(s);for(let t=r;t<e;++t)a.push(-1);return d(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){const a=e.length,s=[];for(let o=0;o<a-1;++o){const a=e[o+1]-e[o];let i=Math.min(r,a),u=t[o];-1===u&&(i=0);for(let e=0;e<i;++e)s.push(u),u+=n;for(let e=0;e<a-i;++e)s.push(-1)}if(a>0&&s.length!==e[a-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,r){const a=e.length,s=[];if(0===a)return[];let o=0,i=e[0];if(i>=t.length)throw new Error(`Got currentValueRowId=${i}, which is not less than ${t.length}`);let u=t[i];s.push(u);for(let l=1;l<a;++l){const a=e[l];if(a===i)u>=0&&(++o,o<r?u+=n:u=-1);else{if(o=0,i=a,a>=t.length)throw new Error(`Got nextValueRowId=${a} which is not less than ${t.length}`);u=t[a]}s.push(u)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,r){const a=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case Fl.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case Fl.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error(`Unsupported partition type: ${Fl[s]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Fl.FIRST_DIM_SIZE:return e[0];case Fl.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Fl.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Fl[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];const r=Ml(t,!1),a=$(this.valuesDType,m(r));if(n[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)s=this.calculateOutputIndex(e-1,s,n[e],t[e]);this.setOutput(this.raggedRank,s,a,r)}return[r,a]}setOutput(e,t,n,r){if(0===n.length)return;const a=this.values,s=n;let o=r.slice();o=o.slice(e+1);const i=m(o),u=t.length;let l=this.defaultValue;if(l.length!==i&&1!==l.length){const e=this.defaultValueShape;Ds((()=>{const t=$a(l,e),n=Sa(t,o);l=n.dataSync()}))}let c=0,d=0,p=0;for(let e=0;e<=u;++e){let r=e<u?t[e]:-1;if(r!==p){if(d<p){const e=a.subarray(c*i);Dl(s.subarray(d*i),e,(p-d)*i)}if(e>=u){const e=n.length;r=Math.floor(e/i)}if(r>p)if(1===this.defaultValue.length)s.subarray(p*i,r*i).fill(this.defaultValue[0]),p=r;else for(;r>p;)Dl(s.slice(p*i),l,i),++p;r<0?(c=e+1,d=p):(c=e,d=p,p=d+1)}else++p}}}function Dl(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function Ml(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function Ll(e,t,n,r,a,s,o,i,u,l){return new Ol(e,t,n,r,a,s,o,i,u,l).compute()}function Pl(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return L(0,r);const a=L(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),a[0]=e;for(let e=1;e<a.length;e++)a[e]=a[e-1]+n;return a}const Bl=sl((e=>1/Math.sqrt(e)));function Wl(e,t,n,r,a,s,o,i,u,l){const c=[r/a,a],d=e.values,p=t.values;if(0===r)return Br(n,t.dtype);const h=Br(c,t.dtype);"string"==typeof u||"number"==typeof u?h.values.fill(u):"boolean"==typeof u&&h.values.fill(+u);for(let e=0;e<s;e++){const s=[];let u=0;for(let t=0;t<o;t++){const n=d[e*o+t];s.push(n),u+=n*i[t]}if(u<0||u>=r/a)throw new Error(`Invalid indices: ${s} does not index into ${n}`);for(let n=0;n<a;n++)l?h.values[u*a+n]+=p[e*a+n]:h.values[u*a+n]=0===t.rank?p[0]:p[e*a+n]}return h}il(vt,Bl);const Ul=sl((e=>1/(1+Math.exp(-e))));function Vl(e,t,n,r,a){const s=wa(r,t,n),o=m(n),i=F(r);if(s){const n=va(t,i);return"string"===a?e.slice(n,n+o):e.subarray(n,n+o)}const u=Br(r,a,"string"===a?Ei(e):e),l=Br(n,a);for(let e=0;e<l.size;++e){const n=l.indexToLoc(e),r=n.map(((e,n)=>e+t[n]));l.set(u.get(...r),...n)}return"string"===a?Ti(l.values):l.values}function Gl(e,t,n,r,a,s,o){const i=t[0],u=s[0],l=new Array(u),c=new Array(i),d=t[1];if(0===u){if(0!==i)throw new Error(hi(i));return[$(n,0),[0,d],$(a,0),l,c]}let p=!0,h=0;const f=new Array(u).fill(0);for(let t=0;t<i;++t){const n=e[t*d];if(n<0)throw new Error(fi(t,n));if(n>=u)throw new Error(mi(t,n,u));++f[n],p=p&&n>=h,h=n}let m=!0;for(let e=0;e<u;++e){const t=0===f[e];l[e]=t,m=m&&!t,f[e]=Math.max(f[e],1),e>0&&(f[e]+=f[e-1])}if(m&&p){const t=e,n=r;for(let e=0;e<i;++e)c[e]=e;return[t,[i,d],n,l,c]}{const t=f[u-1],s=$(n,t*d),p=$(a,t),h=new Array(u).fill(0);for(let t=0;t<i;++t){const n=e[t*d],a=h[n],o=(0===n?0:f[n-1])+a;h[n]++;for(let n=0;n<d;++n)s[o*d+n]=e[t*d+n];p[o]=r[t],c[t]=o}for(let e=0;e<u;++e)if(0===h[e]){const t=0===e?0:f[e-1];s[t*d+0]=e;for(let e=1;e<d;++e)s[t*d+e]=0;p[t]=o}return[s,[t,d],p,l,c]}}function zl(e,t,n,r,a){const s=m(r),o=t[0],i=a.length,u=[];let l=1,c=-1;for(let e=0;e<i;++e){const t=a[e];if(-1===t){if(-1!==c)throw new Error(gi(c,e));c=e,u.push(1)}else{if(t<0)throw new Error(xi(e,t));l*=t,u.push(t)}}if(-1!==c){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(s/l);if(l*e!==s)throw new Error(yi(r,u));u[c]=e}if(m(u)!==s)throw new Error(wi(r,u));const d=r.length,p=[];if(d>0){p[d-1]=1;for(let e=d-2;e>=0;--e)p[e]=p[e+1]*r[e+1]}const h=[];if(i>0){h[i-1]=1;for(let e=i-2;e>=0;--e)h[e]=h[e+1]*u[e+1]}const f=$(n,o*i);for(let t=0;t<o;++t){let n=0;for(let r=0;r<d;++r)n+=e[t*d+r]*p[r];for(let e=0;e<i;++e)f[t*i+e]=Math.trunc(n/h[e]),n%=h[e]}return[f,[o,i],u]}function Hl(e,t,n,r,a,s=!1,o=0){const i=r.length,u=[t[0],e.length/t[0]],l=u[1],c=i>0?a[i-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const d=t.slice();d[0]=c;const p=$(n,d.reduce(((e,t)=>e*t),1));if(0===i)return c>0&&p.fill(o),[p,d];if(c<=0)throw new Error("segment ids must be >= 0");let h=0,f=1,m=0,g=a[h];for(;;){let t=0;if(f<i){if(t=a[f],g===t){++f;continue}if(g>=t)throw new Error("segment ids are not increasing")}if(g<0||g>=c)throw new Error(ki(g,c));g>m&&p.fill(o,m*l,g*l);for(let t=h;t<f;++t){const n=r[t];if(n<0||n>=u[0])throw new Error(Ci(t,r[t],u[0]));for(let t=0;t<l;t++)p[g*l+t]+=e[n*l+t]}if(s)for(let e=0;e<l;e++)p[g*l+e]/=f-h;if(h=f,++f,m=g+1,g=t,f>i)break}return m<c&&p.fill(o,m*l,c*l),[p,d]}ol($t,(e=>1/(1+Math.exp(-e))));const jl=sl((e=>Math.sqrt(e))),Xl=(ol(St,(e=>Math.sqrt(e))),Xu(((e,t)=>{const n=e-t;return n*n})));function ql(e,t,n,r){const a=Br(e,t.dtype);for(let e=0;e<a.size;e++){const s=a.indexToLoc(e),o=new Array(s.length);for(let e=0;e<o.length;e++)o[e]=s[e]*n[e]+r[e];a.set(t.get(...o),...s)}return a}Ju(Dt,Xl);class Kl{constructor(e,t,n,r,a,s){this.separator=_n(e),this.nGramWidths=t,this.leftPad=_n(n),this.rightPad=_n(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let o=0;o<a;++o){const i=this.getPadWidth(s),u=Math.max(0,i-o),l=Math.max(0,i-(a-(o+1))),c=s-(u+l),d=t+(u>0?0:o-i);let p=0;p+=u*this.leftPad.length;for(let t=0;t<c;++t)p+=e[d+t].length;p+=l*this.rightPad.length,p+=(u+l+c-1)*this.separator.length,n[r+o]=new Uint8Array(p);const h=n[r+o];let f=0;const m=e=>e.forEach((e=>h[f++]=e));for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[d+t]),m(this.separator);if(c>0){m(e[d+c-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const a=r-1,s=$("int32",r);if(0===n||0===r){const e=new Array(n);for(let e=0;e<=a;++e)s[e]=0;return[e,s]}s[0]=0;for(let e=1;e<=a;++e){const n=t[e]-t[e-1];let r=0;this.nGramWidths.forEach((e=>{r+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===r&&(r=1),s[e]=s[e-1]+r}const o=new Array(s[a]);for(let n=0;n<a;++n){const r=t[n];let a=s[n];if(this.nGramWidths.forEach((s=>{const i=t[n+1]-t[n],u=this.getNumNGrams(i,s);this.createNGrams(e,r,o,a,u,s),a+=u})),this.preserveShort&&a===s[n]){const s=t[n+1]-t[n];if(0===s)continue;const i=s+2*this.padWidth,u=1;this.createNGrams(e,r,o,a,u,i)}}return[o,s]}}function Yl(e,t,n,r,a,s,o,i){return new Kl(n,r,a,s,o,i).compute(e,t)}function Ql(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const a=t[0];let s=e.indexOf(a);for(;-1!==s;){const t=e.subarray(0,s);n&&0===t.length||r.push(t),s=(e=e.subarray(s+1)).indexOf(a)}return void(n&&0===e.length||r.push(e))}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){const t=e.subarray(a,s);n&&0===t.length||r.push(t),a=s+1}}function Zl(e,t,n){const r=e.length,a=[];let s=0,o=0;const i=new Array(r);for(let u=0;u<r;++u){const r=a.length;Ql(e[u],t,n,a);const l=a.length-r;i[u]=l,s+=l,o=Math.max(o,l)}const u=$("int32",2*s),l=new Array(s),c=[r,o];let d=0;for(let e=0;e<r;++e)for(let t=0;t<i[e];++t)u[2*d]=e,u[2*d+1]=t,l[d]=a[d],++d;return[u,l,c]}function Jl(e,t){const n=$("int32",e.length);for(let r=0;r<e.length;++r)n[r]=kn(e[r]).modulo(t).getLowBitsUnsigned();return n}const ec=Xu(((e,t)=>e-t)),tc=el(((e,t,n,r)=>({real:e-n,imag:t-r})));function nc(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const r=Br(n,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),a=new Array(e.rank);for(let t=0;t<a.length;t++)a[t]=n[t]%e.shape[t];const s=e.locToIndex(a);r.values[t]=e.values[s]}return r}Ju(Ut,ec,tc);const rc=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function ac(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){const a=r-n+1,s=t-n+1,o=Math.log(a),i=.5*Math.exp(2*o/3),u=.5*Math.sqrt(o*i*(a-i)/a)*Math.sign(s-a/2);ac(e,t,Math.max(n,Math.floor(t-s*i/a+u)),Math.min(r,Math.floor(t+(a-s)*i/a+u)))}const a=e[t];let s=n,o=r;for(c(e,n,t),rc(e[r],a)>0&&c(e,n,r);s<o;){for(c(e,s,o),s++,o--;rc(e[s],a)<0;)s+=1;for(;rc(e[o],a)>0;)o-=1}0===rc(e[n],a)?c(e,n,o):(o+=1,c(e,o,r)),o<=t&&(n=o+1),t<=o&&(r=o-1)}}function sc(e,t,n,r,a){const s=t[t.length-1],[o,i]=[e.length/s,s],u=C(n,o*r),l=C("int32",o*r);for(let t=0;t<o;t++){const n=t*i,s=e.subarray(n,n+i);let o=new Array(s.length);s.forEach(((e,t)=>o[t]={value:e,index:t})),r<o.length&&(ac(o,r),o=o.slice(0,r)),a&&o.sort(rc);const c=t*r,d=u.subarray(c,c+r),p=l.subarray(c,c+r);for(let e=0;e<r;e++)d[e]=o[e].value,p[e]=o[e].index}const c=t.slice();return c[c.length-1]=r,[Br(c,n,u),Br(c,"int32",l)]}function oc(e,t,n,r){const a=I(t,n)[0],s=[1,n[0],1];for(let e=0;e<a;e++)s[0]*=n[e];s[1]=n[a];for(let e=a+1;e<n.length;e++)s[2]*=n[e];const o={},i=new Int32Array(n[a]),u=new Ln(s,r,e),l=[],c=1===s[0]&&1===s[2];for(let t=0;t<n[a];t++){let n;if(c)n=e[t].toString();else{const e=[];for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)e.push(u.get(n,t,r));n=e.join(",")}if(void 0!==o[n])i[t]=o[n];else{const e=Object.keys(o).length;o[n]=e,i[t]=e,l.push(t)}}const d=s.slice();d[1]=Object.keys(o).length;const p=new Ln(d,r);l.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)p.set(u.get(n,e,r),n,t,r)}));const h=n.slice();return h[a]=d[1],{outputValues:p.values,outputShape:h,indices:i}}const{addImpl:ic,bincountImpl:uc,bincountReduceImpl:lc,castImpl:cc,ceilImpl:dc,concatImpl:pc,equalImpl:hc,expImpl:fc,expm1Impl:mc,floorImpl:gc,gatherNdImpl:xc,gatherV2Impl:bc,greaterImpl:yc,greaterEqualImpl:wc,lessImpl:vc,lessEqualImpl:Ic,linSpaceImpl:kc,logImpl:Cc,maxImpl:$c,maximumImpl:Sc,minimumImpl:_c,multiplyImpl:Ec,negImpl:Tc,notEqualImpl:Rc,prodImpl:Nc,raggedGatherImpl:Ac,raggedTensorToTensorImpl:Fc,rangeImpl:Oc,rsqrtImpl:Dc,scatterImpl:Mc,sigmoidImpl:Lc,simpleAbsImpl:Pc,sliceImpl:Bc,sparseFillEmptyRowsImpl:Wc,sparseReshapeImpl:Uc,sparseSegmentReductionImpl:Vc,sqrtImpl:Gc,stridedSliceImpl:zc,stringNGramsImpl:Hc,stringSplitImpl:jc,stringToHashBucketFastImpl:Xc,subImpl:qc,tileImpl:Kc,topKImpl:Yc,transposeImpl:Qc,uniqueImpl:Zc}=a;function Jc(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function ed(e,t){return 1===t?[e]:Jc(e,t)}class td{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Nu(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=ed("rc",this.rank),t=$u(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class nd{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Nu(this.outputShape.length);let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var r,a;this.userCode=`\n      ${r=t,a=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${a?function(e,t,n="index"){const r=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),a=new Array(n-1);a[n-2]=r[n-1];for(let e=n-3;e>=0;--e)a[e]=`(${a[e+1]} * ${r[e+1]})`;return a}(e.map(((e,t)=>t)),t);return r.map(((t,a)=>`int ${e[a]} = ${n} / ${r[a]}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${r[a]}`:`index -= ${e[a]} * ${r[a]}`};`)).join("")}(["r","c","d"],"inputShape"):du(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":hu(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class rd{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const r=sd(t,n),a=od(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const s=ad(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const e=this.freeTextures[a].shift();return this.usedTextures[a].push(e),e}let o;return r===Di.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Di.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Di.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Di.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Di.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(o),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),o}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const a=sd(n,r),s=od(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);const o=ad(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),i=H().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const u=this.usedTextures[s],l=u.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(l,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function ad(e,t,n,r,a){const s=function(e,t){switch(e){case Di.PACKED_2X2_FLOAT32:return Vu(t);case Di.PACKED_2X2_FLOAT16:return Gu(t);case Di.UNPACKED_FLOAT32:return Bu(t);case Di.UNPACKED_FLOAT16:return Wu(t);case Di.PACKED_4X1_UNSIGNED_BYTE:return Uu(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let o;if(a){const[t,n]=Pi(e[0],e[1]);o=t*n}else{const[t,n]=Mi(e[0],e[1]);o=t*n}const i=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,s);return o*i}function sd(e,t){if(e===Oi.UPLOAD)return Di.PACKED_2X2_FLOAT32;if(e===Oi.RENDER||null==e)return function(e){return H().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?Di.PACKED_2X2_FLOAT32:Di.UNPACKED_FLOAT32:e?Di.PACKED_2X2_FLOAT16:Di.UNPACKED_FLOAT16}(t);if(e===Oi.DOWNLOAD||e===Oi.PIXELS)return Di.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function od(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class id{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Nu(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const ud="if (isnan(x)) return x;",ld="return abs(x);",cd=ud+"\n  return (x < 0.0) ? 0.0 : x;\n",dd=ud+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",pd="return x;";class hd{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Nu(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class fd{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Nu(this.outputShape.length);const t=e.length,n=ed("rc",t),r=$u(t),a=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),o=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}}const md={},gd=H().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class xd extends o{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!H().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof zu)t=e;else{const n=Ai(H().getNumber("WEBGL_VERSION"),e);t=new zu(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=Ai(H().getNumber("WEBGL_VERSION"));t=new zu(e),this.binaryCache=((n=H().getNumber("WEBGL_VERSION"))in md||(md[n]={}),md[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new rd(this.gpgpu),this.numMBBeforeWarning=null==H().global.screen?1024:H().global.screen.height*H().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new s(this,Os())}nextDataId(){return xd.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((H().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||H().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:Oi.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,r,a){if(H().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:Oi.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:o,isPacked:i}=t;if(null!=s){let t;t=i?new hd(o,pd):new id(o,pd);const n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const u=null!=this.activeTimers;let l,c;return u&&(l=Sn()),c="complex64"===r?Yo(this.readSync(a.real.dataId),this.readSync(a.imag.dataId)):this.getValuesFromTexture(e),u&&(this.downloadWaitMs+=Sn()-l),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:o,isPacked:i}=t;if(null!=a){let t;t=i?new hd(r,pd):new id(r,pd);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(H().getBool("DEBUG")&&!H().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===H().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u,l,c=null;if("complex64"!==s&&H().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const t=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...Li(r))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const e=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]);l=Yo(e[0],e[1])}else if(null==c)l=this.getValuesFromTexture(e);else{const e=m(r);l=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=u&&this.disposeIntermediateTensorInfo(u),null!=c){const e=this.gpgpu.gl;Wi(e,(()=>e.deleteBuffer(c)))}const d=this.convertAndCacheOnCPU(e,l),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Os().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){const n=this.texData.get(e),{values:r,shape:a,slice:s,dtype:o,isPacked:i,texture:u}=n;if("complex64"===o)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=i?new hd(a,pd):new id(a,pd);const r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:o}],o),s=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),s}if(null==u)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,t.customTexShape),c=Os().makeTensorFromTensorInfo(l),d=this.texData.get(l.dataId);return Object.assign({tensorRef:c},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>En(e)));return Br(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return Br(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!Ui(n)){if(H().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=m(t);if(H().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...Li(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}const s=H().getBool("WEBGL_PACK")&&!0===r,o=s?eu(t):t,i=s?new Du(o):new Ou(o),u=this.runWebGLProgram(i,[{shape:o,dtype:n,dataId:e}],"float32"),l=this.texData.get(u.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(u),c}timerAvailable(){return H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const a=f(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=f(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(a);o.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),o.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Sn(),endMs:null}}endTimer(e){return H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Sn(),e)}async getQueryTime(e){if(H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:o}=this.texData.get(e),i=o&&o.origDataId||e,u=this.dataRefCount.get(i);u>1?this.dataRefCount.set(i,u-1):(this.dataRefCount.delete(i),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,s)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=gd){return H().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&m(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){en("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return function(e,t){const n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);const r=Br(e,"int32"),a=Br([n.length,e.length],"int32");for(let t=0;t<n.length;t++){const s=r.indexToLoc(n[t]),o=t*e.length;a.values.set(s,o)}return a.toTensor()}(e.shape,t)}packedUnaryOp(e,t,n){const r=new hd(e.shape,t),a=this.compileAndRun(r,[e],n);return Os().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=Pc(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(H().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,ld,e.dtype);const t=new id(e.shape,ld),n=this.compileAndRun(t,[e]);return Os().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&T(n[0])){const a=n.map((e=>_n(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return Os().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new fd(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new td(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[Zi(e.shape),...Ji(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[Zi(t),...Ji(t)],s=new nd(a,n),o=[n],i=this.runWebGLProgram(s,[r],e.dtype,o,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:a,dtype:s}=n;null!=t&&d(m(a)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."));const o=eu(a);let i;i=r?new Fu(o):new Au(o);const u=[null!=t?t:Li(o)];return{dtype:s,shape:a,dataId:this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:e}],s,u,!0,t).dataId}}runWebGLProgram(e,t,n,r,a=!1,s){const o=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(o.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===Fi.DENSE){const t=null!=s?s:Li(e.outputShape);i.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===m(o.shape))return i.values=C(o.dtype,0),o;const u=[],l=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&m(t.shape)<=H().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),u.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!nu(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),u.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(o.dataId);const c={shape:o.shape,texData:i,isUniform:!1},d=function(e,t,n){let r="";t.concat(n).forEach((t=>{const a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const s=t.texData.texShape,{useSqueezeShape:o,uniformShape:i,keptDims:u}=Su(e.packedInputs,t.shape,s);let l="",c="",d="";if(1===i.length&&e.packedInputs){const e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];l=`${e[0]>1}_${e[1]>1}`}else if(2!==i.length||e.packedInputs){if(i.length>2&&!e.packedInputs){const e=F(i);d=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else c=`${i[0]>1}_${i[1]>1}`;const p=t.shape.length,h=2===i.length&&g(t.shape,s),f=1===m(t.shape),x=ta(t.shape,n.shape),b=!e.packedInputs&&p===n.shape.length&&g(s,n.texData.texShape),y=e.packedInputs||i.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${p}_${b}_${o?u:""}_${i.length}_${f}_${x}_${h}_${l}_${c}_${d}_${y}_${a}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));const a=e.userCode;let s=e.constructor.name;return s+="_"+r+"_"+a+`${H().getNumber("WEBGL_VERSION")}`,s}(e,l,c),p=this.getAndSaveBinary(d,(()=>function(e,t,n,r){const a=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),s=a.map((e=>e.shapeInfo)),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},i=gu(a,o,t),u=function(e,t){const n=Qi(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(Wi(e,(()=>e.shaderSource(n,t))),Wi(e,(()=>e.compileShader(n))),H().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw zi(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,i),l=e.createProgram(u);return H().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:i,webGLProgram:l,inShapeInfos:s,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:u,source:i,webGLProgram:l,inShapeInfos:s,outShapeInfo:o},Tu(e,t,l))}(this.gpgpu,e,l,c))),h=null!=this.activeTimers;let f;h&&(f=this.startTimer()),H().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,a){t.program.enableShapeUniforms||(Ru(t.inShapeInfos,n),Ru([t.outShapeInfo],[r]));const s=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):e.setOutputMatrixTexture(s.texture,o[0],o[1]),e.setProgram(t.webGLProgram),1===H().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach(((n,r)=>{const a=t.program.variableNames[r],s=t.uniformLocations[a],o=t.uniformLocations[`offset${a}`],i=t.inShapesLocations[`${a}Shape`],u=t.inTexShapesLocations[`${a}TexShape`];if(i){const{uniformShape:r}=Su(t.program.packedInputs,n.shape,n.texData.texShape);switch(r.length){case 1:e.gl.uniform1iv(i,new Int32Array(r));break;case 2:e.gl.uniform2iv(i,new Int32Array(r));break;case 3:e.gl.uniform3iv(i,new Int32Array(r));break;case 4:e.gl.uniform4iv(i,new Int32Array(r))}}if(u&&e.gl.uniform2i(u,n.texData.texShape[0],n.texData.texShape[1]),null!=s)if(n.isUniform)if(m(n.shape)<2)e.gl.uniform1f(s,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=n.texData.slice&&null!=o&&e.gl.uniform1i(o,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture.texture,s,r)}));const i=t.outShapeLocation;if(i)switch(r.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=F(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a&&t.program.customUniforms.forEach(((n,r)=>{const s=t.customUniformLocations[r],o=a[r];if("float"===n.type)e.gl.uniform1fv(s,o);else if("vec2"===n.type)e.gl.uniform2fv(s,o);else if("vec3"===n.type)e.gl.uniform3fv(s,o);else if("vec4"===n.type)e.gl.uniform4fv(s,o);else if("int"===n.type)e.gl.uniform1iv(s,o);else if("ivec2"===n.type)e.gl.uniform2iv(s,o);else if("ivec3"===n.type)e.gl.uniform3iv(s,o);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(s,o)}})),e.executeProgram()}(this.gpgpu,p,l,c,r),u.forEach((e=>this.disposeIntermediateTensorInfo(e))),h&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const x=H().get("WEBGL_FLUSH_THRESHOLD");if(x>0){const e=Sn();e-this.lastGlFlushTime>x&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!H().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===a){const e=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),e}return o}compileAndRun(e,t,n,r,a=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(H().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Ds((()=>{if(!H().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=H().getBool("DEBUG");H().set("DEBUG",!1);const t=this.abs(Ea(1e-8)).dataSync()[0];if(H().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:s,usage:o,isPacked:i}=t;if(null!=s)return;const u=null!=this.activeTimers;let c;u&&(c=Sn());let d=t.texShape;if(null==d&&(d=function(e,t=!1){let n=H().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=H().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&H().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?l(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=k(e);e=t.newShape}let a=m(e),s=null;e.length<=1&&a<=n?s=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?s=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);const o=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||o)if(t){const t=Zi(e);let n=2,r=2;e.length&&([n,r]=Ji(e)),a=t*(n/2)*(r/2),s=b(a).map((e=>2*e))}else s=b(a);return s}(n,i),t.texShape=d),null!=a){const e=eu(n);let s,o=d[1],l=d[0];const p=a instanceof Uint8Array||a instanceof Uint8ClampedArray;!i&&p||([o,l]=Pi(d[0],d[1])),s=i?new Lu(e,p):new Mu(e,p);const h=p?[l,o]:d,f=this.makeTensorInfo(h,r),m=this.texData.get(f.dataId);m.usage=p?Oi.PIXELS:Oi.UPLOAD,m.texShape=h,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),o,l,a);const g=[[l,o]],x=!0,b=this.runWebGLProgram(s,[f],r,g,x),y=this.texData.get(b.dataId);t.texShape=y.texShape,t.isPacked=y.isPacked,t.usage=y.usage,H().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=y.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),u&&(this.uploadWaitMs+=Sn()-c)}else{const e=this.acquireTexture(d,o,r,i);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*E(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await new Promise((e=>to((()=>e())))),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw zi(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,inShapesLocations:s,inTexShapesLocations:o,outShapeLocation:i,outShapeStridesLocation:u,outTexShapeLocation:l}=Tu(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.inShapesLocations=s,e.inTexShapesLocations=o,e.outShapeLocation=i,e.outShapeStridesLocation=u,e.outTexShapeLocation=l}}}xd.nextDataId=0,ir()&&Ms("webgl",(()=>new xd),2);const bd="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class yd{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=ra(t,n),this.enableShapeUniforms=Nu(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const wd="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class vd{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ra(t,n);const a=this.outputShape.length;this.enableShapeUniforms=Nu(a);let s="";if(r)if(0===a||1===m(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(s=`\n          ${$u(a)} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=ed("coords",a);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}}function Id(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const kd={kernelName:De,backendName:"webgl",kernelFunc:Id};function Cd(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),o=n.texData.get(s.dataId),i=Id({inputs:{x:r},backend:n}),u=Id({inputs:{x:a},backend:n});return o.complexTensorInfos={real:i,imag:u},s}const $d={kernelName:le,backendName:"webgl",kernelFunc:Cd},Sd="return (a < 0.) ? b * a : a;",_d="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",Ed={kernelName:Pe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,o=n.makeTensorInfo([],"float32",Cn(s,"float32")),i=H().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new vd(_d,a.shape,o.shape):new yd(Sd,a.shape,o.shape),u=n.runWebGLProgram(i,[a,o],"float32");return n.disposeIntermediateTensorInfo(o),u}},Td="return (a < 0.) ? b * a : a;",Rd="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",Nd={kernelName:ct,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=H().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new vd(Rd,r.shape,a.shape):new yd(Td,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}},Ad="if (isnan(x)) return x;";function Fd({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:s})=>{const{x:o}=a,i=s,u=r||o.dtype;if(i.shouldExecuteOnCPU([o])&&null!=n){const e=i.texData.get(o.dataId),t=n(e.values,u);return i.makeTensorInfo(o.shape,u,t)}let l;return l=H().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new hd(o.shape,t):new id(o.shape,e),i.runWebGLProgram(l,[o],u)}}function Od({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:s}){return({inputs:o,backend:i})=>{const{a:u,b:l}=o,c=i;if(r&&"complex64"===u.dtype){const t=c.texData.get(u.dataId),n=c.texData.get(l.dataId),[r,a]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,a={dataId:n.dataId,dtype:n.dtype,shape:u.shape},s={dataId:r.dataId,dtype:r.dtype,shape:l.shape},o=new yd(e,u.shape,l.shape);return c.runWebGLProgram(o,[a,s],Kn(n.dtype,r.dtype))})),s=Cd({inputs:{real:r,imag:a},backend:c});return c.disposeIntermediateTensorInfo(r),c.disposeIntermediateTensorInfo(a),s}const d=s||Kn(u.dtype,l.dtype);if(("string"===u.dtype||"string"===l.dtype||c.shouldExecuteOnCPU([u,l]))&&null!=a){const e=c.texData.get(u.dataId).values,t=c.texData.get(l.dataId).values,n="string"===u.dtype?Ei(e):e,r="string"===u.dtype?Ei(t):t,[s,o]=a(u.shape,l.shape,n,r,d),i=c.makeTensorInfo(o,d);return c.texData.get(i.dataId).values=s,i}let p;return p=H().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new vd(t,u.shape,l.shape,n):new yd(e,u.shape,l.shape),c.runWebGLProgram(p,[u,l],d)}}function Dd(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":cd;if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":dd;if("prelu"===e)return t?Rd:Td;if("leakyrelu"===e)return t?_d:Sd;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class Md{constructor(e,t,n,r=!1,a=!1,s=!1,o=null,i=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=Nu(this.outputShape.length);const l=r?e[1]:e[2],c=Math.ceil(l/2),d=r?"i * 2, rc.y":"rc.y, i * 2",p=a?"rc.z, i * 2":"i * 2, rc.z",h=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";o&&(m=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${o}\n        }`:`vec4 activation(vec4 x) {\n          ${o}\n        }`,g="result = activation(result);");const x=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let b="rc.x",y="rc.x";e[0]<t[0]?b=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(y=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${c}; i++) {\n          int batchA = ${b};\n          int batchB = ${y};\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${f[0]});\n          result += (${h[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${x}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}class Ld{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ra(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const Pd="return a * b;";function Bd(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,s=Kn(r.dtype,a.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),s=new Ld("return areal * breal - aimag * bimag;",r.shape,a.shape),o=new Ld("return areal * bimag + aimag * breal;",r.shape,a.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:a.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:a.shape}],u=n.runWebGLProgram(s,i,"float32"),l=n.runWebGLProgram(o,i,"float32"),c=Cd({inputs:{real:u,imag:l},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),c}if(n.shouldExecuteOnCPU([r,a])){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),[o,i]=Ec(r.shape,a.shape,e.values,t.values,s),u=n.makeTensorInfo(i,s);return n.texData.get(u.dataId).values=o,u}let o;return o=H().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new vd(Pd,r.shape,a.shape):new yd(Pd,r.shape,a.shape),n.runWebGLProgram(o,[r,a],s)}const Wd={kernelName:Je,backendName:"webgl",kernelFunc:Bd};function Ud(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,o=n,i=m(a.shape),u=v(s,i),l=m(u);d(i===l,(()=>`The new shape (${u}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`));const c=o.texData.get(a.dataId);return!c.isPacked||nu(a.shape,u)||null!==c.texture&&nu(c.shape,u)?(o.incRef(a.dataId),{dataId:a.dataId,shape:u,dtype:a.dtype}):function(e,t,n){const r=[Zi(e.shape),...Ji(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[Zi(t),...Ji(t)],o=new nd(s,r),i=[r],u=n.runWebGLProgram(o,[a],e.dtype,i,!0);return{dataId:u.dataId,shape:t,dtype:u.dtype}}(a,u,o)}const Vd={kernelName:mt,backendName:"webgl",kernelFunc:Ud};class Gd{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];const o=4*Math.floor(n/4),i=n%4;let u="sumValue += dot(values, ones);";if(null!=t){const e=1/t;u=`sumValue += dot(values * ${x(e)?e.toPrecision(2):e}, ones);`}let l="";a%n>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===i}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===i}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===i}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class zd{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let o="0.0",i="";"prod"===t?o="1.0":"min"===t?(o="1.0 / 1e-20",i="min"):"max"===t&&(o="-1.0 / 1e-20",i="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const l=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${i}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${i}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,p="vec4";"all"===t?(o="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===t&&(o="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let h="";a%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${u});\n      }\n    `}}function Hd(e,t,n,r){const a=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=Do(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let s=e;for(let o=0;o<a.length;o++){const{inSize:i,windowSize:u,outSize:l}=a[o];let c,d;c="mean"===n?0===o?new Gd({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l},i):new Gd({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l}):new zd({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l},n),d=s,s=r.runWebGLProgram(c,[s],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return s}class jd{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const r=$u(this.rank),a=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}}class Xd{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=$u(this.rank),a=Jc("rc",this.rank),s=new Array(this.rank);for(let e=0;e<t.length;e++)s[t[e]]=a[e];const o=`vec2(${s.slice(-2).join()})`,i=`++${a[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${s.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${i}) {\n        result[1] = ${u};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${i}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function qd(e,t,n){const r=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Xd(e.shape,t):new jd(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function Kd(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r;return function(e,t,n,r){const a=t,s=e.shape.length,o=I(a,e.shape);let i=o;const u=ks(i,s),l=null!=u;let c=e;l&&(c=qd(e,u,r),i=$s(i.length,s)),Is("sum",i,s);const[d,p]=ws(c.shape,i);let h=d;n&&(h=vs(d,o));const f=m(p),g=Ud({inputs:{x:c},attrs:{shape:[m(e.shape)/f,f]},backend:r}),x=Hd(g,Yn(e.dtype),"sum",r),b=Ud({inputs:{x},attrs:{shape:h},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(x),l&&r.disposeIntermediateTensorInfo(c),b}(a,s,o,n)}const Yd={kernelName:_t,backendName:"webgl",kernelFunc:Kd};function Qd(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:s}=r,o=n,i=a.shape.length,u=new Array(i);for(let e=0;e<u.length;e++)u[e]=a.shape[s[e]];let l;if(o.shouldExecuteOnCPU([a])){const e=o.texData.get(a.dataId).values,t=Qc(e,a.shape,a.dtype,s,u);l=o.makeTensorInfo(u,a.dtype),o.texData.get(l.dataId).values=t}else l=qd(a,s,o);return l}const Zd={kernelName:jt,backendName:"webgl",kernelFunc:Qd};function Jd({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:u=null}){const l=e.shape.length,c=t.shape.length,p=n?e.shape[l-2]:e.shape[l-1],h=r?t.shape[c-1]:t.shape[c-2],f=n?e.shape[l-1]:e.shape[l-2],g=r?t.shape[c-2]:t.shape[c-1],x=e.shape.slice(0,-2),b=t.shape.slice(0,-2),y=m(x),w=m(b),v=ra(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,g]);d(p===h,(()=>`Error in matMul: inner shapes (${p}) and (${h}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));const I=n?[y,p,f]:[y,f,p],k=r?[w,g,h]:[w,h,g],C=Ud({inputs:{x:e},backend:a,attrs:{shape:I}}),$=Ud({inputs:{x:t},backend:a,attrs:{shape:k}}),S=[C,$],_=Math.max(y,w),E=n?C.shape[1]:C.shape[2],T=null!=s,R=null!=o,N="leakyrelu"===u,A=null!=u?Dd(u,!0):null;let F;if((1===f||1===g)&&E>1e3&&!1===(T||R||N||null!=A)){let e=C,t=$;n&&(e=Qd({inputs:{x:C},backend:a,attrs:{perm:[0,2,1]}}),S.push(e)),r&&(t=Qd({inputs:{x:$},backend:a,attrs:{perm:[0,2,1]}}),S.push(t));const s=1===g;let o=e;1!==g&&(o=Ud({inputs:{x:e},backend:a,attrs:{shape:[_,E,1]}}),S.push(o));const i=1===g?2:1;let u=t;s&&(u=Ud({inputs:{x:t},backend:a,attrs:{shape:[_,1,E]}}),S.push(u));const l=Bd({inputs:{a:o,b:u},backend:a});F=Kd({inputs:{x:l},backend:a,attrs:{axis:i,keepDims:!0}}),S.push(l)}else{const u=Kn(e.dtype,t.dtype),l=new Md(I,k,[_,f,g],n,r,T,A,R,N),c=[C,$];if(null!=s&&c.push(s),R&&c.push(o),N){const e=a.makeTensorInfo([],"float32",Cn(i,"float32"));c.push(e),S.push(e)}F=a.runWebGLProgram(l,c,u)}const O=Ud({inputs:{x:F},backend:a,attrs:{shape:v}});S.push(F);for(const e of S)a.disposeIntermediateTensorInfo(e);return O}const ep={kernelName:Qt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:o,preluActivationWeights:i}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=r;return Jd({a,b:s,transposeA:u,transposeB:l,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:d,activation:c})}},tp="return abs(x);",np={kernelName:Y,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=Pc(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let a;return a=H().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new hd(r.shape,tp):new id(r.shape,tp),n.runWebGLProgram(a,[r],r.dtype)}},rp={kernelName:"Acos",backendName:"webgl",kernelFunc:Fd({opSnippet:ud+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"})},ap={kernelName:"Acosh",backendName:"webgl",kernelFunc:Fd({opSnippet:ud+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"})},sp="return a + b;",op=Od({opSnippet:sp,packedOpSnippet:sp,supportsComplex:!0,cpuKernelImpl:ic}),ip={kernelName:Q,backendName:"webgl",kernelFunc:op};class up{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class lp{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const cp={kernelName:Z,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,a=n;if(1===a.length)return Id({inputs:{x:a[0]},backend:r});if(a.length>H().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(a.length/2),n=e({inputs:a.slice(0,t),backend:r}),s=e({inputs:a.slice(t),backend:r});return e({inputs:[n,s],backend:r})}const s=a.map((e=>e.dtype)).reduce(((e,t)=>Kn(e,t))),o=a.map((e=>e.shape)),i=H().getBool("WEBGL_PACK")?new lp(a[0].shape,o):new up(a[0].shape,o);return r.runWebGLProgram(i,a,s)}},dp={kernelName:J,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,i=a.shape.length,u=I(s,a.shape);let l=u;const c=ks(l,i);let d=a;null!=c&&(d=Qd({inputs:{x:a},backend:n,attrs:{perm:c}}),l=$s(l.length,i)),Is("all",l,i);const[p,h]=ws(d.shape,l),f=Ud({inputs:{x:d},backend:n,attrs:{shape:[-1,m(h)]}}),g=Hd(f,f.dtype,"all",n);let x;return x=Ud(o?{inputs:{x:g},backend:n,attrs:{shape:vs(p,u)}}:{inputs:{x:g},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(d),x}},pp={kernelName:ee,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,i=a.shape.length,u=I(s,a.shape);let l=u;const c=ks(l,i);let d=a;null!=c&&(d=Qd({inputs:{x:a},backend:n,attrs:{perm:c}}),l=$s(l.length,i)),Is("any",l,i);const[p,h]=ws(d.shape,l),f=Ud({inputs:{x:d},backend:n,attrs:{shape:[-1,m(h)]}}),g=Hd(f,f.dtype,"any",n);let x;return x=Ud(o?{inputs:{x:g},backend:n,attrs:{shape:vs(p,u)}}:{inputs:{x:g},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(d),x}};class hp{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];const o="max"===t?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${i};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${o} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class fp{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,d(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,i=o.length,u=$u(i),l=ed("coords",i);let c,p;if(1===s){p=i+1;const e=$u(p);c=`\n        ${e} sourceLocR = ${e}(${l.join()}, 0);\n        ++${l[i-1]};\n        ${e} sourceLocG = ${e}(${l.join()}, 0);\n        ++${l[i-2]};\n        ${e} sourceLocA = ${e}(${l.join()}, 0);\n        --${l[i-1]};\n        ${e} sourceLocB = ${e}(${l.join()}, 0);\n        --${l[i-2]};`}else p=i,c=`\n        ${u} sourceLocR = coords;\n        ++${l[i-1]};\n        ${u} sourceLocG = coords;\n        ++${l[i-2]};\n        ${u} sourceLocA = coords;\n        --${l[i-1]};\n        ${u} sourceLocB = coords;\n        --${l[i-2]};`;const h=["x","y","z","w","u","v"].slice(0,p),f="."+h[p-1],m=h.map((e=>"int "+e)),g=ed("sourceLocR",p-1).concat("inIdx.r"),x=ed("sourceLocG",p-1).concat("inIdx.g"),b=ed("sourceLocB",p-1).concat("inIdx.b"),y=ed("sourceLocA",p-1).concat("inIdx.a"),w="max"===n?"greaterThan":"lessThan",v=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${x.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,I=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${x.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${l[i-1]} < ${o[i-1]-1};\n        bool hasNextRow = ${l[i-2]} < ${o[i-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${I};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${I};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function mp(e,t,n,r=null){let a=t.shape[0],s=t.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);const o=Do(s),i={windowSize:o,inSize:s,batchSize:a,outSize:Math.ceil(s/o)},u=new hp(i,n,null==r),l=[t];null!=r&&l.push(r);const c=e.runWebGLProgram(u,l,"int32");if(1===c.shape[1])return c;const d=mp(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function gp(e,t,n,r=null){const a=null!=r?r.shape:t.shape,s=Do(a[a.length-1]),o=new fp(a,s,n,null==r),i=null==r?[t]:[t,r],u=e.runWebGLProgram(o,i,"int32");if(u.shape.length===t.shape.length){const r=gp(e,t,n,u);return e.disposeIntermediateTensorInfo(u),r}return u}function xp(e,t,n,r){const a=[n];if(Is("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!H().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],s=e.texData.get(t.dataId);let o=t;null!==s&&s.isPacked&&(o=e.unpackTensor(t),n.push(o));const[i,u]=ws(o.shape,a),l=m(u),c=Ud({inputs:{x:o},backend:e,attrs:{shape:[-1,l]}});n.push(c);const d=mp(e,c,r);n.push(d);const p=Ud({inputs:{x:d},backend:e,attrs:{shape:i}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),p}return gp(e,t,r)}const bp={kernelName:te,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let o=I(s,a.shape);const i=ks(o,a.shape.length);let u=a;const l=[];null!=i&&(u=Qd({inputs:{x:a},backend:n,attrs:{perm:i}}),l.push(u),o=$s(o.length,u.shape.length)),Is("argMax",[o[0]],u.shape.length);const c=xp(n,u,o[0],"max");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},yp={kernelName:"ArgMin",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let o=I(s,a.shape);const i=ks(o,a.shape.length);let u=a;const l=[];null!=i&&(u=Qd({inputs:{x:a},backend:n,attrs:{perm:i}}),l.push(u),o=$s(o.length,u.shape.length)),Is("argMin",[o[0]],u.shape.length);const c=xp(n,u,o[0],"min");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},wp={kernelName:"Asin",backendName:"webgl",kernelFunc:Fd({opSnippet:ud+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"})},vp={kernelName:"Asinh",backendName:"webgl",kernelFunc:Fd({opSnippet:ud+"return log(x + sqrt(x * x + 1.0));"})},Ip={kernelName:"Atan",backendName:"webgl",kernelFunc:Fd({opSnippet:ud+"\n  return atan(x);\n"})},kp={kernelName:"Atan2",backendName:"webgl",kernelFunc:Od({opSnippet:bd+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+wd+"\n  return result;\n"})},Cp={kernelName:"Atanh",backendName:"webgl",kernelFunc:Fd({opSnippet:ud+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"})};class $p{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,o=e.strideHeight,i=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let x="0.0";if(f||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${i});\n        const ivec2 pads = ivec2(${p}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / count");const y=4*Math.floor(s/4),w=s%4,v=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${p}, ${h});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${y}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${v}\n          }\n\n          int xC = xCCorner + ${y};\n          if (${1===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${2===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${3===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${v}\n          }\n        }\n        setOutput(${b});\n      }\n    `}}class Sp{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let y="0.0";if(b||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${o}, ${i}, ${u});\n        const ivec3 pads = ivec3(${m}, ${g}, ${x});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(w="avgValue / count");const v=4*Math.floor(s/4),I=s%4,k=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${o}, ${i}, ${u});\n      const ivec3 pads = ivec3(${m}, ${g}, ${x});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${v}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${k}\n            }\n\n            int xC = xCCorner + ${v};\n            if (${1===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${2===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${3===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${k}\n            }\n          }\n          setOutput(${w});\n        }\n      }\n    `}}const _p={kernelName:ne,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;uu(a,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:u}=r;d(go(o,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const l=so(a.shape,s,o,1,i,u);if(1===l.filterWidth&&1===l.filterHeight&&g(l.inShape,l.outShape))return Id({inputs:{x:a},backend:n});const c=new $p(l,"avg",!1);return n.runWebGLProgram(c,[a],"float32")}},Ep={kernelName:"AvgPool3D",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=r,c=oo(a.shape,s,o,[1,1,1],i,u,l),d=new Sp(c,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}};class Tp{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=i-1-e.padInfo.top,c=u-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${o}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Rp{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=p-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${h}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Np={kernelName:"AvgPool3DGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,o=s,{filterSize:i,strides:u,pad:l,dimRoundingMode:c}=r,d=oo(o.shape,i,u,[1,1,1],l,c),p=new Rp(d);return n.runWebGLProgram(p,[a],o.dtype)}},Ap={kernelName:"AvgPoolGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,o=s;uu([a,s],"avgPoolGrad");const{filterSize:i,strides:u,pad:l}=r,c=so(o.shape,i,u,1,l),d=new Tp(c);return n.runWebGLProgram(d,[a],o.dtype)}},Fp={kernelName:re,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:o,transposeB:i}=r;return Jd({a,b:s,transposeA:o,transposeB:i,backend:n})}};class Op{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],ra(e,t),ra(e,n);let o="0.0";null!=r&&(ra(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="1.0";null!=a&&(ra(e,a),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${i};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Dp{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ra(e,t),ra(e,n);let o="vec4(0.0)";null!=r&&(ra(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=a&&(ra(e,a),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${i};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const Mp={kernelName:Re,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:a,variance:s,offset:o,scale:i}=e;d(a.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),d(null==o||a.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),d(null==i||a.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=n;null==u&&(u=.001);const l=[r,a,s];let c=null;null!=o&&(c=o.shape,l.push(o));let p=null;null!=i&&(p=i.shape,l.push(i));const h=H().getBool("WEBGL_PACK_NORMALIZATION")?new Dp(r.shape,a.shape,s.shape,c,p,u):new Op(r.shape,a.shape,s.shape,c,p,u);return t.runWebGLProgram(h,l,l[0].dtype)}};class Lp{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=$u(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return Pp.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${Pp[t]} = start[${t}] + coords.${Pp[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const Pp=["x","y","z","w","u","v"];class Bp{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=$u(this.rank),n=ed("coords",this.rank),r=ed("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,o=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,i=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${o}\n        ${i}\n        setOutput(result);\n      }\n    `}}function Wp(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:o}=r,[i,u]=Ia(a,s,o);if(ua(a,i,u),0===m(u))return n.makeTensorInfo(u,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){const e=n.texData.get(a.dataId),t=Bc(e.values,i,u,a.shape,a.dtype);return n.makeTensorInfo(u,a.dtype,t)}const{isPacked:l}=n.texData.get(a.dataId),c=wa(a.shape,i,u);if(l||!c){const e=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Bp(u):new Lp(u),t=[i];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),function(e,t,n,r){const a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),o=r.texData.get(s.dataId);Object.assign(o,a),o.refCount=1,o.shape=n,o.dtype=e.dtype;let i=va(t,F(e.shape));a.slice&&(i+=a.slice.flatOffset),o.slice={flatOffset:i,origDataId:a.slice&&a.slice.origDataId||e.dataId};const u=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,u+1),s}(a,i,u,n)}const Up={kernelName:Ct,backendName:"webgl",kernelFunc:Wp},Vp={kernelName:ae,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:o}=r;d(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((e,t)=>e*t)),u=Lo(a.shape,s,i),l=Po(u.length,s.length),c=Bo(a.shape,s,i),p=Wo(o,s.length),h=Uo(c,o,s.length),f=[],m=Ud({inputs:{x:a},backend:n,attrs:{shape:u}}),g=Qd({inputs:{x:m},backend:n,attrs:{perm:l}}),x=Ud({inputs:{x:g},backend:n,attrs:{shape:c}}),b=Wp({inputs:{x},backend:n,attrs:{begin:p,size:h}});return f.push(m),f.push(g),f.push(x),f.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},Gp={kernelName:se,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:o}=r,i=n.readSync(a.dataId),u=n.readSync(s.dataId),l=uc(i,u,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,l)}},zp={kernelName:"BroadcastArgs",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),o=n.readSync(a.dataId),i=ra(Array.from(s),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},Hp=Od({opSnippet:"return float(a != b);",cpuKernelImpl:Rc,dtype:"bool"}),jp={kernelName:tt,backendName:"webgl",kernelFunc:Hp};function Xp(e){const{inputs:t,backend:n}=e,{input:r}=t;return Id({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const qp={kernelName:ht,backendName:"webgl",kernelFunc:Xp},Kp={kernelName:oe,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:a}=t,{x:s}=n,{dtype:o}=a;if("complex64"===o){if("complex64"===s.dtype)return Id({inputs:{x:s},backend:r});const t=Ra(s.shape),n=e({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=Cd({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===s.dtype){const t=Xp({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:o}});return r.disposeIntermediateTensorInfo(t),n}if(!S(s.dtype,o)){const e=Id({inputs:{x:s},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:o}}if(r.shouldExecuteOnCPU([s])){const e=r.texData.get(s.dataId).values,[t,n,a]=cc(e,s.shape,s.dtype,o);return r.makeTensorInfo(t,n,a)}if("int32"===o)return function(e,t){const n=new id(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===o){const e=r.makeTensorInfo([],"bool",C("bool",1)),t=Hp({inputs:{a:s,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},Yp="return ceil(x);",Qp={kernelName:ie,backendName:"webgl",kernelFunc:Fd({opSnippet:Yp,packedOpSnippet:Yp,cpuKernelImpl:dc})};class Zp{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class Jp{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const eh={kernelName:ue,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:o}=r;let i;i=H().getBool("WEBGL_PACK_CLIP")?new Jp(a.shape):new Zp(a.shape);const u=[[s],[o]];return n.runWebGLProgram(i,[a],a.dtype,u)}};class th{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function nh(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const rh={kernelName:ce,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new th(r.shape),o=[nh(r,a.complexTensorInfos.real),nh(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,o,o[0].dtype)}};class ah{constructor(e){this.outputShape=[],this.outputShape=ro(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const r=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${r}));`)}const r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class sh{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ro(e,t);const n=this.outputShape,r=n.length,a=$u(r),s=ed("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const i=new Array(e.length-1);i[0]=e[0][t];for(let n=1;n<i.length;n++)i[n]=i[n-1]+e[n][t];const u=o[t],l=o.slice(-2),c=o.join();let d=`if (${u} < ${i[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${l.join()}));\n        }`;for(let e=1;e<i.length;e++){const t=i[e-1];d+=`\n        if (${u} < ${i[e]}  && ${u} >= ${i[e-1]}) {\n          return getChannel(\n            getT${e}(${oh(o,u,t)}),\n            vec2(${oh(l,u,t)}));\n        }`}const p=i.length,h=i[i.length-1];d+=`\n        return getChannel(\n          getT${p}(${oh(o,u,h)}),\n          vec2(${oh(l,u,h)}));`,this.userCode=`\n      float getValue(${o.map((e=>"int "+e))}) {\n        ${d}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function oh(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function ih(e){const{inputs:t,backend:n}=e,{input:r}=t;return Id({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const uh={kernelName:Le,backendName:"webgl",kernelFunc:ih};function lh(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>Xp({inputs:{input:e},backend:n}))),a=e.map((e=>ih({inputs:{input:e},backend:n}))),s=lh(r,t,n),o=lh(a,t,n),i=Cd({inputs:{real:s,imag:o},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),i}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){const a=e.map((e=>{const r=m(e.shape.slice(t));return Ud({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),o=ro(a.map((e=>e.shape)),1),i=1===a[0].shape[0],u=pc(s,o,r,i),l=ro(e.map((e=>e.shape)),t),c=n.makeTensorInfo(l,r,u);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const s=H().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(e.length>s){const r=[];for(let a=0;a<e.length;a+=s){const o=e.slice(a,a+s);r.push(lh(o,t,n))}const a=lh(r,t,n);for(const e of r)n.disposeIntermediateTensorInfo(e);return a}if(H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const a=new sh(e.map((e=>e.shape)),t);return n.runWebGLProgram(a,e,r)}const{tensors2D:o,outShape:i}=function(e,t,n){const r=ro(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>Ud({inputs:{x:e},attrs:{shape:[-1,m(e.shape.slice(t))]},backend:n}))),outShape:r}}(e,t,n),u=new ah(o.map((e=>e.shape))),l=n.runWebGLProgram(u,o,r);o.forEach((e=>n.disposeIntermediateTensorInfo(e)));const c=Ud({inputs:{x:l},attrs:{shape:i},backend:n});return n.disposeIntermediateTensorInfo(l),c}function ch(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=I(a,t[0].shape)[0];no(t.map((e=>e.shape)),s);const o=ro(t.map((e=>e.shape)),s);if(0===m(o))return n.makeTensorInfo(o,t[0].dtype,[]);const i=t.filter((e=>m(e.shape)>0));return 1===i.length?Id({inputs:{x:i[0]},backend:n}):lh(i,s,n)}const dh={kernelName:de,backendName:"webgl",kernelFunc:ch};class ph{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.padInfo.top,o=e.padInfo.left,i=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,x=m?2:3,b=m?3:1;let y="",w="";n&&(y=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,w="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${y}\n\n      const ivec2 strides = ivec2(${i}, ${u});\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${x}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${w}\n        setOutput(result);\n      }\n    `}}class hh{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${s}, ${o});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${i};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class fh{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Nu(this.outputShape.length);const s=e.padInfo.left,o=e.strideWidth,i=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c;let p="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<c;e++)p+=`\n           vec4 xTexelC${2*e};\n           int xTexelC${2*e}Ready;\n           vec4 xTexelC${2*e+1};\n           int xTexelC${2*e+1}Ready;\n           vec4 xC${e};`;p+=`\n     for (int r = 0; r < ${u}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let e=0;e<c;e++)p+=`\n           xTexelC${2*e} = vec4(0.0);\n           xTexelC${2*e}Ready = 0;\n           xTexelC${2*e+1} = vec4(0.0);\n           xTexelC${2*e+1}Ready = 0;\n           xC${e} = vec4(0.0);`;p+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let t=0;t<(d+1)/2;t++){const n=2*t;if(p+=`\n           xC = xCCorner + ${n*i};\n           `,1===o){if(n<c&&(s%2==1?(p+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n               `,p+=1===i&&n>0?`\n                 xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${n} = vec4(previous.zw, xTexelC${n}.xy);\n                   } else {\n                     xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                   }\n                   `):p+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xC${n} = xTexelC${n};\n                 `,n+1<c)){const e=s%2==0?l(i):i;i%2==0&&s%2==1||i%2!=0&&s%2!=1?(p+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                     xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${n+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${n+1}Ready = 1;\n                   }\n                   `,p+=i>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);\n                     } else {\n                      xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);\n                     }\n                     `:`\n                     xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);\n                     `):p+=1===e?`\n                     xC${n+1} = xTexelC${n};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                       xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${n+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${n+1}Ready = 1;\n                     }\n\n                     xC${n+1} = xTexelC${n+1};\n                     `}}else n<c&&(s%2==1?(p+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n               `,n+1<c&&(p+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);\n                 `)):(p+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(\n                   xTexelC${n}.xy, xTexelC${n+1}.xy);\n               `,n+1<c&&(p+=`\n                   xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n                 `)));n<c&&(p+=`\n             wTexel = getW(r, ${n}, d1, d2);\n             dotProd += xC${n}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${n}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,n+1<c&&(p+=`\n               wTexel = getW(r, ${n+1}, d1, d2);\n               dotProd += xC${n+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${n+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}p+="\n     }\n   ",p+="\n     }\n   ",p+="\n     }\n   ";let h="",f="";n&&(h=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${h}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${p}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${m}\n         ${f}\n         setOutput(result);\n       }\n     `}}class mh{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Nu(this.outputShape.length);const{dataFormat:n}=t,r=cu(),a="channelsLast"===n,s=a?1:2,o=a?2:3,i=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)u+=`\n          blockIndex = rc.z + ${t};\n          pos = rc.y + ${e};\n\n          ${i}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${o}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${u}\n\n        ${r.output} = result;\n      }\n    `}}function gh(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function xh({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:i=null}){const u=e.shape,l=r.texData.get(e.dataId),c=n.inChannels,p=u[0]*u[1]*u[2],h=n.outChannels,f="channelsLast"===n.dataFormat;let m;const x=[];if(null!=s){const e=gh(s.shape,f);null!=e&&(s=Ud({inputs:{x:s},backend:r,attrs:{shape:e}}),x.push(s))}if(null!=a){const e=gh(a.shape,f);null!=e&&(a=Ud({inputs:{x:a},backend:r,attrs:{shape:e}}),x.push(a))}if((1!==p&&1!==h||!(c>1e3))&&l.isPacked&&f&&null!=l.texture&&u[2]%2!=0&&g(l.shape.slice(-3),u.slice(-3))){const c=u[0]*u[1]*(u[2]+1),p={dataId:e.dataId,shape:[1,c,n.inChannels],dtype:e.dtype},h=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,d(nu(l.shape,p.shape),(()=>`packed reshape ${l.shape} to ${p.shape} isn't free`));const f=Ud({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});x.push(f);const g=Jd({a:p,b:f,backend:r,transposeA:!1,transposeB:!1,bias:a,activation:i,preluActivationWeights:s,leakyreluAlpha:o}),b=r.texData.get(g.dataId);d(b.isPacked,(()=>"batchMatMul result is expected to be packed")),l.shape=h,b.shape=n.outShape,m=Id({inputs:{x:g},backend:r}),m.shape=n.outShape,x.push(g)}else{const u=n.outHeight*n.outWidth,l=Ud({inputs:{x:e},backend:r,attrs:{shape:f?[n.batchSize,u,n.inChannels]:[n.batchSize,n.inChannels,u]}}),c=Ud({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),d=Jd({a:f?l:c,b:f?c:l,transposeA:!f,transposeB:!1,backend:r,bias:a,activation:i,preluActivationWeights:s,leakyreluAlpha:o});m=Ud({inputs:{x:d},backend:r,attrs:{shape:n.outShape}}),x.push(l),x.push(c),x.push(d)}for(const e of x)r.disposeIntermediateTensorInfo(e);return m}function bh({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:i=null}){const{filterWidth:u,filterHeight:l,inChannels:c,outWidth:d,outHeight:p,dataFormat:h}=n,f="channelsLast"===h,g=u*l*c,x=p*d,b=[n.batchSize,g,x],y=[];if(null!=s){const e=gh(s.shape,f);null!=e&&(s=Ud({inputs:{x:s},backend:r,attrs:{shape:e}}),y.push(s))}if(null!=a){const e=gh(a.shape,f);null!=e&&(a=Ud({inputs:{x:a},backend:r,attrs:{shape:e}}),y.push(a))}const w=Ud({inputs:{x:t},backend:r,attrs:{shape:[1,g,m(t.shape)/g]}});y.push(w);const v=new mh(b,n),I=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],k=r.runWebGLProgram(v,[e],"float32",I),C=Ud({inputs:{x:k},backend:r,attrs:{shape:b}});y.push(k),y.push(C);const $=null!=a,S=null!=s,_="leakyrelu"===i,E=i?Dd(i,!0):null,T=new Md(f?C.shape:w.shape,f?w.shape:C.shape,f?[n.batchSize,x,n.outChannels]:[n.batchSize,n.outChannels,x],!0,!1,$,E,S,_),R=f?[C,w]:[w,C];if(a&&R.push(a),S&&R.push(s),_){const e=r.makeTensorInfo([],"float32",Cn(o,"float32"));R.push(e),y.push(e)}const N=r.runWebGLProgram(T,R,"float32"),A=Ud({inputs:{x:N},backend:r,attrs:{shape:n.outShape}});y.push(N);for(const e of y)r.disposeIntermediateTensorInfo(e);return A}const yh={kernelName:pe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dataFormat:u,dilations:l,dimRoundingMode:c}=r,d=xo(u),p=io(a.shape,s.shape,o,l,i,c,!1,d);let h;if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(p.strideWidth<=2&&"channelsLast"===d&&H().getBool("WEBGL_EXP_CONV")){const e=new fh(p),t=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];h=n.runWebGLProgram(e,[a,s],"float32",t)}else if(H().getBool("WEBGL_CONV_IM2COL"))h=bh({x:a,filter:s,convInfo:p,backend:n});else{const e=new ph(p);h=n.runWebGLProgram(e,[a,s],"float32")}else h=xh({x:a,filter:s,convInfo:p,backend:n});const f=Ud({inputs:{x:h},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(h),f}};class wh{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${s}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class vh{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s="channelsLast"===e.dataFormat,o=t-1-e.padInfo.top,i=n-1-e.padInfo.left,u=s?1:2,l=s?2:3,c=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${u}], coords[${l}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ih{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,o=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${o};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class kh{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=t-1-e.padInfo.front,u=n-1-e.padInfo.top,l=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${i}, ${u}, ${l});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Ch={kernelName:"Conv2DBackpropFilter",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:c}=r,d=xo(u),p=io(a.shape,c,o,1,i,l,!1,d),h=new wh(p);return n.runWebGLProgram(h,[a,s],"float32")}},$h={kernelName:he,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:o,strides:i,pad:u,dataFormat:l,dimRoundingMode:c}=r,d=xo(l),p=io(o,s.shape,i,1,u,c,!1,d),h=new vh(p);return n.runWebGLProgram(h,[a,s],"float32")}},Sh={kernelName:"Conv3D",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dilations:u}=r,l=uo(a.shape,s.shape,o,u,i),c=new hh(l);return n.runWebGLProgram(c,[a,s],"float32")}},_h={kernelName:"Conv3DBackpropFilterV2",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,pad:i,filterShape:u}=r,l=uo(a.shape,u,o,1,i),c=new Ih(l);return n.runWebGLProgram(c,[a,s],"float32")}},Eh={kernelName:"Conv3DBackpropInputV2",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:o,strides:i,inputShape:u}=r,l=uo(u,s.shape,i,1,o),c=new kh(l);return n.runWebGLProgram(c,[a,s],"float32")}},Th={kernelName:"Cos",backendName:"webgl",kernelFunc:Fd({opSnippet:Ad+"\n  return cos(x);\n"})},Rh={kernelName:fe,backendName:"webgl",kernelFunc:Fd({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"})};class Nh{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,o,i,u]=e,[l]=t,[c,d]=n;this.outputShape=[l,c,d,u];const p="bilinear"===r?1:0,[h,f]=[o-1+".0",i-1+".0"],[m,g,x]=c>1?[""+(o-1)/(c-1),"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[b,y,w]=d>1?[""+(i-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${y};\n\n        float in_y = ${x};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const Ah={kernelName:xe,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:o}=t,{cropSize:i,method:u,extrapolationValue:l}=r,c=new Nh(a.shape,s.shape,i,u,l);return n.runWebGLProgram(c,[a,s,o],"float32")}};var Fh;!function(e){e.Prod="*",e.Sum="+"}(Fh||(Fh={}));class Oh{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,s=this.op===Fh.Prod?"1.0":"0.0",o=n?s:`getX(${Dh(a,"coords",this.op)})`,i=this.outputShape[this.outputShape.length-1];let u="",l="";n?(u=r?"end != "+(i-1):"end != 0",l=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${i}`:"end >= pow2",l=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${$u(a)} coords = getOutputCoords();\n        int end = ${Mh(a,"coords",this.op)};\n        float val = ${o};\n        int pow2 = int(pow(2.0, index));\n        if (${u}) {\n          int idx = ${l};\n          ${Mh(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${Dh(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function Dh(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Mh(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Lh(e,t,n,r,a,s){const o=t.shape.length,i=ks([r],o);let u=t;null!=i&&(u=Qd({inputs:{x:t},backend:n,attrs:{perm:i}}));const l=$s(1,o)[0];if(l!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=u.shape[l];let d=Id({inputs:{x:u},backend:n});for(let t=0;t<=Math.ceil(Math.log2(c))-1;t++){const r=new Oh(e,u.shape,!1,s),a=[[t]],o=d;d=n.runWebGLProgram(r,[d],d.dtype,a),n.disposeIntermediateTensorInfo(o)}if(a){const t=new Oh(e,u.shape,a,s),r=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=i){const e=Qd({inputs:{x:d},backend:n,attrs:{perm:Cs(i)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(u),e}return d}const Ph={kernelName:me,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r;return Lh(Fh.Prod,a,n,s,o,i)}},Bh={kernelName:ge,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r;return Lh(Fh.Sum,a,n,s,o,i)}},Wh={kernelName:"DenseBincount",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:o,binaryOutput:i}=r;if(1===a.shape.length){const e=n.readSync(a.dataId),t=n.readSync(s.dataId),r=uc(e,t,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,r)}if(2===a.shape.length){const e=n.bufferSync(a),t=n.bufferSync(s),r=lc(e,t,o,i);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};class Uh{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Vh={kernelName:be,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:o}=r,i=a.shape[0],u=("NHWC"===o?a.shape[1]:a.shape[2])*s,l=("NHWC"===o?a.shape[2]:a.shape[3])*s,c=("NHWC"===o?a.shape[3]:a.shape[1])/(s*s),d=new Uh("NHWC"===o?[i,u,l,c]:[i,c,u,l],s,o);return n.runWebGLProgram(d,[a],a.dtype)}};class Gh{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Nu(this.outputShape.length);const s=e.filterHeight,o=e.filterWidth,i=e.outChannels/e.inChannels;let u="",l="";n&&(u=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,l="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${u}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${l}\n        setOutput(result);\n      }\n    `}}class zh{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Nu(this.outputShape.length);const s=e.outChannels/e.inChannels,o=e.padInfo.left,i=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,p=d;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<d;e++)h+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;h+=`\n    for (int r = 0; r < ${c}; r++) {\n      `;for(let e=0;e<d;e++)h+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(p+1)/2;e++){const t=2*e;if(h+=`\n          xC = xCCorner + ${t*u};\n          `,1===i){if(t<d&&(o%2==1?(h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,h+=1===u&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<d)){const e=o%2==0?l(u):u;u%2==0&&o%2==1||u%2!=0&&o%2!=1?(h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,h+=u>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                    } else {\n                     xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                    }\n                    `:`\n                    xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                    `):h+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<d&&(o%2==1?(h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<d&&(h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<d&&(h+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<d&&(h+=`\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<d&&(h+=`\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}h+="\n    }\n  ",h+="\n      }\n    ";let f="",m="";n&&(f=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,m="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${f}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${g}\n        ${m}\n        setOutput(result);\n      }\n    `}}const Hh={kernelName:ye,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dilations:u,dimRoundingMode:l}=r;let c=u;null==c&&(c=[1,1]),d(go(o,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`));const p=io(a.shape,s.shape,o,c,i,l,!0);let h;h=H().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels==1?new zh(p):new Gh(p);const f=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return n.runWebGLProgram(h,[a,s],"float32",f)}};class jh{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Xh{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,o=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${i}; dm++) {\n              int d2 = d1 * ${i} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const qh={kernelName:"DepthwiseConv2dNativeBackpropFilter",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,filterShape:c}=r,d=io(a.shape,c,o,i,u,l,!0),p=new jh(d);return n.runWebGLProgram(p,[a,s],"float32")}},Kh={kernelName:"DepthwiseConv2dNativeBackpropInput",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,inputShape:c}=r,d=io(c,s.shape,o,i,u,l,!0),p=new Xh(d);return n.runWebGLProgram(p,[a,s],"float32")}};class Yh{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Qh={kernelName:"Diag",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=m(r.shape),o=Ud({inputs:{x:r},backend:n,attrs:{shape:[s]}}),i=new Yh(s),u=n.runWebGLProgram(i,[o],o.dtype),l=Ud({inputs:{x:u},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),l}};class Zh{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:o,filterWidth:i,dilationHeight:u,dilationWidth:l}=e,{top:c,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${o}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${i}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const Jh={kernelName:"Dilation2D",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dilations:u}=r,l=ao(a.shape,s.shape,o,i,"NHWC",u);let c;const d=new Zh(l);c=n.runWebGLProgram(d,[a,s],"float32");const p=Ud({inputs:{x:c},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(c),p}},ef={kernelName:"Einsum",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:o,summedDims:i,idDims:u}=oi(a,s.length);ui(o.length,u,s);const{path:l,steps:c}=li(i,u),d=c.length;let p=null,h=o.length;const f=[];for(let e=0;e<d;++e){for(const t of c[e]){const{permutationIndices:e,expandDims:r}=ii(h,u[t]);let a;ci(e)?a=s[t]:(a=Qd({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),f.push(a));const o=a.shape.slice();for(let e=0;e<r.length;++e)o.splice(r[e],0,1);g(a.shape,o)||(a=Ud({inputs:{x:a},backend:n,attrs:{shape:o}}),f.push(a)),null===p?p=a:(p=Bd({inputs:{a,b:p},backend:n}),f.push(p))}e<d-1&&(l[e]>=0&&(p=Kd({inputs:{x:p},backend:n,attrs:{axis:l[e]-(o.length-h),keepDims:!1}}),f.push(p)),h--)}for(const e of f)e!==p&&n.disposeIntermediateTensorInfo(e);return p}},tf=Fd({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),nf={kernelName:ve,backendName:"webgl",kernelFunc:tf},rf={kernelName:"EluGrad",backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=H().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new vd("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new yd("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)}},af={kernelName:Ie,backendName:"webgl",kernelFunc:Od({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:hc})},sf={kernelName:"Erf",backendName:"webgl",kernelFunc:Fd({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${zo};\n  float a1 = ${Ho};\n  float a2 = ${jo};\n  float a3 = ${Xo};\n  float a4 = ${qo};\n  float a5 = ${Ko};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`})},of=Fd({opSnippet:Ad+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:fc,dtype:"float32"}),uf={kernelName:ke,backendName:"webgl",kernelFunc:of};function lf(e){const{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,o=s.shape.length,i=s.shape.slice();let u=a;return a<0&&(d(-(o+1)<=a,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),u=o+a+1),i.splice(u,0,1),Ud({inputs:{x:s},backend:r,attrs:{shape:i}})}const cf={kernelName:Ce,backendName:"webgl",kernelFunc:lf},df="return exp(x) - 1.0;",pf={kernelName:$e,backendName:"webgl",kernelFunc:Fd({opSnippet:df,packedOpSnippet:df,cpuKernelImpl:mc})};class hf{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const a=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${r}.0`:"1.0";let o;if("real"===e)o="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);o="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${a};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${o}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function ff(e,t,n){const r=n.texData.get(e.dataId),a=m(e.shape),s=e.shape[e.shape.length-1],o=Ud({inputs:{x:e},backend:n,attrs:{shape:[a/s,s]}}),i=o.shape,u=new hf("real",i,t),l=new hf("imag",i,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:i},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:i}],d=n.runWebGLProgram(u,c,"float32"),p=n.runWebGLProgram(l,c,"float32"),h=Cd({inputs:{real:d,imag:p},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p);const f=Ud({inputs:{x:h},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(h),f}const mf={kernelName:"FFT",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return ff(r,!1,n)}};class gf{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function xf(e){const{backend:t,attrs:n}=e,{shape:r,value:a}=n;let{dtype:s}=n;if(s=s||R(a),"string"===s){const e=$(s,m(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{const e=new gf(r,a),n=[[a]];return t.runWebGLProgram(e,[],s,n)}}const bf={kernelName:Se,backendName:"webgl",kernelFunc:xf};class yf{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const wf={kernelName:_e,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,a=new yf(n.shape);return r.runWebGLProgram(a,[n],n.dtype)}},vf="return floor(x);",If={kernelName:Ee,backendName:"webgl",kernelFunc:Fd({opSnippet:vf,packedOpSnippet:vf,cpuKernelImpl:gc})},kf=Od({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),Cf={kernelName:Te,backendName:"webgl",kernelFunc:kf};class $f{constructor(e){this.variableNames=["A"];const t=cu(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class Sf{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=cu(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const _f={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:a}=t;const{numChannels:s}=r,o="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,i="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,[u,l]=o?[a.videoWidth,a.videoHeight]:[a.width,a.height],c=[l,u],d=[l,u,s];if(i||o){const e=H().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=Ef&&e===Tf||(Tf=e,Ef=document.createElement("canvas").getContext("2d",{willReadFrequently:Tf})),Ef.canvas.width=u,Ef.canvas.height=l,Ef.drawImage(a,0,0,u,l),a=Ef.canvas}const p=n.makeTensorInfo(c,"int32");n.texData.get(p.dataId).usage=Oi.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),a);const h=H().getBool("WEBGL_PACK")?new Sf(d):new $f(d),f=n.runWebGLProgram(h,[p],"int32");return n.disposeData(p.dataId),f}};let Ef,Tf=H().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const Rf={kernelName:Zt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=r,m=xo(c),g=io(a.shape,s.shape,u,d,l,p,!1,m);let x;const b=[],y=null!=o,w=null!=i,v="leakyrelu"===h,I=()=>{const e=[a,s],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=Ud({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(y&&e.push(t(o,c)),w&&e.push(t(i,c)),v){const t=n.makeTensorInfo([],"float32",Cn(f,"float32"));e.push(t),b.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&H().getBool("WEBGL_EXP_CONV")){const e=h?Dd(h,!0):null,t=new fh(g,y,e,w,v),r=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],a=I();x=n.runWebGLProgram(t,a,"float32",r)}else if(H().getBool("WEBGL_CONV_IM2COL"))x=bh({x:a,filter:s,convInfo:g,backend:n,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:f});else{const e=h?Dd(h,!1):null,t=new ph(g,y,e,w,v),r=I();x=n.runWebGLProgram(t,r,"float32")}else x=xh({x:a,filter:s,convInfo:g,backend:n,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:f});const k=Ud({inputs:{x},backend:n,attrs:{shape:g.outShape}});return b.push(x),b.forEach((e=>n.disposeIntermediateTensorInfo(e))),k}},Nf={kernelName:Jt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=r,m=[];let g=c;null==g&&(g=[1,1]),d(go(u,g),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${g}'`));const x=io(a.shape,s.shape,u,g,l,p,!0),b=H().getBool("WEBGL_PACK_DEPTHWISECONV")&&x.strideWidth<=2&&x.outChannels/x.inChannels==1,y=h?Dd(h,b):null,w=[a,s],v=null!=o,I=null!=i,k="leakyrelu"===h;if(v&&w.push(o),I&&w.push(i),k){const e=n.makeTensorInfo([],"float32",Cn(f,"float32"));w.push(e),m.push(e)}let C;C=b?new zh(x,v,y,I,k):new Gh(x,v,y,I,k);const $=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],S=n.runWebGLProgram(C,w,"float32",$);return m.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};class Af{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const a=$u(n.length);let s="\n    int index;";for(let e=0;e<this.sliceDim;e++)s+=`\n          index = round(getIndices(coords[0], ${e}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[e]};\n          flattenIndex += index * ${this.strides[e]};`;this.userCode=`\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const Ff={kernelName:Ae,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,o=s[s.length-1],i=m(r.shape),[u,l,c,d]=aa(r,a),p=Ud({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),h=Ud({inputs:{x:r},backend:n,attrs:{shape:[m(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const e=n.readSync(a.dataId),t=n.bufferSync(r),s=xc(e,t,r.dtype,l,o,c,d,r.shape,i);return n.makeTensorInfo(u,r.dtype,s.values)}const f=new Af(o,d,[l,c],r.shape),g=n.runWebGLProgram(f,[h,p],h.dtype),x=Ud({inputs:{x:g},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(g),x}};class Of{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=$u(this.rank),r=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let t=0;t<e.length;t++)2===t?r.push("index"):r.push(`${n[t]}`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function Df(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:o,batchDims:i}=r,u=I(o,a.shape)[0];if(H().get("DEBUG")){const e=n.readSync(s.dataId),t=a.shape[u];for(let n=0;n<e.length;++n){const r=e[n];d(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const l=_i(a,s,u,i),c=m(s.shape),p=[],h=Ud({inputs:{x:a},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),f=Ud({inputs:{x:s},backend:n,attrs:{shape:[l.batchSize,c/l.batchSize]}});p.push(h),p.push(f);const g=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){const e=n.bufferSync(f),t=n.bufferSync(h),r=bc(t,e,g);return p.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(l.outputShape,r.dtype,r.values)}const x=new Of(h.shape,g),b=n.runWebGLProgram(x,[h,f],h.dtype);p.push(b);const y=Ud({inputs:{x:b},backend:n,attrs:{shape:l.outputShape}});return p.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}const Mf={kernelName:Ne,backendName:"webgl",kernelFunc:Df},Lf=Od({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:yc,dtype:"bool"}),Pf={kernelName:Fe,backendName:"webgl",kernelFunc:Lf},Bf=Od({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:wc}),Wf={kernelName:Oe,backendName:"webgl",kernelFunc:Bf},Uf={kernelName:Me,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return ff(r,!0,n)}},Vf={kernelName:"IsFinite",backendName:"webgl",kernelFunc:Fd({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"})},Gf={kernelName:"IsInf",backendName:"webgl",kernelFunc:Fd({opSnippet:"return float(isinf(x));",dtype:"bool"})},zf={kernelName:"IsNan",backendName:"webgl",kernelFunc:Fd({opSnippet:"return float(isnan(x));",dtype:"bool"})},Hf={kernelName:Be,backendName:"webgl",kernelFunc:Od({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:vc,dtype:"bool"})},jf=Od({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Ic,dtype:"bool"}),Xf={kernelName:We,backendName:"webgl",kernelFunc:jf},qf={kernelName:"LinSpace",backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,o=kc(r,a,s);return t.makeTensorInfo([o.length],"float32",o)}},Kf=Fd({opSnippet:Ad+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:Cc}),Yf={kernelName:Ue,backendName:"webgl",kernelFunc:Kf},Qf=Fd({opSnippet:Ad+"\n  return log(1.0 + x);\n"}),Zf={kernelName:Ve,backendName:"webgl",kernelFunc:Qf},Jf=Od({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),em={kernelName:Ge,backendName:"webgl",kernelFunc:Jf},tm={kernelName:ze,backendName:"webgl",kernelFunc:Fd({opSnippet:"return float(!(x >= 1.0));"})},nm={kernelName:He,backendName:"webgl",kernelFunc:Od({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"})};class rm{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];const s=t,o=e[3]-1;let i;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;i=.5===a?`inversesqrt(${u})`:1===a?`1.0/(${u})`:`exp(log(${u}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${i};\n        setOutput(val);\n      }\n    `}}class am{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=t,o=e[3]-1;let i;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;i=.5===a?`inversesqrt(${u})`:1===a?`1.0/(${u})`:`exp(log(${u}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${i};\n        setOutput(result);\n      }\n    `}}const sm={kernelName:"LRN",backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:o,alpha:i,beta:u}=r,l=H().getBool("WEBGL_PACK_NORMALIZATION")?new am(a.shape,s,o,i,u):new rm(a.shape,s,o,i,u);return n.runWebGLProgram(l,[a],a.dtype)}};class om{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const im={kernelName:"LRNGrad",backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:o}=t,{depthRadius:i,bias:u,alpha:l,beta:c}=r,d=new om(a.shape,i,u,l,c);return n.runWebGLProgram(d,[a,s,o],a.dtype)}};function um(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:o}=r,i=a.shape.length,u=I(s,a.shape);let l=u;const c=ks(l,i),d=null!=c,p=n.shouldExecuteOnCPU([a]);let h=a;if(d){if(p){const e=n.texData.get(h.dataId).values,t=new Array(i);for(let e=0;e<t.length;e++)t[e]=a.shape[c[e]];const r=Qc(e,a.shape,a.dtype,c,t);h=n.makeTensorInfo(t,a.dtype),n.texData.get(h.dataId).values=r}else h=qd(a,c,n);l=$s(l.length,i)}Is("max",l,i);const[f,g]=ws(h.shape,l);let x,b=f;if(o&&(b=vs(f,u)),p){const e=n.texData.get(h.dataId).values,t=$c(e,m(g),b,a.dtype);x=n.makeTensorInfo(b,a.dtype),n.texData.get(x.dataId).values=t}else x=function(e,t,n,r){const a=m(t),s=Ud({inputs:{x:e},attrs:{shape:[m(e.shape)/a,a]},backend:r}),o=Hd(s,e.dtype,"max",r),i=Ud({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}(h,g,b,n);return d&&n.disposeIntermediateTensorInfo(h),x}const lm={kernelName:je,backendName:"webgl",kernelFunc:um},cm={kernelName:Xe,backendName:"webgl",kernelFunc:Od({opSnippet:bd+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+wd+"\n  return result;\n",cpuKernelImpl:Sc})},dm={kernelName:qe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;uu(a,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:u}=r;d(go(o,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const l=so(a.shape,s,o,1,i,u);if(1===l.filterWidth&&1===l.filterHeight&&g(l.inShape,l.outShape))return Id({inputs:{x:a},backend:n});const c=new $p(l,"max",!1);return n.runWebGLProgram(c,[a],a.dtype)}},pm={kernelName:"MaxPool3D",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:o,pad:i,dataFormat:u,dimRoundingMode:l}=r,c=oo(a.shape,s,o,[1,1,1],i,l,u),d=new Sp(c,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}};class hm{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,o=a-1-e.padInfo.top,i=s-1-e.padInfo.left,u=a*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class fm{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterDepth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=i-1-e.padInfo.front,d=u-1-e.padInfo.top,p=l-1-e.padInfo.left,h=i*u*l-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${p});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${i};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${o}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${l} +\n                  wR * ${l} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const mm={kernelName:"MaxPool3DGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,o=s,{filterSize:i,strides:u,pad:l,dimRoundingMode:c}=r,d=oo(o.shape,i,u,[1,1,1],l,c),p=new Sp(d,"max",!0),h=n.runWebGLProgram(p,[o],o.dtype),f=new fm(d),m=n.runWebGLProgram(f,[a,h],o.dtype);return n.disposeIntermediateTensorInfo(h),m}},gm={kernelName:"MaxPoolGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:o}=t,i=s;uu([s,o],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=r,p=so(i.shape,u,l,1,c,d),h=new $p(p,"max",!0),f=n.runWebGLProgram(h,[i],i.dtype),m=new hm(p),g=n.runWebGLProgram(m,[a,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}},xm={kernelName:"MaxPoolWithArgmax",backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:a,strides:s,pad:o,includeBatchInIndex:i}=t,u=n;d(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const l=[1,1];d(go(s,l),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`));const c=so(r.shape,a,s,l,o),[p,h]=function(e,t,n,r){let a=new $p(n,"max",!1);const s=r.runWebGLProgram(a,[e],"float32");return a=new $p(n,"max",!0,!0,t),[s,r.runWebGLProgram(a,[e],"float32")]}(r,i,c,u);return[p,h]}},bm={kernelName:Ke,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:a,axis:s}=t,o=n,i=r.shape.length,u=I(s,r.shape);let l=u;const c=ks(l,i),d=null!=c,p=o.shouldExecuteOnCPU([r]),h=[];let f=r;if(d){if(p){const e=o.texData.get(f.dataId).values,t=new Array(i);for(let e=0;e<t.length;e++)t[e]=r.shape[c[e]];const n=Qc(e,r.shape,r.dtype,c,t);f=o.makeTensorInfo(t,r.dtype),o.texData.get(f.dataId).values=n}else f=qd(r,c,o);h.push(f),l=$s(l.length,i)}Is("sum",l,i);const[g,x]=ws(f.shape,l);let b=g;a&&(b=vs(g,u));const y=function(e,t,n,r){const a=m(t),s=Ud({inputs:{x:e},attrs:{shape:[m(e.shape)/a,a]},backend:r}),o=Hd(s,"float32","mean",r),i=Ud({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}(f,x,b,o);for(const e of h)o.disposeIntermediateTensorInfo(e);return y}},ym={kernelName:Ye,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,i=a.shape.length,u=I(s,a.shape);let l=u;const c=ks(l,i);let d=a;null!=c&&(d=Qd({inputs:{x:a},backend:n,attrs:{perm:c}}),l=$s(l.length,a.shape.length)),Is("min",l,i);const[p,h]=ws(d.shape,l),f=Ud({inputs:{x:d},backend:n,attrs:{shape:[-1,m(h)]}}),g=Hd(f,f.dtype,"min",n);let x;return x=Ud(o?{inputs:{x:g},backend:n,attrs:{shape:vs(p,u)}}:{inputs:{x:g},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(d),x}},wm=Od({opSnippet:bd+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+wd+"\n  return result;\n",cpuKernelImpl:_c}),vm={kernelName:Qe,backendName:"webgl",kernelFunc:wm};class Im{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=$u(r),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${i}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class km{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=$u(r),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=ed("rc",r),u=ed("source",r),l=`${i[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,d="reflect"===n?0:1;let p="";if(1===r){const e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;p=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${i[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n      `}else{const e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;p=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${i[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${i[r-2]} += 1;\n        if(${i[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${u.join()}), ${c});\n          ${i[r-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${u.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const Cm={kernelName:Ze,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:a,mode:s}=n,o=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new km(r.shape,a,s):new Im(r.shape,a,s);return t.runWebGLProgram(o,[r],r.dtype)}},$m={kernelName:"Mod",backendName:"webgl",kernelFunc:Od({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+wd+"\n  return result;\n"})};class Sm{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const _m=Od({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),Em={kernelName:we,backendName:"webgl",kernelFunc:_m},Tm="return a - b;",Rm=Od({opSnippet:Tm,packedOpSnippet:Tm,supportsComplex:!0,cpuKernelImpl:qc}),Nm={kernelName:Ut,backendName:"webgl",kernelFunc:Rm};function Am(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,o=I([s],a.shape),i=um({inputs:{x:a},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),u=vs(i.shape,o),l=Ud({inputs:{x:i},backend:n,attrs:{shape:u}}),c=Rm({inputs:{a,b:l},backend:n}),d=of({inputs:{x:c},backend:n}),p=Kd({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:!1}}),h=Ud({inputs:{x:p},backend:n,attrs:{shape:u}}),f=_m({inputs:{a:d,b:h},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),f}const Fm={kernelName:Rt,backendName:"webgl",kernelFunc:Am},Om={kernelName:"Multinomial",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:o,normalized:i}=r,u=i?a:Am({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),l=u.shape[0],c=u.shape[1],d=new Sm(l,c,s),p=[[o]],h=n.runWebGLProgram(d,[u],"int32",p);return i||n.disposeIntermediateTensorInfo(u),h}},Dm=ud+"\n  return -x;\n",Mm={kernelName:et,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,a]=Tc(e.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,t)}let a;return a=H().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new hd(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new id(r.shape,Dm),n.runWebGLProgram(a,[r],r.dtype)}},Lm=function(e,t,n,r,a){return Za(e,t,n,r,a,0)},Pm={kernelName:nt,backendName:"webgl",kernelFunc:function(e){en("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=r,l=n.readSync(a.dataId),c=n.readSync(s.dataId),{selectedIndices:d}=Lm(l,c,o,i,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Bm=function(e,t,n,r,a,s){return Za(e,t,n,r,a,0,!1,s,!0)},Wm={kernelName:rt,backendName:"webgl",kernelFunc:function(e){en("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),{selectedIndices:p,validOutputs:h}=Bm(c,d,o,i,u,l);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}},Um=function(e,t,n,r,a,s){return Za(e,t,n,r,a,s,!0)},Vm={kernelName:at,backendName:"webgl",kernelFunc:function(e){en("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),p=o,h=i,f=u,m=l,{selectedIndices:g,selectedScores:x}=Um(c,d,p,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}};class Gm{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const zm={kernelName:ot,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:o,onValue:i,offValue:u}=r,l=m(a.shape),c=new Gm(l,o,i,u),d=Ud({inputs:{x:a},backend:n,attrs:{shape:[l]}}),p=n.runWebGLProgram(c,[d],s);n.disposeIntermediateTensorInfo(d);const h=Ud({inputs:{x:p},backend:n,attrs:{shape:[...a.shape,o]}});return n.disposeIntermediateTensorInfo(p),h}};function Hm(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=Xp({inputs:{input:r},backend:n}),t=Hm({inputs:{x:e},backend:n}),a=ih({inputs:{input:r},backend:n}),s=Hm({inputs:{x:a},backend:n}),o=Cd({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),o}return xf({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const jm={kernelName:qt,backendName:"webgl",kernelFunc:Hm},Xm={kernelName:st,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){const t=Xp({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=ih({inputs:{input:a},backend:r}),o=Hm({inputs:{x:s},backend:r}),i=Cd({inputs:{real:n,imag:o},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}return xf({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}},qm={kernelName:it,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return lf({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{p(s,e.shape,"All tensors passed to stack must have matching shapes"),d(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],u=ch({inputs:t.map((e=>{const t=lf({inputs:{input:e},backend:n,attrs:{dim:a}});return i.push(t),t})),backend:n,attrs:{axis:a}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}};class Km{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=$u(r),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${i}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class Ym{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=$u(r),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=ed("rc",r),u=ed("source",r),l=`${i[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,d=[`${a} rc = outputLoc;`,`${i[r-1]} += 1;\n       if(${l}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${i[r-2]} += 1;\n       if(${i[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${i[r-1]} += 1;\n         if(${l}) {`],p=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let h="";for(let e=0,t=1===r?2:4;e<t;e++)h+=`\n        ${d[e]}\n        if (${p}) {\n          result[${e}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${e}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;h+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}const Qm=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:o}=r;if(0===m(a.shape))return xf({backend:n,attrs:{shape:s.map(((e,t)=>e[0]+a.shape[t]+e[1])),value:o,dtype:a.dtype}});const i=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ym(a.shape,s,o):new Km(a.shape,s,o),u=[[o]];return n.runWebGLProgram(i,[a],a.dtype,u)},Zm={kernelName:ut,backendName:"webgl",kernelFunc:Qm},Jm=Od({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+wd+"\n  return result;\n"}),eg={kernelName:lt,backendName:"webgl",kernelFunc:Jm},tg={kernelName:dt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,i=a.shape.length,u=[],l=I(s,a.shape);let c=l;const d=ks(c,i);let p,h=a;if(null!=d&&(h=Qd({inputs:{x:a},backend:n,attrs:{perm:d}}),c=$s(c.length,i),u.push(h)),Is("prod",c,i),n.shouldExecuteOnCPU([h])){const e=n.texData.get(h.dataId).values,{outVals:t,outShape:r,outDtype:a}=Nc(h.shape,h.dtype,e,c);p=n.makeTensorInfo(r,a,t)}else{const[e,t]=ws(h.shape,c),r=m(t),s=Ud({inputs:{x:h},backend:n,attrs:{shape:[-1,r]}}),o=Hd(s,Yn(a.dtype),"prod",n);p=Ud({inputs:{x:o},backend:n,attrs:{shape:e}}),u.push(s),u.push(o)}if(o){u.push(p);const e=vs(p.shape,l);p=Ud({inputs:{x:p},backend:n,attrs:{shape:e}})}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}},ng={kernelName:"RaggedGather",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:o}=t,{outputRaggedRank:i}=r,u=a.map((e=>n.readSync(e.dataId))),l=a.map((e=>e.shape)),c=n.readSync(s.dataId),d=n.readSync(o.dataId),[p,h,f]=Ac(u,l,c,s.shape,s.dtype,d,o.shape,i),m=p.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,h);return m.concat([g])}},rg={kernelName:"RaggedTensorToTensor",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:o,rowPartitionTensors:i}=t,{rowPartitionTypes:u}=r,l=n.readSync(a.dataId),c=n.readSync(s.dataId),d=n.readSync(o.dataId),p=i.map((e=>n.readSync(e.dataId))),h=i.map((e=>e.shape)),[f,m]=Fc(l,a.shape,c,s.shape,s.dtype,d,o.shape,p,h,u);return n.makeTensorInfo(f,s.dtype,m)}},ag=e=>{const{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:o}=n,i=Oc(r,a,s,o);return t.makeTensorInfo([i.length],o,i)},sg={kernelName:pt,backendName:"webgl",kernelFunc:ag},og={kernelName:"Reciprocal",backendName:"webgl",kernelFunc:Fd({opSnippet:"return 1.0 / x;"})},ig=Fd({opSnippet:ud+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),ug={kernelName:ft,backendName:"webgl",kernelFunc:ig},lg=Fd({opSnippet:ud+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),cg={kernelName:bt,backendName:"webgl",kernelFunc:lg};class dg{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,o,i,u]=e;this.outputShape=[s,t,n,u];const l=[r&&t>1?o-1:o,r&&n>1?i-1:i],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class pg{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,u]=e;this.outputShape=[s,t,n,u];const l=[r&&t>1?o-1:o,r&&n>1?i-1:i],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${i}.0,\n                                     ${i}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const hg={kernelName:xt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:o,size:i}=r,[u,l]=i,c=H().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new pg(a.shape,u,l,s,o):new dg(a.shape,u,l,s,o);return n.runWebGLProgram(c,[a],"float32")}};class fg{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,s,o]=e,i=[n&&s>1?r-1:r,n&&o>1?a-1:a],u=[n&&s>1?s-1:s,n&&o>1?o-1:o],l=i[0]/u[0],c=i[1]/u[1],d=1/l,p=1/c,h=2*Math.ceil(d)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const mg={kernelName:"ResizeBilinearGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:o}=r,i=new fg(s.shape,a.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}};class gg{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,o,i,u]=e;this.outputShape=[s,t,n,u];const l=[r&&t>1?o-1:o,r&&n>1?i-1:i],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let p;p=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class xg{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,u]=e;this.outputShape=[s,t,n,u];const l=[r&&t>1?o-1:o,r&&n>1?i-1:i],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let p;p=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${i}.0,\n                                     ${i}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const bg={kernelName:gt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:o,size:i}=r,[u,l]=i,c=H().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new xg(a.shape,u,l,s,o):new gg(a.shape,u,l,s,o);return n.runWebGLProgram(c,[a],a.dtype)}};class yg{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,s,o]=e,i=[n&&s>1?r-1:r,n&&o>1?a-1:a],u=[n&&s>1?s-1:s,n&&o>1?o-1:o],l=i[0]/u[0],c=i[1]/u[1],d=1/l,p=1/c,h=2*Math.ceil(d)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${i[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${i[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const wg={kernelName:"ResizeNearestNeighborGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:o}=r,i=new yg(s.shape,a.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}};class vg{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),a=$u(n);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class Ig{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=ed("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,o=$u(n);function i(n){const r=e.map(((r,a)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(a,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${o} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return i(e)}(r.slice())};\n          if(${a}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",i(e)}(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",i(e)}(r.slice())};\n            if(${a}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",i(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const kg={kernelName:yt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,o=a.shape.length,i=I(s,a.shape);if(0===o)return Id({inputs:{x:a},backend:n});const u=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ig(a.shape,i):new vg(a.shape,i);return n.runWebGLProgram(u,[a],a.dtype)}};class Cg{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let a="";a="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const $g={kernelName:Yt,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:a,fillValue:s,center:o}=t,i=n,u=new Cg(r.shape,s),[l,c]=Mo(o,r.shape[1],r.shape[2]),d=[[l,c,Math.sin(a),Math.cos(a)]];return i.runWebGLProgram(u,[r],r.dtype,d)}},Sg=Fd({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),_g={kernelName:wt,backendName:"webgl",kernelFunc:Sg},Eg={kernelName:vt,backendName:"webgl",kernelFunc:Fd({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Dc})};class Tg{constructor(e,t,n,r,a,s,o=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const i=$u(a.length),u=$u(s.length);let l="";1===n?l="i":2===n&&(l="i, j");const c=`getIndices(${l})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const p=`getUpdates(${d})`,h=t>1?"strides[j]":"strides";this.userCode=`\n        ${i} strides = ${i}(${a});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${h};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const Rg={kernelName:It,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:o}=r,{sliceRank:i,numUpdates:u,sliceSize:l,strides:c,outputSize:d}=ia(0,a,o),p=[d/l,l];if(0===d)return n.makeTensorInfo(o,a.dtype);const h=Ud({inputs:{x:a},backend:n,attrs:{shape:[u,i]}}),f=Ud({inputs:{x:s},backend:n,attrs:{shape:[u,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new Tg(u,i,h.shape.length,f.shape.length,c,p),x=n.runWebGLProgram(g,[f,h,m],f.dtype),b=Ud({inputs:{x},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(m),b}};class Ng{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=2===H().getNumber("WEBGL_VERSION")?"while (left < right) {":a,o="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${s}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${o} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const Ag={kernelName:"SearchSorted",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:o}=r,i=new Ng(a.shape[0],a.shape[1],s.shape[1],o),u=[[a.shape[1]]];return n.runWebGLProgram(i,[a,s],"int32",u)}};class Fg{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],o=[];for(let r=0;r<t.length;r++)o.push(`${n[r]}`),r<e&&s.push(`${n[r]}`);r=s.join(),a=o.join()}const s=$u(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}}const Og={kernelName:kt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,o=new Fg(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(o,[r,a,s],Kn(a.dtype,s.dtype))}},Dg={kernelName:"Selu",backendName:"webgl",kernelFunc:Fd({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Vo};\n  float scale = ${Go};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`})},Mg=Fd({opSnippet:Ad+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Lc}),Lg={kernelName:$t,backendName:"webgl",kernelFunc:Mg},Pg={kernelName:"Sign",backendName:"webgl",kernelFunc:Fd({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"})},Bg={kernelName:"Sin",backendName:"webgl",kernelFunc:Fd({opSnippet:Ad+"\n  return sin(x);\n"})},Wg={kernelName:"Sinh",backendName:"webgl",kernelFunc:Fd({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"})},Ug={kernelName:"Softplus",backendName:"webgl",kernelFunc:Fd({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"})},Vg={kernelName:Et,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:o}=r;d(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((e,t)=>e*t)),u=[[0,0]];u.push(...o);for(let e=1+s.length;e<a.shape.length;++e)u.push([0,0]);const l=[],c=Qm({inputs:{x:a},backend:n,attrs:{paddings:u,constantValue:0}}),p=Lo(c.shape,s,i,!1),h=Po(p.length,s.length,!1),f=Bo(c.shape,s,i,!1),m=Ud({inputs:{x:c},backend:n,attrs:{shape:p}}),g=Qd({inputs:{x:m},backend:n,attrs:{perm:h}}),x=Ud({inputs:{x:g},backend:n,attrs:{shape:f}});return l.push(c),l.push(m),l.push(g),l.forEach((e=>n.disposeIntermediateTensorInfo(e))),x}},Gg={kernelName:Nt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:o}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const i=n.readSync(r.dataId),u=n.readSync(a.dataId),l=n.readSync(s.dataId),c=n.readSync(o.dataId)[0],[d,p,h,f,m]=Wc(i,r.shape,r.dtype,u,a.dtype,l,c);return[n.makeTensorInfo(p,r.dtype,d),n.makeTensorInfo([p[0]],a.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},zg={kernelName:At,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(n.readSync(a.dataId)),i=n.readSync(r.dataId),u=Array.from(n.readSync(s.dataId)),[l,c,d]=Uc(i,r.shape,r.dtype,o,u);return[n.makeTensorInfo(c,r.dtype,l),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}},Hg={kernelName:Ft,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);const o=n.readSync(r.dataId),i=n.readSync(a.dataId),u=n.readSync(s.dataId),[l,c]=Vc(o,r.shape,r.dtype,i,u,!0);return n.makeTensorInfo(c,r.dtype,l)}},jg={kernelName:Ot,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);const o=n.readSync(r.dataId),i=n.readSync(a.dataId),u=n.readSync(s.dataId),[l,c]=Vc(o,r.shape,r.dtype,i,u);return n.makeTensorInfo(c,r.dtype,l)}},Xg={kernelName:"SparseToDense",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:o}=t,{outputShape:i}=r,{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:p}=ia(0,a,i);if("string"===s.dtype){const e=n.bufferSync(a),t=n.bufferSync(s),r=En(n.readSync(o.dataId)[0]),h=Mc(e,t,i,p,c,l,u,d,r,!1);return n.makeTensorInfo(i,h.dtype,h.values)}const h=new Tg(l,u,a.shape.length,s.shape.length,d,[p,1],!1),f=n.runWebGLProgram(h,[s,a,o],s.dtype),m=Ud({inputs:{x:f},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(f),m}},qg={kernelName:Tt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:o}=r,i=I(o,a.shape)[0],u=pi(a,s,i),l=a.shape.length,c=new Array(l).fill(0),d=a.shape.slice();return u.map((e=>{const t=[...d];t[i]=e;const r=Wp({inputs:{x:a},backend:n,attrs:{begin:c,size:t}});return c[i]+=e,r}))}},Kg="return sqrt(x);",Yg=Fd({opSnippet:Kg,packedOpSnippet:Kg,cpuKernelImpl:Gc}),Qg={kernelName:St,backendName:"webgl",kernelFunc:Yg},Zg={kernelName:Mt,backendName:"webgl",kernelFunc:Fd({opSnippet:"return x * x;"})},Jg="return (a - b) * (a - b);",ex=Od({opSnippet:Jg,packedOpSnippet:Jg}),tx={kernelName:Dt,backendName:"webgl",kernelFunc:ex},nx={kernelName:Kt,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,a=ud+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,s=new id(r.shape,a);return n.runWebGLProgram(s,[r],r.dtype)}};class rx{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,a=$u(n.length),s=$u(n.length);let o="";if(1===r)o="coords * strides + begin";else{let e=0;o=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}const ax={kernelName:Lt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:o,strides:i,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:h}=r,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:x,isSimpleSlice:b,begin:y,end:w,strides:v}=ka(a.shape,s,o,i,u,l,c,p,h);let I;if(g)I=Ud({inputs:{x:a},backend:n,attrs:{shape:m}});else if(x||b){d(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=ca(y,w,v),t=Wp({inputs:{x:a},backend:n,attrs:{begin:y,size:e}});I=Ud({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else if(n.shouldExecuteOnCPU([a])){const e=n.readSync(a.dataId),t=Br(a.shape,a.dtype,e),r=zc(f,t,v,y);I=n.makeTensorInfo(m,a.dtype,r.values)}else{const e=new rx(y,v,f);I=n.runWebGLProgram(e,[a],a.dtype)}const k=Ud({inputs:{x:I},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(I),k}},sx={kernelName:Pt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:o,rightPad:i,padWidth:u,preserveShortSequences:l}=r,{data:c,dataSplits:d}=t,p=n.readSync(c.dataId),h=n.readSync(d.dataId),[f,m]=Hc(p,h,a,s,o,i,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}},ox={kernelName:Bt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:o}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const i=n.readSync(s.dataId),u=n.readSync(o.dataId)[0],[l,c,d]=jc(i,u,a),p=c.length;return[n.makeTensorInfo([p,2],"int32",l),n.makeTensorInfo([p],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}},ix={kernelName:Wt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(s.dataId),i=Xc(o,a);return n.makeTensorInfo(s.shape,"int32",i)}},ux={kernelName:"Tan",backendName:"webgl",kernelFunc:Fd({opSnippet:"return tan(x);"})},lx={kernelName:Vt,backendName:"webgl",kernelFunc:Fd({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"})};class cx{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const r=$u(this.rank),a=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}}function dx(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){const e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>En(e))):e,r=Br(a.shape,a.dtype,t),o=Kc(r,s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new cx(a.shape,s);return n.runWebGLProgram(o,[a],a.dtype)}const px={kernelName:Gt,backendName:"webgl",kernelFunc:dx};class hx{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class fx{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function mx(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function gx(e){let t=1;for(;t<e;)t*=2;return t}const xx={kernelName:zt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:o}=r,i=H().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=H().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=a.shape,c=l[l.length-1];if(n.shouldExecuteOnCPU([a])||c<i||s>u){const e=n.readSync(a.dataId),[t,r]=Yc(e,l,a.dtype,s,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return l[l.length-1]=0,[n.makeTensorInfo(l,a.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(1===c)return[a,xf({attrs:{shape:l,dtype:"int32",value:0},backend:n})];const d=n.texData.get(a.dataId),p=null!==d&&d.isPacked,h=p?n.unpackTensor(a):a,f=m(l)/c,g=Ud({inputs:{x:h},attrs:{shape:[f,c]},backend:n});p&&mx(n,h);const x=gx(s),b=gx(c);let y=null;const w=()=>null===y?[g,g]:[g,y],v=(e,t,r)=>{const a=w(),s=new hx(r),o=[[c],[null===y?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],i=y;y=n.runWebGLProgram(s,a,"int32",o),mx(n,i)};for(let e=1;e<x;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)v(t,n,[f,b])}for(let e=b;e>x;e/=2){const t=w(),r=new fx([f,e/2]),a=[[c],[null===y?1:0],[x]],s=y;y=n.runWebGLProgram(r,t,"int32",a),mx(n,s);const o=x/2,i=2*o;for(let e=o;e>=1;e/=2)v(i,e,y.shape)}let I=y;y=Wp({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,s]}}),mx(n,I);let k=Df({inputs:{x:g,indices:y},backend:n,attrs:{axis:1,batchDims:1}});mx(n,g);const C=l.slice(0,-1);C.push(s),I=y,y=Ud({inputs:{x:y},attrs:{shape:C},backend:n}),mx(n,I);const $=k;return k=Ud({inputs:{x:k},attrs:{shape:C},backend:n}),mx(n,$),[k,y]}};class bx{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const o="nearest"===n?1:2;let i;switch(r){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${i} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const yx={kernelName:Ht,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:o,fillMode:i,fillValue:u,outputShape:l}=r,[c,d,p,h]=a.shape,[f,m]=null!=l?l:[d,p],g=new bx(d,p,o,i,u,[c,f,m,h]);return n.runWebGLProgram(g,[a,s],"float32")}},wx={kernelName:"Unique",backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;uu(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(s.dataId),{outputValues:i,outputShape:u,indices:l}=Zc(o,a,s.shape,s.dtype);return[r.makeTensorInfo(u,s.dtype,i),r.makeTensorInfo([l.length],"int32",l)]}},vx={kernelName:Xt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const o=a,i=o.shape.length,u=a.shape[s],l=new Array(i-1);let c=0;for(let e=0;e<i;e++)e!==s&&(l[c++]=o.shape[e]);const d=[],p=new Array(i).fill(0),h=o.shape.slice();h[s]=1;const f=new Array(u);for(let e=0;e<f.length;e++){p[s]=e;const t=Wp({inputs:{x:o},backend:n,attrs:{begin:p,size:h}}),r=Ud({inputs:{x:t},backend:n,attrs:{shape:l}});f[e]=r,d.push(t)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class Ix{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,o=s*Math.ceil(a/n);this.outputShape=[r,o];const i=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let c="";a%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let d="";a%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}const kx=[ep,np,rp,ap,ip,cp,dp,pp,bp,yp,wp,vp,Ip,kp,Cp,_p,Ep,Np,Ap,Fp,Mp,Vp,Gp,zp,Kp,Qp,eh,$d,rh,dh,yh,Ch,$h,Sh,_h,Eh,Th,Rh,Ah,Ph,Bh,Wh,Vh,Hh,qh,Kh,Qh,Jh,ef,nf,rf,af,sf,uf,cf,pf,mf,bf,wf,If,Cf,_f,Rf,Nf,Ff,Mf,Pf,Wf,kd,Uf,uh,Vf,Gf,zf,Ed,Hf,Xf,qf,Yf,Zf,em,tm,nm,sm,im,lm,cm,dm,pm,mm,gm,xm,bm,ym,vm,Cm,$m,Om,Wd,Mm,Pm,Wm,Vm,jp,zm,Xm,qm,Zm,eg,Nd,tg,ng,rg,sg,qp,Em,og,ug,cg,Vd,hg,mg,bg,wg,kg,$g,_g,Eg,Rg,Ag,Og,Dg,Lg,Pg,Bg,Wg,Up,Fm,Ug,Vg,Gg,zg,Hg,jg,Xg,qg,Qg,Zg,tx,nx,ax,sx,ox,ix,Nm,Yd,ux,lx,px,xx,yx,Zd,wx,vx,{kernelName:"UnsortedSegmentSum",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:o}=r,i=a.shape.length,u=[];let l=0;const c=ks([l],i);let d=a;null!=c&&(d=Qd({inputs:{x:a},backend:n,attrs:{perm:c}}),u.push(d),l=$s(1,i)[0]);const p=Si(d.shape,l,o),h=m([d.shape[l]]),f=Ud({inputs:{x:d},backend:n,attrs:{shape:[-1,h]}});u.push(f);const g=Yn(a.dtype),x=(e,t,r,a,s)=>{const o=e.shape[0],i=e.shape[1],l=$i(i,s),c=new Ix({windowSize:l,inSize:i,batchSize:o,numSegments:s},t),d=n.compileAndRun(c,[e,r],a);if(u.push(d),d.shape[1]===s)return d;const p=ag({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),h=dx({inputs:{x:p},backend:n,attrs:{reps:[i/l]}});return u.push(p),u.push(h),x(d,t,h,a,s)},b=Ud({inputs:{x:x(f,"unsortedSegmentSum",s,g,o)},backend:n,attrs:{shape:p}});let y=b;if(null!=c){u.push(b);const e=Cs(c);y=Qd({inputs:{x:y},backend:n,attrs:{perm:e}})}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}},jm];for(const e of kx)un(e);var Cx,$x;let Sx;!function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"}(Cx||(Cx={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"}($x||($x={}));const _x={kernelName:Qt,backendName:"wasm",setupFunc:function(e){Sx=e.wasm.cwrap(Qt,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:o,preluActivationWeights:i}=t;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");const{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=r,p=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(s.dataId).id;let f=0;if(null!=o){const e=n.dataIdMap.get(o.dataId);if(1!==e.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);f=e.id}const m=null==i?0:n.dataIdMap.get(i.dataId).id,g=$x[c];if(null==g)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);const x=u?a.shape[2]:a.shape[1],b=l?s.shape[1]:s.shape[2],y=ra(a.shape.slice(0,-2),s.shape.slice(0,-2)),w=n.makeOutput([...y,x,b],a.dtype),v=n.dataIdMap.get(w.dataId).id,I=new Uint8Array(new Int32Array(a.shape).buffer),k=new Uint8Array(new Int32Array(s.shape).buffer);return Sx(p,I,a.shape.length,h,k,s.shape.length,u,l,g,f,m,d||0,v),w}};function Ex(e,t){let n;return{kernelName:e,backendName:"wasm",setupFunc:function(t){n=t.wasm.cwrap(e,null,["number","number","number"])},kernelFunc:function(e){const{backend:r,inputs:{x:a}}=e,s=r.dataIdMap.get(a.dataId).id,o=r.makeOutput(a.shape,t||a.dtype),i=r.dataIdMap.get(o.dataId).id;return 0===m(o.shape)||n(s,Cx[a.dtype],i),o}}}const Tx=Ex(Y);function Rx(e,t,n){let r;return{kernelName:e,backendName:"wasm",setupFunc:function(t){r=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a}=e,{a:s,b:o}=a,i=t.dataIdMap.get(s.dataId).id,u=t.dataIdMap.get(o.dataId).id,l=null!=n?n:s.dtype,c=ra(s.shape,o.shape),d=t.makeOutput(c,l);if(0===m(c))return d;const p=new Uint8Array(new Int32Array(s.shape).buffer),h=new Uint8Array(new Int32Array(o.shape).buffer),f=t.dataIdMap.get(d.dataId).id;return r(i,p,s.shape.length,u,h,o.shape.length,Cx[s.dtype],f),d}}}const Nx=Rx(Q);let Ax;const Fx={kernelName:Z,backendName:"wasm",setupFunc:function(e){Ax=e.wasm.cwrap(Z,null,["array","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(0===m(r.shape))return r;const a=t.map((e=>n.dataIdMap.get(e.dataId).id)),s=new Uint8Array(new Int32Array(a).buffer),o=n.dataIdMap.get(r.dataId).id;return Ax(s,a.length,Cx[r.dtype],o),r}};function Ox(e){const{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}const Dx={kernelName:De,backendName:"wasm",kernelFunc:Ox};let Mx;function Lx(e){const{inputs:t,backend:n,attrs:r}=e,[a,s]=function(e,t){const n=[],r=[];for(let a=0;a<e.length;++a)1!==e[a]&&n.push(e[a]),1!==e[t[a]]&&r.push(t[a]);for(let e=0;e<r.length;++e){let t=-1;for(let n=0;n<r.length;++n)r[n]>=e&&(-1===t||r[t]>r[n])&&(t=n);r[t]=e}return[n,r]}(t.x.shape,r.perm);let o=!0;for(let e=0;e<s.length;e++)s[e]!==e&&(o=!1);const i=function(e,t){const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}(t.x.shape,r.perm),u={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(o){const e=Ox({inputs:t,backend:n});return e.shape=i,e}const l=n.makeOutput(i,u.dtype),c=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(l.dataId).id,p=new Uint8Array(new Int32Array(s).buffer),h=new Uint8Array(new Int32Array(u.shape).buffer);return Mx(c,h,u.shape.length,Cx[u.dtype],d,p,s.length),l}const Px={kernelName:jt,backendName:"wasm",kernelFunc:Lx,setupFunc:function(e){Mx=e.wasm.cwrap(jt,null,["number","array","number","number","number","array","number"])}};function Bx(e,t,n){const r=e.shape,a=e.shape.length,s=I(t,r);let o=s;const i=ks(o,a);let u=null,l=!1;if(null!=i){const t=new Array(a);for(let e=0;e<t.length;e++)t[e]=r[i[e]];o=$s(o.length,a),u=Lx({inputs:{x:e},attrs:{perm:i},backend:n});const s=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(u.dataId).id!==s&&(l=!0)}return{transposed:u,originalAxes:s,axes:o,inputWasTransposed:l}}let Wx;const Ux={kernelName:J,backendName:"wasm",setupFunc:function(e){Wx=e.wasm.cwrap(J,null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:o}=n;let i=t.dataIdMap.get(o.dataId).id,u=o;const{transposed:l,axes:c,originalAxes:d,inputWasTransposed:p}=Bx(o,a,t);p&&(u=l,i=t.dataIdMap.get(l.dataId).id),Is("all",c,u.shape.length);const[h,f]=ws(u.shape,c),g=m(f),x=t.makeOutput(h,o.dtype);if(0!==m(u.shape)){const e=t.dataIdMap.get(x.dataId).id;Wx(i,g,e)}if(p&&t.disposeData(l.dataId),s){const e=vs(x.shape,d);x.shape=e}return x}};let Vx;const Gx={kernelName:ee,backendName:"wasm",setupFunc:function(e){Vx=e.wasm.cwrap(ee,null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:o}=n;let i=t.dataIdMap.get(o.dataId).id,u=o;const{transposed:l,axes:c,originalAxes:d,inputWasTransposed:p}=Bx(o,a,t);p&&(u=l,i=t.dataIdMap.get(l.dataId).id),Is("any",c,u.shape.length);const[h,f]=ws(u.shape,c),g=m(f),x=t.makeOutput(h,o.dtype);if(0!==m(u.shape)){const e=t.dataIdMap.get(x.dataId).id;Vx(i,g,e)}if(p&&t.disposeData(l.dataId),s){const e=vs(x.shape,d);x.shape=e}return x}};let zx;const Hx={kernelName:te,backendName:"wasm",kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{axis:a}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id;let i=o,u=s;const{transposed:l,axes:c,inputWasTransposed:d}=Bx(s,a,t);if(d){const e=t.dataIdMap.get(l.dataId).id;e!==o&&(u=l,i=e)}const p=u.shape.slice(0,-1),h=t.makeOutput(p,"int32"),f=t.dataIdMap.get(h.dataId).id,g=m(h.shape),x=u.shape[c[0]];return zx(i,Cx[u.dtype],g,x,f),d&&t.disposeData(l.dataId),h},setupFunc:function(e){zx=e.wasm.cwrap(te,null,["number","number","number","number","number"])}};let jx;const Xx={kernelName:ne,backendName:"wasm",setupFunc:function(e){jx=e.wasm.cwrap(ne,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id,{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=n,c=so(a.shape,o,i,1,u,l),d=c.filterHeight,p=c.filterWidth,h=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,x=c.strideHeight,b=c.strideWidth,y=c.inChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(1!==c.dilationWidth||1!==c.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);const w=r.makeOutput(c.outShape,"float32"),v=r.dataIdMap.get(w.dataId).id;return jx(s,a.shape[0],a.shape[1],a.shape[2],d,p,h,f,m,g,x,b,y,v),w}};function qx(e){const{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,s=m(r.shape),o=v(a,s);return d(s===m(o),(()=>`new shape: ${o}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`)),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:o,dtype:r.dtype}}const Kx={kernelName:mt,backendName:"wasm",kernelFunc:qx};let Yx;const Qx={kernelName:re,backendName:"wasm",setupFunc:function(e){Yx=e.wasm.cwrap(re,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:o,transposeB:i}=r;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");const u=a.shape.length,l=s.shape.length,c=o?a.shape[u-2]:a.shape[u-1],p=i?s.shape[l-1]:s.shape[l-2],h=o?a.shape[u-1]:a.shape[u-2],f=i?s.shape[l-2]:s.shape[l-1],g=a.shape.slice(0,-2),x=s.shape.slice(0,-2),b=m(g),y=m(x),w=ra(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,f]);d(c===p,(()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${o} and transposeB=${i} must match.`));const v=i?[y,f,p]:[y,p,f],I=qx({inputs:{x:a},backend:n,attrs:{shape:o?[b,c,h]:[b,h,c]}}),k=qx({inputs:{x:s},backend:n,attrs:{shape:v}}),C=n.dataIdMap.get(I.dataId).id,$=n.dataIdMap.get(k.dataId).id,S=o?I.shape[2]:I.shape[1],_=i?k.shape[1]:k.shape[2],E=Math.max(b,y),T=n.makeOutput([E,S,_],I.dtype),R=n.dataIdMap.get(T.dataId).id,N=new Uint8Array(new Int32Array(I.shape).buffer),A=new Uint8Array(new Int32Array(k.shape).buffer);return Yx(C,N,I.shape.length,$,A,k.shape.length,o,i,R),n.disposeData(I.dataId),n.disposeData(k.dataId),T.shape=w,T}};function Zx(e){const{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[s,o]=Ia(t,n,r),i=wa(t.shape,s,o),u=a.readSync(t.dataId),l=a.makeOutput(o,t.dtype),c=F(t.shape),d=a.dataIdMap.get(l.dataId);if(i){const e=va(s,c);return"string"===t.dtype?d.stringBytes=u.slice(e,e+m(o)):a.typedArrayFromHeap(l).set(u.subarray(e,e+m(o))),l}if("string"===t.dtype){const e=Vl(u,s,o,t.shape,t.dtype);return d.stringBytes=e,l}const p=a.typedArrayFromHeap(l),h=t.shape.length;if(2===h)!function(e,t,n,r,a){let s=0;const o=r[0],i=r[1],u=o+a[0];for(let r=o;r<u;r++){const o=r*t+i;n.set(e.subarray(o,o+a[1]),s),s+=a[1]}}(u,c[0],p,s,o);else if(3===h)!function(e,t,n,r,a,s){let o=0;const i=a[0],u=a[1],l=a[2],c=i+s[0],d=u+s[1];for(let a=i;a<c;a++)for(let i=u;i<d;i++){const u=a*t+i*n+l;r.set(e.subarray(u,u+s[2]),o),o+=s[2]}}(u,c[0],c[1],p,s,o);else if(4===h)!function(e,t,n,r,a,s,o){let i=0;const u=s[0],l=s[1],c=s[2],d=u+o[0],p=l+o[1],h=c+o[2],f=s[3];for(let s=u;s<d;s++)for(let u=l;u<p;u++)for(let l=c;l<h;l++){const c=s*t+u*n+l*r+f;a.set(e.subarray(c,c+o[3]),i),i+=o[3]}}(u,c[0],c[1],c[2],p,s,o);else{const e=Vl(u,s,o,t.shape,t.dtype);p.set(e)}return l}const Jx={kernelName:Ct,backendName:"wasm",kernelFunc:Zx},eb={kernelName:ae,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:o}=r,i=s.reduce(((e,t)=>e*t)),u=Lo(a.shape,s,i),l=Po(u.length,s.length),c=Bo(a.shape,s,i),d=Wo(o,s.length),p=Uo(c,o,s.length),h=qx({inputs:{x:a},backend:n,attrs:{shape:u}}),f=Lx({inputs:{x:h},backend:n,attrs:{perm:l}}),m=Zx({inputs:{x:qx({inputs:{x:f},backend:n,attrs:{shape:c}})},backend:n,attrs:{begin:d,size:p}});return n.disposeData(h.dataId),n.disposeData(f.dataId),n.disposeData(h.dataId),m}};function tb(e){const{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),s=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(s),a}const nb={kernelName:oe,backendName:"wasm",kernelFunc:tb},rb=Ex(ie);let ab;const sb={kernelName:ue,backendName:"wasm",setupFunc:function(e){ab=e.wasm.cwrap(ue,null,["number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:o}=r,i=n.dataIdMap.get(a.dataId).id,u=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(u.dataId).id;return ab(i,s,o,l),u}};function ob(e){const{inputs:t,backend:n}=e,r=I(e.attrs.axis,t[0].shape)[0];no(t.map((e=>e.shape)),r);let a=ro(t.map((e=>e.shape)),r);const s=t.filter((e=>m(e.shape)>0));if(1===s.length)return Ox({inputs:{x:s[0]},backend:n});const o=n.makeOutput(a,t[0].dtype);if(0===m(a))return o;if("string"===s[0].dtype){const e=s.map((e=>{const t=m(e.shape.slice(r));return qx({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),i=e.map((e=>({vals:n.readSync(e.dataId),shape:e.shape})));a=ro(e.map((e=>e.shape)),1);const u=1===e[0].shape[0],l=ll(i,a,t[0].dtype,u),c=ro(s.map((e=>e.shape)),r);return o.shape=c,n.dataIdMap.get(o.dataId).stringBytes=Ti(l),e.forEach((e=>n.disposeData(e.dataId))),o}const i=m(s[0].shape.slice(0,r));let u=0;const l=s.map((e=>{const t=m(e.shape.slice(r));return u+=t,t})),c=s.map((e=>n.typedArrayFromHeap(e))),d=n.typedArrayFromHeap(o);for(let e=0;e<i;e++){let t=e*u;for(let n=0;n<c.length;n++){const r=l[n],a=e*r,s=c[n].subarray(a,a+r);d.set(s,t),t+=r}}return o}const ib={kernelName:de,backendName:"wasm",kernelFunc:ob};let ub;const lb={kernelName:pe,backendName:"wasm",setupFunc:function(e){ub=e.wasm.cwrap(pe,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,o=r.dataIdMap.get(a.dataId).id,i=r.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:d,dataFormat:p}=n,h=xo(p),f=io(a.shape,s.shape,u,l,c,d,!1,h),m=f.filterHeight,g=f.filterWidth,x=f.padInfo.top,b=f.padInfo.right,y=f.padInfo.bottom,w=f.padInfo.left,v=f.dilationHeight,I=f.dilationWidth,k=f.strideHeight,C=f.strideWidth,$=f.inChannels,S=f.outChannels,_="SAME"===f.padInfo.type?1:0;if("channelsLast"!==f.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);const E=r.makeOutput(f.outShape,"float32"),T=r.dataIdMap.get(E.dataId).id;return ub(o,a.shape[0],a.shape[1],a.shape[2],i,m,g,x,b,y,w,_,v,I,k,C,$,S,T),E}};let cb;const db={kernelName:he,backendName:"wasm",setupFunc:function(e){cb=e.wasm.cwrap(he,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:s}=n,{strides:o,pad:i,dataFormat:u,dimRoundingMode:l,inputShape:c}=r,d=xo(u),p=io(c,s.shape,o,1,i,l,!1,d),{batchSize:h,filterHeight:f,filterWidth:m,inChannels:g,inHeight:x,inWidth:b,outChannels:y,outHeight:w,outWidth:v,strideHeight:I,strideWidth:k}=p,C=f-1-p.padInfo.top,$=m-1-p.padInfo.left,S="channelsLast"===p.dataFormat,_=F(p.inShape),E=F(a.shape),[T,R,N]=F(s.shape),A=_[0],O=S?_[1]:_[2],D=S?_[2]:1,M=S?1:_[1],L=E[0],P=S?E[1]:E[2],B=S?E[2]:1,W=S?1:E[1],U=t.makeOutput(p.inShape,"float32"),V=t.dataIdMap.get(U.dataId).id,G=t.dataIdMap.get(a.dataId).id,z=t.dataIdMap.get(s.dataId).id;return cb(G,z,h,f,m,x,b,g,w,v,y,I,k,C,$,T,R,N,A,O,D,M,L,P,B,W,V),U}},pb=Ex("Cos"),hb=Ex(fe);var fb;let mb;!function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"}(fb||(fb={}));const gb={kernelName:xe,backendName:"wasm",setupFunc:function(e){mb=e.wasm.cwrap(xe,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{method:a,extrapolationValue:s,cropSize:o}=r,{image:i,boxes:u,boxInd:l}=n,c=u.shape[0],[d,p]=o,h=[c,d,p,i.shape[3]];let f,m=t.dataIdMap.get(i.dataId);"float32"!==i.dtype&&(f=tb({backend:t,inputs:{x:i},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(f.dataId));const g=m.id,x=t.dataIdMap.get(u.dataId).id,b=t.dataIdMap.get(l.dataId).id,y=t.makeOutput(h,"float32"),w=t.dataIdMap.get(y.dataId).id,v=new Uint8Array(new Int32Array(i.shape).buffer);return mb(g,x,b,c,v,d,p,fb[a],s,w),null!=f&&t.disposeData(f.dataId),y}};let xb;const bb={kernelName:me,backendName:"wasm",setupFunc:function(e){xb=e.wasm.cwrap(me,null,["number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r,u=a.shape.length;d("float32"===a.dtype||"int32"===a.dtype,(()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`));const l=ks([s],u);let c=a;null!==l&&(c=Lx({inputs:{x:a},attrs:{perm:l},backend:n}));const p=$s(1,u)[0];Is("cumprod",[p],u);const h=n.makeOutput(c.shape,c.dtype),f=c.shape[p],m=n.dataIdMap.get(c.dataId).id,g=n.dataIdMap.get(h.dataId).id;xb(m,o?1:0,i?1:0,f,g,Cx[a.dtype]);let x=h;return null!==l&&(x=Lx({inputs:{x:h},attrs:{perm:Cs(l)},backend:n}),n.disposeData(c.dataId),n.disposeData(h.dataId)),x}};let yb;const wb={kernelName:ge,backendName:"wasm",setupFunc:function(e){yb=e.wasm.cwrap(ge,null,["number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r,u=a.shape.length;d("float32"===a.dtype||"int32"===a.dtype,(()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`));const l=ks([s],u);let c=a;null!==l&&(c=Lx({inputs:{x:a},attrs:{perm:l},backend:n}));const p=$s(1,u)[0];Is("cumsum",[p],u);const h=n.makeOutput(c.shape,c.dtype),f=c.shape[p],m=n.dataIdMap.get(c.dataId).id,g=n.dataIdMap.get(h.dataId).id;yb(m,o?1:0,i?1:0,f,g,Cx[a.dtype]);let x=h;return null!==l&&(x=Lx({inputs:{x:h},attrs:{perm:Cs(l)},backend:n}),n.disposeData(c.dataId),n.disposeData(h.dataId)),x}};let vb;const Ib={kernelName:be,backendName:"wasm",setupFunc:function(e){vb=e.wasm.cwrap(be,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:s,dataFormat:o}=r,i=a.shape[0],u=("NHWC"===o?a.shape[1]:a.shape[2])*s,l=("NHWC"===o?a.shape[2]:a.shape[3])*s,c=("NHWC"===o?a.shape[3]:a.shape[1])/(s*s),d="NHWC"===o?[i,u,l,c]:[i,c,u,l],p=t.makeOutput(d,"float32"),h=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(F(a.shape)).buffer),m=new Uint8Array(new Int32Array(d).buffer),g=new Uint8Array(new Int32Array(F(d)).buffer),x=t.dataIdMap.get(p.dataId).id;return vb(h,s,"NHWC"===o?1:0,f,a.shape.length-1,m,g,d.length,x),p}};let kb;const Cb={kernelName:ye,backendName:"wasm",setupFunc:function(e){kb=e.wasm.cwrap(ye,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,o=r.dataIdMap.get(a.dataId).id,i=r.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:d}=n,p=null==l?[1,1]:l,h=io(a.shape,s.shape,u,p,c,d,!0),f=h.filterHeight,m=h.filterWidth,g=h.padInfo.top,x=h.padInfo.right,b=h.padInfo.bottom,y=h.padInfo.left,w=h.dilationHeight,v=h.dilationWidth,I=h.strideHeight,k=h.strideWidth,C=h.inChannels,$=h.outChannels,S="SAME"===h.padInfo.type?1:0;if("channelsLast"!==h.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);const _=r.makeOutput(h.outShape,"float32"),E=r.dataIdMap.get(_.dataId).id;return kb(o,a.shape[0],a.shape[1],a.shape[2],i,f,m,g,x,b,y,S,w,v,I,k,C,$,E),_}},$b=Ex(ve),Sb=Rx(Ie,0,"bool"),_b=Ex(ke,"float32");function Eb(e){const{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:s}=n,o=a.shape.length,i=a.shape.slice();let u=s;return s<0&&(d(-(o+1)<=s,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),u=o+s+1),i.splice(u,0,1),qx({inputs:{x:a},backend:r,attrs:{shape:i}})}const Tb={kernelName:Ce,backendName:"wasm",kernelFunc:Eb};function Rb(e){const{attrs:{shape:t,value:n,dtype:r},backend:a}=e,s=a.makeOutput(t,r);return a.typedArrayFromHeap(s).fill(n),s}const Nb={kernelName:Se,backendName:"wasm",kernelFunc:Rb};let Ab;const Fb={kernelName:_e,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),s=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,[i,u,l,c]=r.shape;return Ab(s,i,u,l,c,o),a},setupFunc:function(e){Ab=e.wasm.cwrap(_e,null,["number","number","number","number","number","number"])}},Ob=Ex(Ee),Db=Rx(Te);let Mb;const Lb={kernelName:Re,backendName:"wasm",setupFunc:function(e){Mb=e.wasm.cwrap(Re,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:s,mean:o,variance:i,offset:u,scale:l}=n,c=t.dataIdMap.get(s.dataId).id,d=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(i.dataId).id,h=null!=u?t.dataIdMap.get(u.dataId).id:0,f=null!=l?t.dataIdMap.get(l.dataId).id:0,g=t.makeOutput(s.shape,s.dtype);if(0===m(s.shape))return g;const x=t.dataIdMap.get(g.dataId).id;return Mb(c,d,p,h,f,a,x),g}};let Pb;const Bb={kernelName:Zt,backendName:"wasm",setupFunc:function(e){Pb=e.wasm.cwrap(Zt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dilations:c,dataFormat:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=n,m=io(a.shape,s.shape,u,c,l,p),g=$x[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);const x=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,y=m.outChannels;let w=0;if(null!=o){const e=r.dataIdMap.get(o.dataId);if(1!==e.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==y)throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${y})`);w=e.id}const v=m.filterHeight,I=m.filterWidth,k=m.padInfo.top,C=m.padInfo.right,$=m.padInfo.bottom,S=m.padInfo.left,_=m.dilationHeight,E=m.dilationWidth,T=m.strideHeight,R=m.strideWidth,N=m.inChannels,A="SAME"===m.padInfo.type?1:0,F=m.batchSize,O=m.inHeight,D=m.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);const M=r.makeOutput(m.outShape,"float32"),L=r.dataIdMap.get(M.dataId).id,P=null==i?0:r.dataIdMap.get(i.dataId).id;return Pb(x,F,O,D,b,v,I,w,k,C,$,S,A,_,E,T,R,N,y,g,P,f||0,L),M}};let Wb;const Ub={kernelName:Jt,backendName:"wasm",setupFunc:function(e){Wb=e.wasm.cwrap(Jt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dilations:c,dataFormat:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=n,m=io(a.shape,s.shape,u,c,l,p,!0),g=$x[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);const x=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,y=m.outChannels;let w=0;if(null!=o){const e=r.dataIdMap.get(o.dataId);if(1!==e.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==y)throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${y})`);w=e.id}const v=m.filterHeight,I=m.filterWidth,k=m.padInfo.top,C=m.padInfo.right,$=m.padInfo.bottom,S=m.padInfo.left,_=m.dilationHeight,E=m.dilationWidth,T=m.strideHeight,R=m.strideWidth,N=m.inChannels,A="SAME"===m.padInfo.type?1:0,F=m.batchSize,O=m.inHeight,D=m.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);const M=r.makeOutput(m.outShape,"float32"),L=r.dataIdMap.get(M.dataId).id,P=null==i?0:r.dataIdMap.get(i.dataId).id;return Wb(x,F,O,D,b,v,I,w,k,C,$,S,A,_,E,T,R,N,y,g,P,f||0,L),M}};let Vb;const Gb={kernelName:Ae,backendName:"wasm",setupFunc:function(e){Vb=e.wasm.cwrap(Ae,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function(e){const{backend:t,inputs:n}=e,{params:r,indices:a}=n,[s,o,i,u]=aa(r,a),l=t.makeOutput(s,r.dtype);if(0===o)return l;const c=a.shape,d=c[c.length-1],p=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(u).buffer),m=t.dataIdMap.get(l.dataId).id;return Vb(p,Cx[r.dtype],h,o,d,i,f,m),l}};let zb;const Hb={kernelName:Ne,backendName:"wasm",setupFunc:function(e){zb=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{x:a,indices:s}=n,{axis:o,batchDims:i}=r,u=I(o,a.shape)[0],l=t.readSync(s.dataId),c=a.shape[u];for(let e=0;e<l.length;++e){const t=l[e];d(t<=c-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${c-1}]`))}const p=_i(a,s,u,i),h=qx({inputs:{x:a},attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]},backend:t}),f=m(s.shape),g=qx({inputs:{x:s},attrs:{shape:[p.batchSize,f/p.batchSize]},backend:t}),x=[p.batchSize,p.outerSize,f/p.batchSize,p.sliceSize],b=t.makeOutput(x,a.dtype);if(0===m(a.shape))return b;const y=h.shape.length-1,w=t.dataIdMap.get(h.dataId).id,v=t.dataIdMap.get(g.dataId).id,k=t.dataIdMap.get(b.dataId).id,C=new Uint8Array(new Int32Array(F(h.shape)).buffer),$=new Uint8Array(new Int32Array(F(x)).buffer);return zb(w,Cx[a.dtype],C,y,v,p.batchSize,$,k),t.disposeData(h.dataId),t.disposeData(g.dataId),b.shape=p.outputShape,b}},jb=Rx(Fe,0,"bool"),Xb=Rx(Oe,0,"bool");let qb;const Kb={kernelName:Pe,backendName:"wasm",setupFunc:function(e){qb=e.wasm.cwrap(Pe,null,["number","number","number","number"])},kernelFunc:function(e){const{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,s=r.makeOutput(t.shape,"float32");if(0!==m(t.shape)){const e=r.dataIdMap.get(s.dataId).id;qb(a,Cx[t.dtype],n,e)}return s}},Yb=Rx(Be,0,"bool"),Qb=Rx(We,0,"bool"),Zb=Ex(Ue),Jb=Rx(Ge,0,"bool"),ey=Ex(ze),ty=Rx(He,0,"bool"),ny=Rx("LogicalXor",0,"bool");let ry;const ay={kernelName:je,backendName:"wasm",setupFunc:function(e){ry=e.wasm.cwrap(je,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:s}=r,{x:o}=n;let i=t.dataIdMap.get(o.dataId).id,u=o;const{transposed:l,axes:c,originalAxes:d,inputWasTransposed:p}=Bx(o,a,t);p&&(u=l,i=t.dataIdMap.get(l.dataId).id),Is("max",c,u.shape.length);const[h,f]=ws(u.shape,c),g=m(f),x=t.makeOutput(h,o.dtype);if(0!==m(u.shape)){const e=t.dataIdMap.get(x.dataId).id;ry(i,Cx[o.dtype],g,e)}if(p&&t.disposeData(l.dataId),s){const e=vs(x.shape,d);x.shape=e}return x}},sy=Rx(Xe);let oy;const iy={kernelName:qe,backendName:"wasm",setupFunc:function(e){oy=e.wasm.cwrap(qe,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id;d("float32"===a.dtype,(()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`));const{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=n,c=so(a.shape,o,i,1,u,l),p=c.filterHeight,h=c.filterWidth,f=c.padInfo.top,m=c.padInfo.right,g=c.padInfo.bottom,x=c.padInfo.left,b=c.dilationHeight,y=c.dilationWidth,w=c.strideHeight,v=c.strideWidth,I=c.inChannels,k=c.outChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);const C=r.makeOutput(c.outShape,"float32"),$=r.dataIdMap.get(C.dataId).id;return oy(s,a.shape[0],a.shape[1],a.shape[2],p,h,f,m,g,x,b,y,w,v,I,k,$),C}};let uy;const ly={kernelName:Ke,backendName:"wasm",setupFunc:function(e){uy=e.wasm.cwrap(Ke,null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:o}=n,i=t.dataIdMap.get(o.dataId).id;let u=i,l=o;const{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=Bx(o,a,t);let f=d;if(h){const e=t.dataIdMap.get(c.dataId).id;e!==i&&(l=c,u=e,f=$s(f.length,l.shape.length))}Is("mean",f,l.shape.length);const[g,x]=ws(l.shape,f),b=m(x);let y=l;"float32"!==l.dtype&&(y=tb({backend:t,inputs:{x:l},attrs:{dtype:"float32"}}),u=t.dataIdMap.get(y.dataId).id);const w=t.makeOutput(g,"float32");if(0!==m(l.shape)){const e=t.dataIdMap.get(w.dataId).id;uy(u,b,e)}if(h&&t.disposeData(c.dataId),s){const e=vs(w.shape,p);w.shape=e}return"float32"!==l.dtype&&t.disposeData(y.dataId),w}};let cy;const dy={kernelName:Ye,backendName:"wasm",setupFunc:function(e){cy=e.wasm.cwrap(Ye,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:o}=n,i=t.dataIdMap.get(o.dataId).id;let u=i,l=o;const{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=Bx(o,a,t);if(h){const e=t.dataIdMap.get(c.dataId).id;e!==i&&(l=c,u=e)}Is("min",d,l.shape.length);const[f,g]=ws(l.shape,d),x=m(g),b=t.makeOutput(f,l.dtype);if(0!==m(l.shape)){const e=t.dataIdMap.get(b.dataId).id;cy(u,Cx[o.dtype],x,e)}if(h&&t.disposeData(c.dataId),s){const e=vs(b.shape,p);b.shape=e}return b}},py=Rx(Qe);var hy;let fy;!function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"}(hy||(hy={}));const my={kernelName:Ze,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1])),o=n.dataIdMap.get(t.dataId).id,i=n.makeOutput(s,t.dtype),u=n.dataIdMap.get(i.dataId).id,l=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map((e=>e[0])),d=r.map((e=>e[1])),p=new Uint8Array(new Int32Array(c).buffer),h=new Uint8Array(new Int32Array(d).buffer);return fy(o,l,t.shape.length,Cx[t.dtype],p,h,hy[a],u),i},setupFunc:function(e){fy=e.wasm.cwrap(Ze,null,["number","array","number","number","array","array","number","number"])}},gy=Rx(Je),xy=Ex(et);function by(e,t){const n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],s=n[2],o=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:s,pValidOutputs:o}}let yy;const wy={kernelName:nt,backendName:"wasm",setupFunc:function(e){yy=e.wasm.cwrap(nt,"number",["number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:o}=r,{boxes:i,scores:u}=n,l=t.dataIdMap.get(i.dataId).id,c=t.dataIdMap.get(u.dataId).id,d=yy(l,c,s,a,o),{pSelectedIndices:p,selectedSize:h,pSelectedScores:f,pValidOutputs:m}=by(t,d);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([h],"int32",p)}};let vy;const Iy={kernelName:rt,backendName:"wasm",setupFunc:function(e){vy=e.wasm.cwrap(rt,"number",["number","number","number","number","number","bool"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:o,padToMaxOutputSize:i}=r,{boxes:u,scores:l}=n,c=t.dataIdMap.get(u.dataId).id,d=t.dataIdMap.get(l.dataId).id,p=vy(c,d,s,a,o,i),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=by(t,p);return t.wasm._free(m),[t.makeOutput([f],"int32",h),t.makeOutput([],"int32",g)]}};let ky;const Cy={kernelName:at,backendName:"wasm",setupFunc:function(e){ky=e.wasm.cwrap(at,"number",["number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:o,softNmsSigma:i}=r,{boxes:u,scores:l}=n,c=t.dataIdMap.get(u.dataId).id,d=t.dataIdMap.get(l.dataId).id,p=ky(c,d,s,a,o,i),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=by(t,p);return t.wasm._free(g),[t.makeOutput([f],"int32",h),t.makeOutput([f],"float32",m)]}},$y=Rx(tt,0,"bool");let Sy;const _y={kernelName:ot,backendName:"wasm",setupFunc:function(e){Sy=e.wasm.cwrap(ot,null,["number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:o,onValue:i,offValue:u}=r,l=n.makeOutput([...a.shape,o],s),c=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(a.dataId).id;return Sy(d,o,i,u,c),l}},Ey={kernelName:st,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}},Ty={kernelName:it,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return Eb({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{p(s,e.shape,"All tensors passed to stack must have matching shapes"),d(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],u=ob({inputs:t.map((e=>{const t=Eb({inputs:{input:e},backend:n,attrs:{dim:a}});return i.push(t),t})),backend:n,attrs:{axis:a}});return i.forEach((e=>n.disposeData(e.dataId))),u}};let Ry;const Ny={kernelName:ut,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1]));if(0===m(t.shape))return Rb({backend:n,attrs:{shape:s,value:a,dtype:t.dtype}});const o=n.dataIdMap.get(t.dataId).id,i=n.makeOutput(s,t.dtype),u=n.dataIdMap.get(i.dataId).id,l=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map((e=>e[0])),d=r.map((e=>e[1])),p=new Uint8Array(new Int32Array(c).buffer),h=new Uint8Array(new Int32Array(d).buffer);return Ry(o,l,t.shape.length,Cx[t.dtype],p,h,a,u),i},setupFunc:function(e){Ry=e.wasm.cwrap(ut,null,["number","array","number","number","array","array","number","number"])}},Ay=Rx(lt);let Fy;const Oy={kernelName:ct,backendName:"wasm",setupFunc:function(e){Fy=e.wasm.cwrap(ct,null,["number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id;let i=s;const u=r;let l=u;"float32"!==u.dtype&&(l=tb({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),i=n.dataIdMap.get(l.dataId).id);const c=n.makeOutput(r.shape,"float32"),d=n.dataIdMap.get(c.dataId).id;return Fy(i,o,d),"float32"!==u.dtype&&n.disposeData(l.dataId),c}};let Dy;const My={kernelName:dt,backendName:"wasm",setupFunc:function(e){Dy=e.wasm.cwrap(dt,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:o}=n,i=t.dataIdMap.get(o.dataId).id;let u=i,l=o;const{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=Bx(o,a,t);let f=d;if(h){const e=t.dataIdMap.get(c.dataId).id;e!==i&&(l=c,u=e,f=$s(f.length,l.shape.length))}Is("prod",f,l.shape.length);const[g,x]=ws(l.shape,f),b=m(x),y=t.makeOutput(g,l.dtype);if(0!==m(l.shape)){const e=t.dataIdMap.get(y.dataId).id;Dy(u,b,Cx[y.dtype],e)}if(h&&t.disposeData(c.dataId),s){const e=vs(y.shape,p);y.shape=e}return y}},Ly={kernelName:pt,backendName:"wasm",kernelFunc:e=>{const{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:o}=n,i=Pl(r,a,s,o),u=t.makeOutput([i.length],o);return t.typedArrayFromHeap(u).set(i),u}},Py=Rx(we),By=Ex(ft),Wy=Ex(bt);let Uy;const Vy={kernelName:xt,backendName:"wasm",setupFunc:function(e){Uy=e.wasm.cwrap(xt,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:o,size:i}=r,[u,l]=i,[c,d,p,h]=a.shape,f=[c,u,l,h];let g,x=t.dataIdMap.get(a.dataId);"float32"!==x.dtype&&(g=tb({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),x=t.dataIdMap.get(g.dataId));const b=x.id,y=t.makeOutput(f,"float32");if(0===m(a.shape))return y;const w=t.dataIdMap.get(y.dataId).id;return Uy(b,c,d,p,h,u,l,s?1:0,o?1:0,w),null!=g&&t.disposeData(g.dataId),y}};let Gy;const zy={kernelName:gt,backendName:"wasm",setupFunc:function(e){Gy=e.wasm.cwrap(gt,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:o,size:i}=r,[u,l]=i,[c,d,p,h]=a.shape,f=[c,u,l,h],g=t.makeOutput(f,"float32");if(0===m(a.shape))return g;let x,b=t.dataIdMap.get(a.dataId);"float32"!==b.dtype&&(x=tb({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),b=t.dataIdMap.get(x.dataId));const y=b.id,w=t.dataIdMap.get(g.dataId).id;return Gy(y,c,d,p,h,u,l,s?1:0,o?1:0,w),null!=x&&t.disposeData(x.dataId),g}};let Hy;const jy={kernelName:yt,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,o=I(s,a.shape);if(0===a.shape.length)return Ox({inputs:{x:a},backend:n});const i=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(i.dataId).id,c=new Uint8Array(new Int32Array(o).buffer),d=new Uint8Array(new Int32Array(a.shape).buffer);Hy(u,c,o.length,d,a.shape.length,l);const p=qx({inputs:{x:i},attrs:{shape:a.shape},backend:n});return n.disposeData(i.dataId),p},setupFunc:function(e){Hy=e.wasm.cwrap(yt,null,["number","array","number","array","number","number"])}};let Xy;const qy={kernelName:Yt,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:s,fillValue:o,center:i}=r,u=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,c=n.dataIdMap.get(u.dataId).id,[d,p,h,f]=a.shape,[m,g]=Mo(i,p,h),x="number"==typeof o?[o,o,o,0===o?0:255]:[...o,255],b=new Uint8Array(new Int32Array(x).buffer);return Xy(l,d,p,h,f,s,m,g,b,x.length,c),u},setupFunc:function(e){Xy=e.wasm.cwrap(Yt,null,["number","number","number","number","number","number","number","number","array","number","number"])}},Ky=Ex(wt),Yy=Ex(vt);let Qy;const Zy={kernelName:It,backendName:"wasm",setupFunc:function(e){Qy=e.wasm.cwrap(It,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:s}=n,{shape:o}=r,i=t.makeOutput(o,s.dtype);if(0===m(o))return i;const{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:p}=ia(0,a,o),h=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(s.dataId).id,g=new Uint8Array(new Int32Array(d).buffer),x=t.dataIdMap.get(i.dataId).id;return Qy(h,f,Cx[s.dtype],u,l,c,g,p,x),i}};let Jy;const ew={kernelName:kt,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,o=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(s.dataId).id,l=n.makeOutput(a.shape,a.dtype),c=n.dataIdMap.get(l.dataId).id,d=r.shape.length,p=a.shape.length,h=0===d||d>1||1===p?1:m(a.shape.slice(1));return Jy(o,i,u,h,c),l},setupFunc:function(e){Jy=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}};let tw;const nw={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function(e){tw=e.wasm.cwrap($t,null,["number","number"])},kernelFunc:function(e){const{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(a.dataId).id;return 0===m(a.shape)||tw(r,s),a}},rw=Ex("Sin");let aw;const sw={kernelName:Rt,backendName:"wasm",setupFunc:function(e){aw=e.wasm.cwrap(Rt,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),o=t.dataIdMap.get(s.dataId).id,i=n.shape[r],u=m(n.shape)/i;return 0===m(s.shape)||aw(a,o,i,u),s}},ow={kernelName:Et,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:o}=r,i=m(s),u=[[0,0]];u.push(...o);for(let e=1+s.length;e<a.shape.length;++e)u.push([0,0]);const l=Ny.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:u,constantValue:0}}),c=Lo(l.shape,s,i,!1),d=Po(c.length,s.length,!1),p=Bo(l.shape,s,i,!1),h=qx({inputs:{x:l},backend:n,attrs:{shape:c}}),f=Lx({inputs:{x:h},backend:n,attrs:{perm:d}}),g=qx({inputs:{x:f},backend:n,attrs:{shape:p}});return n.disposeData(l.dataId),n.disposeData(h.dataId),n.disposeData(f.dataId),g}};let iw;const uw={kernelName:Nt,backendName:"wasm",setupFunc:function(e){iw=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n}=e,{indices:r,values:a,denseShape:s,defaultValue:o}=n,i=r.shape[0],u=r.shape[1],l=t.readSync(s.dataId)[0],c=[i+l,u],d=t.dataIdMap.get(r.dataId).id,p=t.dataIdMap.get(a.dataId).id,h=t.dataIdMap.get(o.dataId).id,f=t.makeOutput(c,r.dtype),m=t.dataIdMap.get(f.dataId).id,g=t.makeOutput(c.slice(0,1),a.dtype),x=t.dataIdMap.get(g.dataId).id,b=t.makeOutput([l],"bool"),y=t.dataIdMap.get(b.dataId).id,w=t.makeOutput([i],r.dtype),v=t.dataIdMap.get(w.dataId).id,I=t.makeOutput([4],"int32"),k=t.dataIdMap.get(I.dataId).id,C=iw(d,p,Cx[a.dtype],i,l,u,h,m,x,y,v,k),$=t.readSync(I.dataId);let S;switch($[0]){case 1:S=hi($[1]);break;case 2:S=fi($[1],$[2]);break;case 3:S=mi($[1],$[2],$[3]);break;default:S=""}if(t.disposeData(I.dataId),S)throw t.disposeData(f.dataId),t.disposeData(g.dataId),t.disposeData(b.dataId),t.disposeData(w.dataId),new Error(S);let _=f,E=g;return C!==c[0]&&(_=Zx({inputs:{x:f},attrs:{begin:0,size:[C,u]},backend:t}),E=Zx({inputs:{x:g},attrs:{begin:0,size:C},backend:t}),t.disposeData(f.dataId),t.disposeData(g.dataId)),[_,E,b,w]}};let lw;const cw={kernelName:At,backendName:"wasm",setupFunc:function(e){lw=e.wasm.cwrap(At,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:s}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=t.dataIdMap.get(r.dataId).id,i=t.dataIdMap.get(a.dataId).id,u=t.dataIdMap.get(s.dataId).id,l=r.shape[0],c=m(s.shape),d=t.makeOutput([l,c],r.dtype),p=t.dataIdMap.get(d.dataId).id,h=t.makeOutput([c],s.dtype),f=t.dataIdMap.get(h.dataId).id,g=t.makeOutput([3],"int32"),x=t.dataIdMap.get(g.dataId).id;lw(o,i,u,l,p,f,x);const b=t.readSync(g.dataId);let y;switch(b[0]){case 0:y=gi(b[1],b[2]);break;case 1:y=xi(b[1],b[2]);break;case 2:y="reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";break;case 3:y=yi(Array.from(t.readSync(a.dataId)),Array.from(t.readSync(h.dataId)));break;case 4:y=wi(Array.from(t.readSync(a.dataId)),Array.from(t.readSync(h.dataId)));break;default:y=""}if(t.disposeData(g.dataId),y)throw t.disposeData(d.dataId),t.disposeData(h.dataId),new Error(y);return[d,h]}};let dw;function pw(e){dw=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function hw(e,t){const{backend:n,inputs:r}=e,{data:a,indices:s,segmentIds:o}=r,i=s.shape[0],u=n.readSync(o.dataId,i-1,i)[0],l=i>0?u+1:0;if(l<0)throw new Error("segment ids must be >= 0");const c=a.shape.slice();c[0]=l;const d=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(s.dataId).id,h=n.dataIdMap.get(o.dataId).id,f=n.makeOutput(c,a.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),x=n.dataIdMap.get(g.dataId).id;dw(d,Cx[a.dtype],a.shape[0],p,h,m,x,t,0);const b=n.readSync(g.dataId);let y;switch(b[0]){case 0:y="segment ids must be >= 0";break;case 1:y="segment ids are not increasing";break;case 2:y=ki(b[1],b[2]);break;case 3:y=Ci(b[1],b[2],b[3]);break;default:y=""}if(n.disposeData(g.dataId),y)throw n.disposeData(f.dataId),new Error(y);return f}const fw={kernelName:Ft,backendName:"wasm",setupFunc:pw,kernelFunc:function(e){return hw(e,!0)}},mw={kernelName:Ot,backendName:"wasm",setupFunc:pw,kernelFunc:function(e){return hw(e,!1)}},gw={kernelName:Tt,backendName:"wasm",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:o}=n,i=I(o,a.shape)[0],u=pi(a,s,i),l=new Array(a.shape.length).fill(0),c=a.shape.slice();return u.map((e=>{const t=[...c];t[i]=e;const n=Zx({inputs:{x:a},attrs:{begin:l,size:t},backend:r});return l[i]+=e,n}))}},xw=Ex(St),bw=Ex(Mt),yw=Rx(Dt);let ww;const vw={kernelName:Kt,backendName:"wasm",setupFunc:function(e){ww=e.wasm.cwrap(Kt,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,i=t.makeOutput(s.shape,s.dtype),u=t.dataIdMap.get(i.dataId).id;return ww(o,a,Cx[s.dtype],u),i}};let Iw;const kw={kernelName:Lt,backendName:"wasm",setupFunc:function(e){Iw=e.wasm.cwrap(Lt,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{begin:s,end:o,strides:i,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:h}=r,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:x,isSimpleSlice:b,begin:y,end:w,strides:v}=ka(a.shape,s,o,i,u,l,c,p,h);let I;if(g)I=qx({inputs:{x:a},backend:t,attrs:{shape:m}});else if(x||b){d(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=ca(y,w,v),n=Zx({inputs:{x:a},backend:t,attrs:{begin:y,size:e}});I=qx({inputs:{x:n},backend:t,attrs:{shape:m}}),t.disposeData(n.dataId)}else{const e=t.makeOutput(f,"float32"),n=t.dataIdMap.get(a.dataId).id,r=new Uint8Array(new Int32Array(F(a.shape)).buffer),s=new Uint8Array(new Int32Array(y).buffer),o=new Uint8Array(new Int32Array(w).buffer),i=new Uint8Array(new Int32Array(v).buffer),u=new Uint8Array(new Int32Array(f).buffer),l=new Uint8Array(new Int32Array(F(f)).buffer),c=t.dataIdMap.get(e.dataId).id;Iw(n,r,a.shape.length,s,o,i,u,l,f.length,c),I=qx({inputs:{x:e},backend:t,attrs:{shape:m}}),t.disposeData(e.dataId)}return I}},Cw={kernelName:Pt,backendName:"wasm",kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{data:a,dataSplits:s}=n,{separator:o,nGramWidths:i,leftPad:u,rightPad:l,padWidth:c,preserveShortSequences:d}=r,p=t.readSync(a.dataId),h=t.readSync(s.dataId),[f,m]=Yl(p,h,o,i,u,l,c,d),g=t.makeOutput([f.length],"string");t.dataIdMap.get(g.dataId).stringBytes=f;const x=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(x).set(m),[g,x]}},$w={kernelName:Bt,backendName:"wasm",kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{input:a,delimiter:s}=n,{skipEmpty:o}=r,i=t.readSync(a.dataId),u=t.readSync(s.dataId),[l,c,d]=Zl(i,u[0],o),p=c.length,h=t.makeOutput([p,2],"int32");t.typedArrayFromHeap(h).set(l);const f=t.makeOutput([p],"string");t.dataIdMap.get(f.dataId).stringBytes=c;const m=t.makeOutput([2],"int32");return t.typedArrayFromHeap(m).set(d),[h,f,m]}},Sw={kernelName:Wt,backendName:"wasm",kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{input:a}=n,{numBuckets:s}=r,o=Jl(t.readSync(a.dataId),s),i=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(i).set(o),i}},_w=Rx(Ut);let Ew;const Tw={kernelName:_t,backendName:"wasm",setupFunc:function(e){Ew=e.wasm.cwrap(_t,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:o}=n,i=t.dataIdMap.get(o.dataId).id;let u=i,l=o;const{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=Bx(o,a,t);let f=d;if(h){const e=t.dataIdMap.get(c.dataId).id;e!==i&&(l=c,u=e,f=$s(f.length,l.shape.length))}Is("sum",f,l.shape.length);const[g,x]=ws(l.shape,f),b=m(x),y=t.makeOutput(g,l.dtype);if(0!==m(l.shape)){const e=t.dataIdMap.get(y.dataId).id;Ew(u,b,Cx[y.dtype],e)}if(h&&t.disposeData(c.dataId),s){const e=vs(y.shape,p);y.shape=e}return y}},Rw=Ex("Tan"),Nw=Ex(Vt);let Aw;let Fw;let Ow;const Dw=[_x,Tx,Nx,Fx,Ux,Gx,Hx,Xx,Qx,eb,nb,rb,sb,ib,lb,db,pb,hb,gb,bb,wb,Ib,Cb,$b,Sb,_b,Tb,Nb,Fb,Ob,Db,Lb,Bb,Ub,Gb,Hb,jb,Xb,Dx,Kb,Yb,Qb,Zb,Jb,ey,ty,ny,ay,sy,iy,ly,dy,py,my,gy,xy,wy,Iy,Cy,$y,_y,Ey,Ty,Ny,Ay,Oy,My,Ly,Py,By,Wy,Kx,Vy,zy,jy,qy,Ky,Yy,Zy,ew,nw,rw,Jx,sw,ow,uw,cw,fw,mw,gw,xw,bw,yw,vw,kw,Cw,$w,Sw,_w,Tw,Rw,Nw,{kernelName:Gt,backendName:"wasm",setupFunc:function(e){Aw=e.wasm.cwrap(Gt,null,["number","array","number","array","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,s=n.dataIdMap.get(a.dataId).id,{reps:o}=r,i=new Array(a.shape.length);for(let e=0;e<i.length;e++)i[e]=a.shape[e]*o[e];const u=new Uint8Array(new Int32Array(a.shape).buffer),l=new Uint8Array(new Int32Array(i).buffer),c=n.makeOutput(i,a.dtype),d=n.dataIdMap.get(c.dataId).id;return Aw(s,u,a.shape.length,l,i.length,Cx[c.dtype],d),c}},{kernelName:zt,backendName:"wasm",setupFunc:function(e){Fw=e.wasm.cwrap(zt,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{k:a,sorted:s}=n,o=t.dataIdMap.get(r.dataId).id,i=new Uint8Array(new Int32Array(r.shape).buffer),u=r.shape.slice();u[u.length-1]=a;const l=t.makeOutput(u,r.dtype),c=t.dataIdMap.get(l.dataId).id,d=t.makeOutput(u,"int32"),p=t.dataIdMap.get(d.dataId).id;return Fw(o,i,r.shape.length,Cx[r.dtype],a,s,c,p),[l,d]}},{kernelName:Ht,backendName:"wasm",setupFunc:function(e){Ow=e.wasm.cwrap(Ht,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{image:a,transforms:s}=n,{interpolation:o,fillMode:i,fillValue:u,outputShape:l}=r,[c,d,p,h]=a.shape,[f,m]=null!=l?l:[d,p],g=[c,f,m,h],x=new Uint8Array(new Int32Array(F(a.shape)).buffer),b=new Uint8Array(new Int32Array(F(g)).buffer),y=t.makeOutput(g,a.dtype),w=t.dataIdMap.get(y.dataId).id,v=t.dataIdMap.get(a.dataId).id,I=t.dataIdMap.get(s.dataId).id,k="nearest"===o?1:2;let C;switch(i){case"constant":default:C=1;break;case"reflect":C=2;break;case"wrap":C=3;break;case"nearest":C=4}return Ow(v,I,s.shape[0]>1,c,f,m,h,p,d,x,a.shape.length-1,b,g.length-1,k,C,u,w),y}},Px,{kernelName:Xt,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const o=a.shape[s],i=a.shape.length,u=new Array(i-1);let l=0;for(let e=0;e<i;e++)e!==s&&(u[l++]=a.shape[e]);const c=new Array(o),d=new Array(i).fill(0),p=a.shape.slice();p[s]=1;for(let e=0;e<c.length;e++)d[s]=e,c[e]=Zx({inputs:{x:a},attrs:{begin:d,size:p},backend:n});return c.map((({dataId:e,dtype:t})=>({dataId:e,dtype:t,shape:u})))}},{kernelName:qt,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}}];for(const e of Dw)un(e);const Mw=H();Mw.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(e){return!1}})),Mw.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(Mw.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}}));var Lw=n(349),Pw=n.n(Lw),Bw=n(142),Ww=n(234),Uw=n.n(Ww);const Vw=Pw()||Lw,Gw=Uw()||Ww;class zw extends o{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(Kw),Yw=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new s(this,Os())}write(e,t,n){const r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){const t=Sn();return e(),{kernelMs:Sn()-t}}move(e,t,n,r,a){const s=this.dataIdNextNumber++;if("string"===r){const o=t;return void this.dataIdMap.set(e,{id:s,stringBytes:o,shape:n,dtype:r,memoryOffset:null,refCount:a})}const o=m(n),i=o*E(r),u=this.wasm._malloc(i);this.dataIdMap.set(e,{id:s,memoryOffset:u,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(s,o,u),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,i),u)}async read(e){return this.readSync(e)}readSync(e,t,n){const{memoryOffset:r,dtype:a,shape:s,stringBytes:o}=this.dataIdMap.get(e);if("string"===a)return null!=t&&0!==t||!(null==n||n>=o.length)?o.slice(t,n):o;t=t||0,n=n||m(s);const i=E(a);return function(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}(this.wasm.HEAPU8.slice(r+t*i,r+n*i).buffer,a)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){const n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){const t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n){let r;if(null==n)r=this.write(null,e,t);else{const a=this.dataIdNextNumber++;r={id:a},this.dataIdMap.set(r,{id:a,memoryOffset:n,shape:e,dtype:t,refCount:1});const s=m(e);this.wasm.tfjs.registerTensor(a,s,n)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){const r=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(n),s=m(e);switch(t){case"float32":return new Float32Array(r,a,s);case"int32":return new Int32Array(r,a,s);case"bool":return new Uint8Array(r,a,s);default:throw new Error(`Unknown dtype ${t}`)}}}function Hw(e,t,n){if(null!=jw)return jw;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),null!=Xw&&null!=Xw[r]?Xw[r]:n+r}let jw=null,Xw={},qw=!1,Kw=-1,Yw=null;var Qw,Zw;async function Jw(e,t){let n=0;const r=[];for(;;){const{done:a,value:s}=await e.read();if(a)break;r.push(s),n+=s.length,t(s.length)}const a=new Uint8Array(n);let s=0;for(const e of r)a.set(e,s),s+=e.length;return a}async function ev(e,t,n,r){const a=await r([e,t],n);return{box:a[0],lan:a[1]}}async function tv(e,t,n){return{...await ev(e,t,n,nv),modelType:"tfjs"}}async function nv(e,t){return async function(e,t,n){const r=[],a=function(e){let t=0,n=0;return()=>{let r=!0,a=0;return(s,o)=>{t-=a,t+=s,a=s,r&&(n+=o,r=!1),e(t,n)}}}(t);for(const t of e)r.push(n(t,a()));return Promise.all(r)}(e,t,rv)}async function rv(e,t){const n=H().platform.fetch,r=await n(e),a=await r.blob(),s=await a.text(),o=JSON.parse(s).weightsManifest[0].paths,i=e.substring(0,e.lastIndexOf("/")+1),u=o.map((e=>i+e)),l=await async function(e,t){const n=e.map((e=>fetch(e))),r=await Promise.all(n),a=r.map((e=>+e.headers.get("Content-Length"))),s=a.reduce(((e,t)=>e+t)),o=[];t(0,s);let i=0;for(let e=0;e<a.length;++e)o.push(Jw(r[e].body.getReader(),(e=>{i+=e,t(i,s)})));const u=await Promise.all(o),l=new Map;for(let t=0;t<a.length;++t)l.set(e[t],new Blob([u[t]]));return{blobs:l}}(u,t);return l.blobs.set(e,a),l}Ms("wasm",(async()=>{const{wasm:e}=await async function(){const[e,t]=await Promise.all([H().getAsync("WASM_HAS_SIMD_SUPPORT"),H().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((n,r)=>{const a={locateFile:(n,r)=>{if(n.endsWith(".worker.js")){const e=Bw.g.replace(/\n/g,"\\n"),t=new Blob([e],{type:"application/javascript"});return URL.createObjectURL(t)}return n.endsWith(".wasm")?Hw(e,t,r):r+n}};let s,o=!1;a.onAbort=()=>{o||qw||(qw=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},t&&e&&null==jw?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+Vw.toString()],{type:"text/javascript"}),s=Vw(a)):s=Gw(a),s.then((e=>{o=!0,qw=!1,e.tfjs={init:e.cwrap("init",null,[]),initWithThreadsCount:e.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:e.cwrap("get_threads_count","number",[]),registerTensor:e.cwrap("register_tensor",null,["number","number","number"]),disposeData:e.cwrap("dispose_data",null,["number"]),dispose:e.cwrap("dispose",null,[])},n({wasm:e})})).catch(r)}))}();return new zw(e)}),2),H().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(Qw||(Qw={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(Zw||(Zw={}));new Set(Object.values({ABORT_ERROR:"AbortError",NOT_ALLOWED_ERROR:"NotAllowedError",NOT_FOUND_ERROR:"NotFoundError",NOT_READABLE_ERROR:"NotReadableError",OVERCONSTRAINTED_ERROR:"OverconstrainedError",SECURITY_ERROR:"SecurityError",TYPE_ERROR:"TypeError"}));var av=function(e,t,n,r){return new(n||(n=Promise))((function(a,s){function o(e){try{u(r.next(e))}catch(e){s(e)}}function i(e){try{u(r.throw(e))}catch(e){s(e)}}function u(e){var t;e.done?a(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,i)}u((r=r.apply(e,t||[])).next())}))},sv=function(e,t){var n,r,a,s,o={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(i){return function(u){return function(i){if(n)throw new TypeError("Generator is already executing.");for(;s&&(s=0,i[0]&&(o=0)),o;)try{if(n=1,r&&(a=2&i[0]?r.return:i[0]?r.throw||((a=r.return)&&a.call(r),0):r.next)&&!(a=a.call(r,i[1])).done)return a;switch(r=0,a&&(i=[2&i[0],a.value]),i[0]){case 0:case 1:a=i;break;case 4:return o.label++,{value:i[1],done:!1};case 5:o.label++,r=i[1],i=[0];continue;case 7:i=o.ops.pop(),o.trys.pop();continue;default:if(!((a=(a=o.trys).length>0&&a[a.length-1])||6!==i[0]&&2!==i[0])){o=0;continue}if(3===i[0]&&(!a||i[1]>a[0]&&i[1]<a[3])){o.label=i[1];break}if(6===i[0]&&o.label<a[1]){o.label=a[1],a=i;break}if(a&&o.label<a[2]){o.label=a[2],o.ops.push(i);break}a[2]&&o.ops.pop(),o.trys.pop();continue}i=t.call(e,o)}catch(e){i=[6,e],r=0}finally{n=a=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,u])}}};const ov=function(e,t,n){var r=this;this.video=null,this.canvas=null,this.activeCameraID=null,this.artboardSize={height:0,width:0},this.devices=null,this.stream=null,this.calculateSize=function(e,t){var n=e.width/e.height;return t.width/t.height<n?{width:t.height*n,height:t.height}:{width:t.width,height:t.width/n}},this.initCamera=function(e,t,n,a){return av(r,void 0,void 0,(function(){var r,s;return sv(this,(function(o){switch(o.label){case 0:return this.stream&&this.stream.getTracks().forEach((function(e){return e.stop()})),r={audio:!1,video:{facingMode:"user",width:t,height:n,frameRate:{max:a},deviceId:e}},[4,navigator.mediaDevices.getUserMedia(r)];case 1:return s=o.sent(),this.stream=s,this.activeCameraID=s.getTracks().map((function(e){return e.getSettings().deviceId}))[0],this.video.srcObject=s,[2]}}))}))},this.startUp=function(e){return void 0===e&&(e=""),av(r,void 0,void 0,(function(){return sv(this,(function(t){switch(t.label){case 0:return[4,this.initCamera(e,this.artboardSize[0],this.artboardSize[1],30)];case 1:return t.sent(),[4,this.video.play()];case 2:return t.sent(),this.video.addEventListener("loadeddata",(function(e){console.log("Camera is ready")})),this.renderCanvas(),[2]}}))}))},this.renderCanvas=function(){var e=r.canvas.getContext("2d");if(requestAnimationFrame(r.renderCanvas),r.canvas.width=r.canvas.scrollWidth,r.canvas.height=r.canvas.scrollHeight,r.video.readyState===r.video.HAVE_ENOUGH_DATA){var t={width:r.video.videoWidth,height:r.video.videoHeight},n={width:r.canvas.width,height:r.canvas.height},a=r.calculateSize(t,n),s=(n.height-a.height)/2,o=(n.width-a.width)/2;e.drawImage(r.video,o,s,a.width,a.height)}},this.video=t,this.canvas=n,navigator.mediaDevices.enumerateDevices().then((function(e){r.devices=e.filter((function(e){return"videoinput"===e.kind}))})),this.artboardSize={width:e.offsetWidth,height:e.offsetHeight},window.addEventListener("resize",(function(){r.artboardSize={width:e.offsetWidth,height:e.offsetHeight}}))},iv=function(){function e(){var e=this;this.cursor=null,this.setCursorVisibility=function(t){e.cursor.style.display=t?"block":"none"},this.cursor=document.createElement("div"),this.cursor.style.width="20px",this.cursor.style.height="20px",this.cursor.style.backgroundColor="blue",this.cursor.style.position="fixed",this.cursor.style.top="100px",this.cursor.style.left="100px",document.body.appendChild(this.cursor)}return e.prototype.setCursorColor=function(e){this.cursor.style.backgroundColor=e},e.prototype.setCursorPosition=function(e,t){this.cursor.style.top=window.innerHeight*t+"px",this.cursor.style.left=window.innerWidth*e+"px"},e}();var uv,lv,cv,dv,pv;uv=document.querySelector("#app"),lv=void 0,cv=void 0,pv=function(){var e,t,n;return function(e,t){var n,r,a,s,o={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(i){return function(u){return function(i){if(n)throw new TypeError("Generator is already executing.");for(;s&&(s=0,i[0]&&(o=0)),o;)try{if(n=1,r&&(a=2&i[0]?r.return:i[0]?r.throw||((a=r.return)&&a.call(r),0):r.next)&&!(a=a.call(r,i[1])).done)return a;switch(r=0,a&&(i=[2&i[0],a.value]),i[0]){case 0:case 1:a=i;break;case 4:return o.label++,{value:i[1],done:!1};case 5:o.label++,r=i[1],i=[0];continue;case 7:i=o.ops.pop(),o.trys.pop();continue;default:if(!((a=(a=o.trys).length>0&&a[a.length-1])||6!==i[0]&&2!==i[0])){o=0;continue}if(3===i[0]&&(!a||i[1]>a[0]&&i[1]<a[3])){o.label=i[1];break}if(6===i[0]&&o.label<a[1]){o.label=a[1],a=i;break}if(a&&o.label<a[2]){o.label=a[2],o.ops.push(i);break}a[2]&&o.ops.pop(),o.trys.pop();continue}i=t.call(e,o)}catch(e){i=[6,e],r=0}finally{n=a=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,u])}}}(this,(function(r){switch(r.label){case 0:return uv?(uv.classList.add("index__root--eFmu9"),(e=document.createElement("video")).classList.add("index__video--T7iZS"),uv.appendChild(e),(t=document.createElement("canvas")).classList.add("index__canvas--A7HJv"),uv.appendChild(t),[4,(n=new ov(uv,e,t)).startUp()]):[2];case 1:return r.sent(),console.log(n.devices),[4,tv("/box/model.json","/lan/model.json",(function(e,t){document.body.innerText="Download progress: "+e/t*100+"%"}))];case 2:return r.sent(),new iv,[2]}}))},new((dv=void 0)||(dv=Promise))((function(e,t){function n(e){try{a(pv.next(e))}catch(e){t(e)}}function r(e){try{a(pv.throw(e))}catch(e){t(e)}}function a(t){var a;t.done?e(t.value):(a=t.value,a instanceof dv?a:new dv((function(e){e(a)}))).then(n,r)}a((pv=pv.apply(lv,cv||[])).next())}))})()})();